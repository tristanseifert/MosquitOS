     1                                  	BITS	16
     2                                  	org		$0500
     3                                  
     4                                  ; Kernel will be loaded to segment $0A80, or $00A800 physical
     5                                  kern_loc:				EQU $0A80
     6                                  kern_loc_phys:			EQU kern_loc<<4
     7                                  kern_start:				EQU 6
     8                                  kern_len:				EQU 32									; Length in sectors
     9                                  
    10                                  ; Location to store various BIOS info at
    11                                  Kern_Info_Struct:		EQU $0160								; $001600 phys (len = $400 max)
    12                                  Kern_Info_StructPhys:	EQU (Kern_Info_Struct<<4)
    13                                  VESA_SupportedModes:	EQU	$01A0								; $001A00 phys (len = $200)
    14                                  BIOS_MemMapSeg:			EQU	$0200								; $002000 phys (len = $800 max)
    15                                  
    16                                  ; Physical protected mode addresses
    17                                  MMU_PageDir:			EQU $003000
    18                                  MMU_PageTable1:			EQU $004000
    19                                  MMU_PageTable2:			EQU $005000
    20                                  MMU_PageTable3:			EQU $006000
    21                                  MMU_PageTable4:			EQU $007000
    22                                  MMU_PageTable5:			EQU $008000
    23                                  
    24                                  ;	+$00 uint32_t munchieValue; // Should be "KERN"
    25                                  ;	+$04 uint16_t supportBits;
    26                                  ;	+$06 uint16_t high16Mem; // 64K blocks above 16M
    27                                  ;	+$08 uint16_t low16Mem; // 1k blocks below 16M
    28                                  ;	+$0A uint32_t memMap; // 32-bit ptr to list
    29                                  ;	+$0E uint16_t numMemMapEnt; // Number of entries in above map
    30                                  ;	+$10 uint8_t vesaSupport;
    31                                  ;	+$11 uint8_t bootDrive;
    32                                  ;	+$12 uint32_t vesaMap;
    33                                  
    34                                  stage2_start:
    35 00000000 B80080                  	mov		ax, $8000											; AX = stack segment value (Stack to go at $80000)
    36 00000003 8ED0                    	mov 	ss, ax
    37 00000005 BC0010                  	mov 	sp, 4096											; Set up SP
    38                                  
    39 00000008 8CC8                    	mov 	ax, cs												; Set data segment to where we're loaded
    40 0000000A 8ED8                    	mov 	ds, ax
    41                                  
    42 0000000C 8816[9507]              	mov		BYTE [BootDevice], dl								; Save boot device number
    43 00000010 8816[B10B]              	mov		BYTE [FAT_Drive], dl								; Set FAT read drive
    44                                  
    45 00000014 66C70600164B45524E      	mov		DWORD [Kern_Info_StructPhys], "KERN"				; Set magic value for kern struct
    46                                  
    47 0000001D A0[9507]                	mov		al, [BootDevice]									; Set boot drive
    48 00000020 A21116                  	mov		BYTE [Kern_Info_StructPhys+$11], al					; ""
    49                                  
    50                                  	; Set up video
    51 00000023 B400                    	mov		ah, $00												; Change video mode
    52 00000025 B003                    	mov		al, $03												; 80x25 text mode
    53 00000027 CD10                    	int		$10													; Call video BIOS
    54                                  
    55 00000029 BE[9C05]                	mov 	si, str_stage2loaded								; Put string position into SI
    56 0000002C 31D2                    	xor		dx, dx												; Cursor position
    57 0000002E BF2F00                  	mov		di, $2F												; Set colour
    58 00000031 E8C203                  	call 	print_string										; Call string printing routine
    59                                  
    60                                  	; Call VESA BIOS routines to get supported video modes
    61 00000034 B8A001                  	mov		ax, VESA_SupportedModes								; Memory location of supported mode struct
    62 00000037 8EC0                    	mov		es, ax												; ""
    63 00000039 31FF                    	xor		di, di												; Offset 0 in segment
    64                                  
    65 0000003B 2666C70556424532        	mov		[es:di], DWORD "VBE2"								; Tell BIOS we want 512 bytes of data
    66                                  
    67 00000043 B8004F                  	mov		ax, $4F00											; VESA BIOS routines â€” get supported modes
    68 00000046 CD10                    	int		$10													; Perform lookup
    69                                  
    70 00000048 84E4                    	test	ah, ah												; Is AH not zero (i.e. error)
    71 0000004A 7400                    	je		.vesaDone											; If so, VESA is unsupported
    72                                  
    73                                  .vesaDone:
    74                                  	; Call BIOS to get memory information
    75 0000004C 31C9                    	xor 	cx, cx
    76 0000004E 31D2                    	xor 	dx, dx
    77 00000050 B801E8                  	mov 	ax, $0E801
    78 00000053 CD15                    	int 	$15													; Request upper memory size
    79 00000055 7250                    	jc 		error_memoryDetect
    80 00000057 80FC86                  	cmp 	ah, $86												; Unsupported function
    81 0000005A 744B                    	je		error_memoryDetect
    82 0000005C 80FC80                  	cmp		ah, $80												; Invalid command
    83 0000005F 7446                    	je		error_memoryDetect
    84 00000061 E304                    	jcxz 	.useax												; Was the CX result invalid?
    85                                   
    86 00000063 89C8                    	mov		ax, cx												; Number of continuous 1K blocks (1M-16M)
    87 00000065 89D3                    	mov		bx, dx												; Number of continuous 64K block above 16M
    88                                  
    89                                  .useax:
    90 00000067 31FF                    	xor		di, di												; Clear DI
    91 00000069 891E[9807]              	mov		WORD [MemBlocksAbove16M], bx						; Store amount of memory available
    92 0000006D 891E0616                	mov		WORD [Kern_Info_StructPhys+$06], bx					; Highmem
    93 00000071 A3[9A07]                	mov		WORD [MemBlocksBelow16M], ax						; ""
    94 00000074 A30816                  	mov		WORD [Kern_Info_StructPhys+$08], ax					; Lowmem
    95                                  
    96 00000077 E85703                  	call	display_memsize										; Display the memory size
    97                                  
    98                                  	; Fetch memory map
    99 0000007A B80002                  	mov 	ax, BIOS_MemMapSeg									; Write mem map to $01800 in physical space
   100 0000007D 8EC0                    	mov 	es, ax
   101 0000007F 31FF                    	xor		di, di												; Start of segment
   102                                  
   103 00000081 E81B04                  	call	fetch_mem_map										; Fetch a memory map
   104 00000084 7221                    	jc 		SHORT error_memoryDetect							; Branch if error
   105                                  
   106 00000086 892E0E16                	mov		WORD [Kern_Info_StructPhys+$0E], bp					; ""
   107 0000008A 66C7060A1600200000      	mov		DWORD [Kern_Info_StructPhys+$0A], (BIOS_MemMapSeg<<4); Physical location of table
   108                                  
   109                                  	; Initialise FAT library
   110 00000093 E8AA07                  	call	FAT_Init
   111                                  
   112                                  	; Check which partitions are bootable from MBR partition map
   113 00000096 E88702                  	call	find_bootable_partitions
   114 00000099 C606[A607]00            	mov		BYTE [HDD_Selected], 0								; Clear HDD selection
   115                                  
   116                                  	; Set up the partition chooser UI
   117 0000009E E80201                  	call	render_partition_chooser
   118                                  
   119                                  	; Process keypresses, and loads kernel from FS if ENTER is pressed
   120 000000A1 E8F801                  	call	chooser_loop
   121 000000A4 E90800                  	jmp		boot
   122                                  
   123                                  ;========================================================================================
   124                                  ; Memory detection error handler
   125                                  ;========================================================================================
   126                                  error_memoryDetect:
   127 000000A7 BE[B705]                	mov 	si, str_errorDetectMem								; Put string position into SI
   128 000000AA E84303                  	call 	print_error											; Call string printing routine
   129 000000AD EBFE                    	jmp		$
   130                                  
   131                                  ;========================================================================================
   132                                  ; Code to boot the kernel
   133                                  ;========================================================================================
   134                                  boot:
   135                                  	; Hide cursor
   136 000000AF 31D2                    	xor		dx, dx												; Clear dx
   137 000000B1 F7D2                    	not		dx													; dx = $FFFF
   138 000000B3 B402                    	mov 	ah, $02												; Set cursor position
   139 000000B5 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   140 000000B7 CD10                    	int		$10													; Set cursor
   141                                  
   142                                  	; Go into SVGA mode $101 (640x480x8bpp)
   143 000000B9 BB0181                  	mov		bx, $8101											; SVGA mode
   144 000000BC B8024F                  	mov		ax, $4F02											; SVGA routine calls
   145 000000BF CD10                    	int		$10													; Call video BIOS
   146                                  
   147                                  ;	mov		ax, $0013
   148                                  ;	int		$10
   149                                  
   150                                  
   151                                  	; Set up GDT
   152 000000C1 FA                      	cli															; Disable ints
   153 000000C2 0F0116[3808]            	lgdt	[gdt_table]											; Set up GDTR
   154                                  
   155                                  	; Jump into protected mode, woot!
   156 000000C7 0F20C0                  	mov		eax, cr0											; Get control reg
   157 000000CA 0C01                    	or		al, 00000001b										; Set PE bit
   158 000000CC 0F22C0                  	mov		cr0, eax											; Write control reg
   159                                  
   160                                  	; Set up selectors
   161 000000CF B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   162 000000D2 8ED8                    	mov		ds, ax												; Set data selector
   163                                  
   164 000000D4 B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   165 000000D7 8EC0                    	mov		es, ax												; Update other selectors to point to data segment
   166 000000D9 8EE0                    	mov		fs, ax
   167 000000DB 8EE8                    	mov		gs, ax
   168 000000DD 8ED0                    	mov		ss, ax
   169                                  
   170                                  	; The kernel is loaded to $00003000 phys (segmented address 0300h:0000h)
   171 000000DF 66                      	db		$66													; 32-bit prefix
   172 000000E0 EA                      	db		$0EA												; Far jump opcode
   173 000000E1 [E7000000]              	dd		copy_kernel											; Jump to kernel copying routine
   174 000000E5 0800                    	dw		$08													; Selector for CODE32_DESCRIPTOR
   175                                  
   176                                  	BITS	32
   177                                  copy_kernel:
   178 000000E7 BC00004000              	mov		esp, $400000										; Stackzors at $400000
   179                                  
   180 000000EC B800A80000              	mov		eax, kern_loc_phys									; Physical kernel location
   181 000000F1 BB00001000              	mov		ebx, $00100000										; Destination memory address
   182 000000F6 B900400000              	mov		ecx, $4000											; Number of long-words to copy (64KB)
   183                                  
   184 000000FB 90                      	align	4													; DWORD align
   185                                  .copy:
   186 000000FC 8B10                    	mov		edx, DWORD [eax]									; Read a DWORD from lowmem
   187 000000FE 8913                    	mov		DWORD [ebx], edx									; Write DWORD to himem
   188                                  
   189 00000100 0504000000              	add		eax, $04											; Increment read ptr
   190 00000105 81C304000000            	add		ebx, $04											; Increment write ptr
   191                                  
   192 0000010B E2EF                    	loop	.copy												; Loop and copy everything
   193                                  
   194                                  	; Here, we build a page directory and table to map $C0000000 to $00100000.
   195 0000010D 31C0                    	xor		eax, eax
   196 0000010F BB00300000              	mov		ebx, MMU_PageDir
   197 00000114 B900100000              	mov		ecx, $1000
   198                                  
   199                                  .clrTablesLoop:
   200 00000119 8903                    	mov		DWORD [ebx], eax
   201 0000011B 81C304000000            	add		ebx, $04
   202 00000121 E2F6                    	loop	.clrTablesLoop
   203                                  
   204                                  
   205                                  	; Since we only need to map 4M for right now, concern ourselves only with entry 0x300 and 0x000
   206                                  	; Also, map 0x00000000 to 0x003FFFFF
   207 00000123 C70500300000034000-     	mov		DWORD [MMU_PageDir+0x000], (MMU_PageTable1 | $3)
   208 0000012C 00                 
   209                                  
   210 0000012D C705003C0000035000-     	mov		DWORD [MMU_PageDir+0xC00], (MMU_PageTable2 | $3)
   211 00000136 00                 
   212 00000137 C705043C0000036000-     	mov		DWORD [MMU_PageDir+0xC04], (MMU_PageTable3 | $3)
   213 00000140 00                 
   214 00000141 C705083C0000037000-     	mov		DWORD [MMU_PageDir+0xC08], (MMU_PageTable4 | $3)
   215 0000014A 00                 
   216 0000014B C7050C3C0000038000-     	mov		DWORD [MMU_PageDir+0xC0C], (MMU_PageTable5 | $3)
   217 00000154 00                 
   218                                  
   219                                  
   220                                  	; Run a loop 1024 times to fill the first page table
   221 00000155 B900040000              	mov		ecx, $400
   222 0000015A 31DB                    	xor		ebx, ebx											; Page table offset
   223 0000015C B807000000              	mov		eax, DWORD $00000007									; Physical address start
   224                                  
   225                                  .fillPageTable1:
   226 00000161 89049D00400000          	mov		DWORD [MMU_PageTable1+ebx*4], eax					; Write physical location
   227                                  
   228 00000168 43                      	inc		ebx													; Go to next entry in page table
   229 00000169 0500100000              	add		eax, $1000											; Increment physical address
   230 0000016E E2F1                    	loop	.fillPageTable1
   231                                  
   232                                  
   233                                  	; Run a loop 8192 times to fill the second page table
   234 00000170 B900100000              	mov		ecx, $1000
   235 00000175 31DB                    	xor		ebx, ebx											; Page table offset
   236 00000177 B807001000              	mov		eax, DWORD $00100007								; Physical address start
   237                                  
   238                                  .fillPageTable2:
   239 0000017C 89049D00500000          	mov		DWORD [MMU_PageTable2+ebx*4], eax					; Write physical location
   240                                  
   241 00000183 43                      	inc		ebx													; Go to next entry in page table
   242 00000184 0500100000              	add		eax, $1000											; Increment physical address
   243 00000189 E2F1                    	loop	.fillPageTable2
   244                                  
   245                                  
   246                                  	; Set paging directory to CR3
   247 0000018B B800300000              	mov		eax, MMU_PageDir
   248 00000190 0F22D8                  	mov		cr3, eax
   249                                  
   250                                  	; Enable paging in CR0
   251 00000193 0F20C0                  	mov		eax, cr0
   252 00000196 0D00000080              	or		eax, $80000000
   253 0000019B 0F22C0                  	mov		cr0, eax
   254                                  
   255                                  	; Jump into kernel
   256 0000019E E9(000000C0)            	jmp		$0C0000000
   257                                  
   258                                  	BITS	16
   259                                  
   260                                  ;========================================================================================
   261                                  ; Renders the partition chooser
   262                                  ;========================================================================================
   263                                  render_partition_chooser:
   264 000001A3 BE[6506]                	mov 	si, str_select_partition							; Put string position into SI
   265 000001A6 BA0105                  	mov		dx, $0501											; Cursor position
   266 000001A9 BF0700                  	mov		di, $07												; Set colour
   267 000001AC E84702                  	call 	print_string										; Call string printing routine
   268                                  
   269 000001AF C706[9607]0407          	mov		WORD [LastCursorPosition], 0x0704					; Read last cursor position
   270                                  
   271 000001B5 66BA[9E070000]          	mov		edx, HDD_BootablePartitions							; EDX contains bootable partition ptr
   272 000001BB B90400                  	mov		cx, $04												; Loop 4x
   273                                  
   274                                  .disp_loop:
   275 000001BE 678A02                  	mov		al, BYTE [edx]										; Read bootability
   276 000001C1 2480                    	and		al, $80												; Get high bit only
   277 000001C3 3C80                    	cmp		al, $80												; Is it $80?
   278 000001C5 7505                    	jne		.not_bootable										; If not, it's not a bootable drive
   279                                  
   280 000001C7 E81300                  	call	.render_boot										; Render bootable drive label
   281                                  
   282 000001CA EB03                    	jmp		SHORT .next											; Skip over non-bootable code
   283                                  
   284                                  .not_bootable:
   285 000001CC E87900                  	call	.render_noboot										; Render non-bootable drive label
   286                                  
   287                                  .next:
   288 000001CF 6642                    	inc		edx													; Go to next item
   289 000001D1 E2EB                    	loop	.disp_loop											; Loop over all 4 partitions
   290                                  
   291 000001D3 BA010C                  	mov		dx, $0C01
   292 000001D6 BE[F806]                	mov		si, str_err_clear_err								; Clear error
   293 000001D9 E81A02                  	call	print_string										; Display
   294                                  
   295 000001DC C3                      	ret
   296                                  
   297                                  ;========================================================================================
   298                                  ; Renders an entry for a bootable drive
   299                                  ;========================================================================================
   300                                  .render_boot:
   301 000001DD B004                    	mov		al, $04												; Max drive num to al
   302 000001DF 28C8                    	sub		al, cl												; Subtract loop counter
   303 000001E1 A2[4402]                	mov		BYTE [.index], al									; Write index
   304 000001E4 0430                    	add		al, $30												; ASCII numbers
   305                                  
   306 000001E6 66C706[D707]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   307 000001EE 2C                 
   308 000001EF A2[DB07]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   309 000001F2 C706[DC07]3A20          	mov		WORD [Temp_StrBuf+5], ": "							; Colon, space
   310                                  
   311 000001F8 60                      	pusha														; Push registers
   312 000001F9 66BA[DE070000]          	mov		edx, Temp_StrBuf+7									; String buffer write place
   313 000001FF 66BB[A7070000]          	mov		ebx, HDD_PartitionNames								; Partition names
   314 00000205 B90C00                  	mov		cx, $0C												; $0C characters
   315                                  
   316                                  .copyNameLoop:
   317 00000208 678A03                  	mov		al, BYTE [ebx]										; Copy a character
   318 0000020B 678802                  	mov		BYTE [edx], al										; Write to temp buffer
   319 0000020E 6643                    	inc		ebx													; Increment read pointer
   320 00000210 6642                    	inc		edx													; Increment write pointer
   321 00000212 E2F4                    	loop	.copyNameLoop
   322                                  
   323 00000214 67C742FF0A00            	mov		WORD [edx-1], 0x000A								; Insert newline
   324                                  
   325 0000021A 6631C0                  	xor		eax, eax											; Clear EAX
   326 0000021D 66BA[A2070000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type matrix
   327 00000223 0216[4402]              	add		dl, BYTE [.index]
   328 00000227 678A02                  	mov		al, BYTE [edx]										; Read FAT type to AL
   329                                  
   330 0000022A 8A1E[A607]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   331 0000022E 80E303                  	and		bl, $3												; Get low 2 bits only
   332 00000231 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   333 00000233 7503                    	jne		.no_highlight										; If not, branch.
   334                                  
   335 00000235 BF7000                  	mov		di, $070											; Black text on white background
   336                                  
   337                                  .no_highlight:
   338 00000238 8B16[9607]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   339 0000023C BE[D707]                	mov		si, Temp_StrBuf										; Temporary string buffer
   340 0000023F E8B401                  	call 	print_string										; Call string printing routine
   341 00000242 61                      	popa														; Pop registers
   342                                  
   343 00000243 C3                      	ret
   344                                  
   345                                  .index:
   346 00000244 00                      	db	0
   347                                  
   348                                  ;========================================================================================
   349                                  ; Renders an entry for a non-bootable drive.
   350                                  ;========================================================================================
   351 00000245 90<rept>                	align 4
   352                                  
   353                                  .render_noboot:
   354 00000248 B004                    	mov		al, $04												; Max drive num to al
   355 0000024A 28C8                    	sub		al, cl												; Subtract loop counter
   356 0000024C 0430                    	add		al, $30												; ASCII numbers
   357                                  
   358 0000024E 66C706[D707]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   359 00000256 2C                 
   360 00000257 A2[DB07]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   361 0000025A 66C706[DC07]3A204E-     	mov		DWORD [Temp_StrBuf+5], ": No"						; "Not Bootable"
   362 00000262 6F                 
   363 00000263 66C706[E007]742042-     	mov		DWORD [Temp_StrBuf+9], "t Bo"
   364 0000026B 6F                 
   365 0000026C 66C706[E407]6F7461-     	mov		DWORD [Temp_StrBuf+13], "otab"
   366 00000274 62                 
   367 00000275 C706[E807]6C65          	mov		WORD [Temp_StrBuf+17], "le"
   368 0000027B C706[EA07]0A00          	mov		WORD [Temp_StrBuf+19], 0x000A						; Newline, terminator
   369                                  
   370 00000281 60                      	pusha														; Push registers
   371                                  
   372 00000282 8A1E[A607]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   373 00000286 80E303                  	and		bl, $3												; Get low 2 bits only
   374 00000289 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   375 0000028B 7503                    	jne		.no_highlight2										; If not, branch.
   376                                  
   377 0000028D BF7000                  	mov		di, $070											; Black text on white background
   378                                  
   379                                  .no_highlight2:
   380 00000290 8B16[9607]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   381 00000294 BE[D707]                	mov		si, Temp_StrBuf										; Temporary string buffer
   382 00000297 E85C01                  	call 	print_string										; Call string printing routine
   383 0000029A 61                      	popa														; Pop registers
   384                                  
   385 0000029B C3                      	ret
   386                                  
   387                                  ;========================================================================================
   388                                  ; Handle keypresses for chooser
   389                                  ;========================================================================================
   390                                  chooser_loop:
   391 0000029C E91500                  	jmp		partition_chooser_enter
   392                                  
   393 0000029F 30E4                    	xor		ah, ah												; Wait for keystroke
   394 000002A1 CD16                    	int		$16													; Call into BIOS
   395                                  
   396 000002A3 80FC50                  	cmp		ah, $50												; Down pressed?
   397 000002A6 7459                    	je		partition_chooser_dn
   398                                  
   399 000002A8 80FC48                  	cmp		ah, $48												; Up pressed?
   400 000002AB 7463                    	je		partition_chooser_up
   401                                  
   402 000002AD 80FC1C                  	cmp		ah, $1C												; Enter pressed?
   403 000002B0 7402                    	je		partition_chooser_enter
   404                                  
   405 000002B2 EBE8                    	jmp		chooser_loop
   406                                  
   407                                  partition_chooser_enter:
   408 000002B4 31DB                    	xor		bx, bx												; Clear BX
   409 000002B6 8A1E[A607]              	mov		bl, BYTE [HDD_Selected]								; Get selection
   410                                  
   411 000002BA 8A87[9E07]              	mov		al, BYTE [HDD_BootablePartitions+bx]				; Check bootability status
   412 000002BE 2480                    	and		al, $80												; Get high bit only
   413 000002C0 3C80                    	cmp		al, $80
   414 000002C2 7527                    	jne		.noBootErr											; If not bootable, branch
   415                                  
   416                                  
   417 000002C4 BE[0C08]                	mov		si, kernel_filename									; Filename to find
   418 000002C7 E8C107                  	call	FAT_FindFileAtRoot									; Find file
   419 000002CA 722A                    	jc		.fileNotFound										; Carry set = KERNEL.BIN not found
   420                                  
   421 000002CC 66A3[0808]              	mov		DWORD [kernel_cluster], eax							; Store cluster
   422                                  
   423 000002D0 31C0                    	xor		ax, ax												; Segment 0
   424 000002D2 8EC0                    	mov		es, ax												; Write segment											
   425 000002D4 BF00A8                  	mov		di, kern_loc_phys									; Offset into segment
   426                                  
   427 000002D7 66A1[0808]              	mov		eax, DWORD [kernel_cluster]							; Kernel's cluster location
   428 000002DB E82208                  	call	FAT_ReadFile										; Read file
   429                                  
   430 000002DE BE[4A07]                	mov 	si, str_kernel_loaded_ok							; Put string position into SI
   431 000002E1 BA010C                  	mov		dx, $0C01											; Cursor position
   432 000002E4 BF0200                  	mov		di, $02												; Set colour
   433 000002E7 E80C01                  	call 	print_string										; Call string printing routine
   434                                  
   435 000002EA C3                      	ret
   436                                  
   437                                  .noBootErr:
   438 000002EB BA010C                  	mov		dx, $0C01
   439 000002EE BE[9A06]                	mov		si, str_err_not_bootable							; Not bootable error
   440 000002F1 E8FC00                  	call	print_error											; Display
   441 000002F4 EBA6                    	jmp		chooser_loop
   442                                  
   443                                  .fileNotFound:
   444 000002F6 BA010C                  	mov		dx, $0C01
   445 000002F9 BE[C406]                	mov		si, str_err_kern_not_found							; Not found error
   446 000002FC E8F100                  	call	print_error											; Display
   447 000002FF EB9B                    	jmp		chooser_loop
   448                                  
   449                                  partition_chooser_dn:
   450 00000301 A0[A607]                	mov		al, BYTE [HDD_Selected]								; Read selection
   451 00000304 FEC8                    	dec		al													; Move cursor up
   452 00000306 2403                    	and		al, $03												; Get low 2 bits only
   453 00000308 A2[A607]                	mov		BYTE [HDD_Selected], al								; Restore
   454                                  
   455 0000030B E895FE                  	call	render_partition_chooser							; Update display
   456 0000030E EB8C                    	jmp		chooser_loop
   457                                  
   458                                  partition_chooser_up:
   459 00000310 A0[A607]                	mov		al, BYTE [HDD_Selected]								; Read selection
   460 00000313 FEC0                    	inc		al													; Move cursor down
   461 00000315 2403                    	and		al, $03												; Get low 2 bits only
   462 00000317 A2[A607]                	mov		BYTE [HDD_Selected], al								; Restore
   463                                  
   464 0000031A E886FE                  	call	render_partition_chooser							; Update display
   465 0000031D E97CFF                  	jmp		chooser_loop
   466                                  
   467                                  ;========================================================================================
   468                                  ; Finds all partitions that are bootable.
   469                                  ;========================================================================================
   470                                  find_bootable_partitions:
   471 00000320 B90400                  	mov		cx, $4												; MBR contains 4 partition maps
   472                                  
   473 00000323 B8C007                  	mov		ax, $07C0											; Bootloader at 0x7C00
   474 00000326 8EC0                    	mov		es, ax												; Set ES to the bootloader's place in memory
   475 00000328 BFBE01                  	mov		di, $1BE											; Start of partition map
   476                                  
   477 0000032B 8CD8                    	mov		ax, ds												; Fetch data segment
   478 0000032D 8EE8                    	mov		gs, ax												; Set GS to data segment
   479                                  
   480 0000032F 66BE[9E070000]          	mov		esi, HDD_BootablePartitions							; ESI contains bootable partition ptr
   481 00000335 66BA[A7070000]          	mov		edx, HDD_PartitionNames								; Partition name ptr
   482                                  
   483                                  .loop:
   484 0000033B 268A05                  	mov		al, BYTE [es:di]									; Read bootable flag
   485 0000033E 2480                    	and		al, $80												; Get high bit only
   486 00000340 3C80                    	cmp		al, $80												; Is it $80?
   487 00000342 754B                    	jne		.not_bootable										; If not, it's not a bootable drive
   488                                  
   489 00000344 678806                  	mov		BYTE [esi], al										; Write bootability flag
   490                                  
   491 00000347 880E[A607]              	mov		BYTE [HDD_Selected], cl								; Write index
   492                                  
   493                                  	; Try to read the LBA of the partition
   494 0000034B 26668B4508              	mov		eax, DWORD [es:di+8]								; Read partition LBA
   495 00000350 663D00000000            	cmp		eax, $00											; Is it zero?
   496 00000356 7437                    	je		.no_valid_lba										; If so, fuck off
   497                                  
   498 00000358 66A3[0008]              	mov		DWORD [ExtendedRead_Table+0x08], eax				; Write LBA
   499 0000035C C706[FA07]0100          	mov		WORD [ExtendedRead_Table+0x02], 0x01				; Read one sector
   500 00000362 C706[FC07][D00B]        	mov		WORD [ExtendedRead_Table+0x04], SectorBuf			; Temporary sector buffer offset (seg 0)
   501                                  
   502 00000368 66A3[AC0B]              	mov		DWORD [FAT_PartitionOffset], eax					; Write offset into FAT
   503                                  
   504 0000036C 60                      	pusha														; Push registers (BIOS may clobber them)
   505 0000036D BE[F807]                	mov 	si, ExtendedRead_Table								; address of "disk address packet"
   506 00000370 B442                    	mov 	ah, $42												; Extended Read
   507 00000372 8A16[9507]              	mov		dl, BYTE [BootDevice]								; Device number
   508 00000376 CD13                    	int 	$13
   509 00000378 61                      	popa														; Pop registers
   510 00000379 7214                    	jc 		SHORT .no_valid_lba									; If error, fuck off
   511                                  
   512 0000037B E82100                  	call	.typeDetermine										; Determine type and label loc
   513                                  
   514 0000037E 51                      	push	cx													; Back up original loop counter
   515                                  
   516 0000037F B90B00                  	mov		cx, $0B												; Copy 0xB bytes
   517                                  .copy_str_loop:
   518 00000382 678A18                  	mov		bl, BYTE [eax]										; Copy from source
   519 00000385 67881A                  	mov		BYTE [edx], bl										; Write to target buffer
   520 00000388 6640                    	inc		eax													; Increment read pointer
   521 0000038A 6642                    	inc		edx													; Increment write pointer
   522 0000038C E2F4                    	loop	.copy_str_loop										; Copy all bytes.
   523                                  
   524 0000038E 59                      	pop		cx													; Restore original loop counter.
   525                                  
   526                                  .no_valid_lba:
   527                                  
   528                                  .not_bootable:
   529 0000038F 81C71000                	add		di, $10												; Go to next entry in bootsector
   530 00000393 6646                    	inc		esi													; Write next bootability flag
   531 00000395 6681C20C000000          	add		edx, $0C											; Each entry of partition names is 0x0C in length
   532 0000039C E29D                    	loop	.loop												; Loop through all partitions
   533                                  
   534                                  .done:
   535 0000039E C3                      	ret
   536                                  
   537                                  ; Determines FAT type and stores pointer to read volume label in eax
   538                                  .typeDetermine:
   539 0000039F 6656                    	push	esi													; Push old ESI
   540 000003A1 BE[D00B]                	mov		si, SectorBuf										; Sector buffer
   541 000003A4 E8B304                  	call	FAT_DetermineType									; Determine type of FS
   542 000003A7 665E                    	pop		esi													; Pop ESI
   543                                  
   544 000003A9 6652                    	push	edx													; Back up EDX
   545 000003AB B304                    	mov		bl, $04												; Max drive num to al
   546 000003AD 28CB                    	sub		bl, cl												; Subtract loop counter
   547                                  
   548 000003AF 66BA[A2070000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type ptr
   549 000003B5 28DA                    	sub		dl, bl												; Subtract index
   550 000003B7 678802                  	mov		BYTE [edx], al										; Write FAT size
   551 000003BA 665A                    	pop		edx													; Restore EDX
   552                                  
   553 000003BC 3C20                    	cmp		al, $20												; Is it a FAT32 volume?
   554 000003BE 7509                    	jne		.fat16_label										; If so, branch
   555                                  
   556 000003C0 66B8[170C0000]          	mov		eax, SectorBuf+$47									; FAT32 has volume label at 0x47
   557                                  
   558 000003C6 E90600                  	jmp		.copy												; Copy label
   559                                  
   560                                  	; Extract volume label from sector buffer
   561                                  .fat16_label:
   562 000003C9 66B8[FB0B0000]          	mov		eax, SectorBuf+$2B									; FAT16 has volume label at 0x2B
   563                                  
   564                                  .copy:
   565 000003CF C3                      	ret
   566                                  
   567                                  .index:
   568 000003D0 00                      	db		0
   569                                  
   570                                  ;========================================================================================
   571                                  ; Displays the memory size on the screen 
   572                                  ;========================================================================================
   573                                  display_memsize:
   574 000003D1 BE[0F06]                	mov 	si, str_available_lomem								; Put string position into SI
   575 000003D4 BA0002                  	mov		dx, $0200
   576 000003D7 E81C00                  	call 	print_string										; Call string printing routine
   577 000003DA A1[9A07]                	mov		ax, WORD [MemBlocksBelow16M]						; Get total of memory blocks to EDX
   578 000003DD E88100                  	call	hex_to_ascii
   579                                  
   580 000003E0 BE[3A06]                	mov 	si, str_available_himem								; Put string position into SI
   581 000003E3 BA0003                  	mov		dx, $0300
   582 000003E6 E80D00                  	call 	print_string										; Call string printing routine
   583 000003E9 A1[9807]                	mov		ax, WORD [MemBlocksAbove16M]						; Get total of memory blocks to EDX
   584 000003EC E87200                  	call	hex_to_ascii
   585                                  
   586 000003EF C3                      	ret
   587                                  
   588                                  ;========================================================================================
   589                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h with the styling
   590                                  ; required for an error string.
   591                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   592                                  ;========================================================================================
   593                                  print_error:
   594 000003F0 BF4F00                  	mov		di, $04F											; White text on red background
   595 000003F3 E90000                  	jmp 	print_string										; Call string printing routine
   596                                  
   597                                  ;========================================================================================
   598                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h.
   599                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   600                                  ;========================================================================================
   601                                  print_string:
   602 000003F6 52                      	push	dx													; Push column
   603                                  
   604 000003F7 85FF                    	test	di, di												; Check if DI is set
   605 000003F9 7406                    	jz		.useDefaultColour									; If so, branch
   606                                  
   607 000003FB 89F8                    	mov		ax, di												; Set colour
   608 000003FD 88C3                    	mov		bl, al												; Get low byte only
   609 000003FF EB02                    	jmp		SHORT .setCursor
   610                                  
   611                                  .useDefaultColour:
   612 00000401 B307                    	mov		bl, $007											; Light gray text on black background
   613                                  
   614                                  .setCursor:
   615 00000403 B402                    	mov 	ah, $02												; Set cursor position
   616 00000405 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   617 00000407 CD10                    	int		$10													; Set cursor
   618                                  
   619                                  .repeat:
   620 00000409 AC                      	lodsb														; Get character from string
   621 0000040A 3C00                    	cmp 	al, 0
   622 0000040C 7417                    	je		.done												; If char is zero, end of string
   623                                  	
   624 0000040E 3C0A                    	cmp 	al, $0A												; Process newline
   625 00000410 741B                    	je		.newline
   626                                  
   627 00000412 B90100                  	mov		cx, $01												; Write one ASCII character
   628 00000415 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   629 00000417 B409                    	mov 	ah, $09												; Write character
   630 00000419 CD10                    	int		$10													; Print character
   631                                  
   632 0000041B B402                    	mov 	ah, $02												; Set cursor position
   633 0000041D 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   634 0000041F FEC2                    	inc		dl													; Increment column
   635 00000421 CD10                    	int		$10													; Set cursor
   636                                  
   637 00000423 EBE4                    	jmp		.repeat
   638                                  
   639                                  .done:
   640 00000425 8916[9607]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   641 00000429 5A                      	pop		dx													; Pop position
   642 0000042A 31FF                    	xor		di, di												; Clear colour
   643 0000042C C3                      	ret
   644                                  
   645                                  .newline:
   646 0000042D 5A                      	pop		dx													; Get original column
   647 0000042E FEC6                    	inc		dh													; Increment row
   648 00000430 52                      	push	dx													; Push it back to stack
   649 00000431 EBD6                    	jmp		.repeat
   650                                  
   651                                  ;========================================================================================
   652                                  ; Prints the character in al to the screen at the current cursor position, using the
   653                                  ; colour in di.
   654                                  ;========================================================================================
   655                                  putc:
   656 00000433 85FF                    	test	di, di												; Check if DI is set
   657 00000435 7406                    	jz		.useDefaultColour									; If so, branch
   658                                  
   659 00000437 89F8                    	mov		ax, di												; Set colour
   660 00000439 88C3                    	mov		bl, al												; Get low byte only
   661 0000043B EB02                    	jmp		SHORT .setCursor
   662                                  
   663                                  .useDefaultColour:
   664 0000043D B307                    	mov		bl, $007											; Light gray text on black background
   665                                  
   666                                  .setCursor:
   667 0000043F 8B16[9607]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   668 00000443 B402                    	mov 	ah, $02												; Set cursor position
   669 00000445 B700                    	mov		bh, $0												; Video page 0
   670 00000447 CD10                    	int		$10													; Set cursor
   671                                  
   672 00000449 B90100                  	mov		cx, $01												; Write one ASCII character
   673 0000044C B700                    	mov		bh, $0												; Video page 0
   674 0000044E B409                    	mov 	ah, $09												; Write character
   675 00000450 CD10                    	int		$10													; Print character
   676                                  
   677 00000452 FEC2                    	inc		dl													; Increment column
   678                                  
   679 00000454 B402                    	mov 	ah, $02												; Set cursor position
   680 00000456 B700                    	mov		bh, $0												; Video page 0
   681 00000458 CD10                    	int		$10													; Set cursor
   682                                  
   683 0000045A 8916[9607]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   684 0000045E 31FF                    	xor		di, di												; Clear colour
   685 00000460 C3                      	ret
   686                                  
   687                                  ;========================================================================================
   688                                  ; Prints the value in eax to the screen.
   689                                  ;========================================================================================
   690                                  hex_to_ascii:
   691 00000461 31C9                    	xor 	cx, cx
   692                                  
   693 00000463 88E1                    	mov 	cl, ah												; Move high byte of ax to cl
   694 00000465 E81000                  	call 	.nibble_high										; Print low nibble to ASCII
   695 00000468 88E1                    	mov 	cl, ah
   696 0000046A E81100                  	call 	.nibble_low
   697 0000046D 88C1                    	mov 	cl, al
   698 0000046F E80600                  	call 	.nibble_high
   699 00000472 88C1                    	mov 	cl, al
   700 00000474 E80700                  	call 	.nibble_low
   701 00000477 C3                      	ret
   702                                  
   703                                  .nibble_high:
   704 00000478 C0E904                  	shr 	cl, $04
   705 0000047B E90600                  	jmp 	.convert_check
   706                                  
   707                                  .nibble_low:
   708 0000047E 80E10F                  	and 	cl, $0F
   709 00000481 E90000                  	jmp 	.convert_check
   710                                  
   711                                  .convert_check:
   712 00000484 80F90A                  	cmp 	cl, $0A
   713 00000487 7D0B                    	jge 	.letter
   714 00000489 80C130                  	add 	cl, $30
   715 0000048C 50                      	push 	ax
   716 0000048D 88C8                    	mov 	al, cl
   717 0000048F E8A1FF                  	call 	putc
   718 00000492 58                      	pop 	ax
   719 00000493 C3                      	ret
   720                                  
   721                                  .letter:
   722 00000494 80C137                  	add 	cl, $37
   723 00000497 50                      	push	ax
   724 00000498 88C8                    	mov 	al, cl
   725 0000049A E896FF                  	call	putc
   726 0000049D 58                      	pop 	ax
   727 0000049E C3                      	ret
   728                                  
   729                                  ;========================================================================================
   730                                  ; Uses BIOS INT $15, EAX $E820 function to get the memory map of the system
   731                                  ; input: 	es:di = destination buffer for 24 byte entries
   732                                  ; output: 	bp = entry count, trashes all registers except esi
   733                                  ;========================================================================================
   734                                  fetch_mem_map:
   735 0000049F 6631DB                  	xor		ebx, ebx											; Clear EBX
   736 000004A2 31ED                    	xor		bp, bp												; Use BP as an entry count
   737 000004A4 66BA50414D53            	mov		edx, $0534D4150										; Place "SMAP" into edx (magic value)
   738 000004AA 66B820E80000            	mov		eax, $0E820											; Function call
   739                                  
   740 000004B0 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   741 000004B9 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   742 000004BF CD15                    	int		$15
   743                                  
   744 000004C1 7257                    	jc		SHORT .error										; If carry set, the function is unsupported
   745                                  
   746 000004C3 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   747 000004C9 6639D0                  	cmp		eax, edx											; On success, EAX = "SMAP"
   748 000004CC 754C                    	jne		SHORT .error
   749                                  
   750 000004CE 6685DB                  	test	ebx, ebx											; ebx = 0 implies list is only 1 entry long (worthless)
   751 000004D1 7447                    	je		SHORT .error
   752                                  
   753 000004D3 EB1F                    	jmp		SHORT .startLoop									; Jump into the loop
   754                                  
   755                                  .getEntryLoop:
   756 000004D5 66B820E80000            	mov		eax, $0E820											; Reset command (EAX, ECX are trashed)
   757 000004DB 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   758 000004E4 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   759 000004EA CD15                    	int		$15
   760                                  
   761 000004EC 722A                    	jc		SHORT .done											; If carry set, we are done
   762 000004EE 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   763                                  
   764                                  .startLoop:
   765 000004F4 E31D                    	jcxz	.skipEntry											; Skip any 0 length entries
   766                                  
   767 000004F6 80F914                  	cmp		cl, 20												; Did we get 24-byte ACPI 3.x data?
   768 000004F9 7607                    	jbe		SHORT .notext
   769                                  
   770 000004FB 26F6451401              	test	BYTE [es:di+20], 1									; If so, is the "ignore this data" bit clear?
   771 00000500 7411                    	je		SHORT .skipEntry
   772                                  
   773                                  .notext:
   774 00000502 26668B4D08              	mov		ecx, [es:di+8]										; get lower dword of memory region length
   775 00000507 26660B4D0C              	or		ecx, [es:di+12]										; Check if zero (OR with upper dword)
   776 0000050C 7405                    	jz		.skipEntry											; If length qword is 0, skip entry
   777                                  
   778 0000050E 45                      	inc		bp													; We got a good entry, increment count, go to next entry
   779                                  
   780 0000050F 81C71800                	add		di, 24
   781                                  
   782                                  .skipEntry:
   783 00000513 6685DB                  	test	ebx, ebx											; If EBX = 0, then the BIOS has given us all entries
   784 00000516 75BD                    	jne		SHORT .getEntryLoop
   785                                  
   786                                  .done:
   787 00000518 F8                      	clc															; There is "jc" on end of list to this point, so the carry must be cleared
   788 00000519 C3                      	ret
   789                                  
   790                                  .error:
   791 0000051A F9                      	stc															; Set carry if this BIOS sucks ass and doesn't support this
   792 0000051B C3                      	ret
   793                                  
   794                                  ;========================================================================================
   795                                  ; Writes a register dump to the VGA hardware
   796                                  ;========================================================================================
   797                                  VGA_MISC_WRITE		EQU	$3C2
   798                                  VGA_SEQ_INDEX		EQU	$3C4
   799                                  VGA_SEQ_DATA		EQU	$3C5
   800                                  VGA_CRTC_INDEX		EQU	$3D4
   801                                  VGA_CRTC_DATA		EQU	$3D5
   802                                  VGA_INSTAT_READ		EQU	$3DA
   803                                  
   804                                  NUM_SEQ_REGS		EQU	5
   805                                  NUM_CRTC_REGS		EQU	25
   806                                  
   807                                  write_regs:
   808 0000051C 56                      	push 	si
   809 0000051D 52                      	push 	dx
   810 0000051E 51                      	push 	cx
   811 0000051F 50                      	push 	ax
   812 00000520 FC                      	cld
   813                                  
   814                                  ; write MISC register
   815 00000521 BAC203                  	mov 	dx, VGA_MISC_WRITE
   816 00000524 AC                      	lodsb
   817 00000525 EE                      	out 	dx, al
   818                                  
   819                                  ; write SEQuencer registers
   820 00000526 B90500                  	mov 	cx, NUM_SEQ_REGS
   821 00000529 30E4                    	xor 	ah, ah
   822                                  
   823                                  write_seq:
   824 0000052B BAC403                  	mov 	dx, VGA_SEQ_INDEX
   825 0000052E 88E0                    	mov 	al, ah
   826 00000530 EE                      	out 	dx, al
   827                                  
   828 00000531 BAC503                  	mov 	dx, VGA_SEQ_DATA
   829 00000534 AC                      	lodsb
   830 00000535 EE                      	out 	dx, al
   831                                  
   832 00000536 FEC4                    	inc 	ah
   833 00000538 E2F1                    	loop 	write_seq
   834                                  
   835                                  ; write CRTC registers
   836                                  ; Unlock CRTC registers: enable writes to CRTC regs 0-7
   837 0000053A BAD403                  	mov 	dx, VGA_CRTC_INDEX
   838 0000053D B011                    	mov 	al, 17
   839 0000053F EE                      	out 	dx, al
   840                                  
   841 00000540 BAD503                  	mov 	dx, VGA_CRTC_DATA
   842 00000543 EC                      	in		al, dx
   843 00000544 247F                    	and 	al, $7F
   844 00000546 EE                      	out 	dx, al
   845                                  
   846                                  ; Unlock CRTC registers: enable access to vertical retrace regs
   847 00000547 BAD403                  	mov 	dx, VGA_CRTC_INDEX
   848 0000054A B003                    	mov 	al, 3
   849 0000054C EE                      	out 	dx, al
   850                                  
   851 0000054D BAD503                  	mov 	dx ,VGA_CRTC_DATA
   852 00000550 EC                      	in		al, dx
   853 00000551 0C80                    	or		al, $80
   854 00000553 EE                      	out		dx, al
   855                                  
   856                                  ; make sure CRTC registers remain unlocked
   857 00000554 8A4411                  	mov		al,[si + 17]
   858 00000557 247F                    	and 	al, $7F
   859 00000559 884411                  	mov 	[si + 17],al
   860                                  
   861 0000055C 8A4403                  	mov 	al,[si + 3]
   862 0000055F 0C80                    	or		al, $80
   863 00000561 884403                  	mov 	[si + 3], al
   864                                  
   865                                  ; now, finally, write them
   866 00000564 B91900                  	mov 	cx, NUM_CRTC_REGS
   867 00000567 B400                    	mov 	ah, 0
   868                                  
   869                                  write_crtc:
   870 00000569 BAD403                  	mov 	dx, VGA_CRTC_INDEX
   871 0000056C 88E0                    	mov 	al, ah
   872 0000056E EE                      	out 	dx, al
   873                                  
   874 0000056F BAD503                  	mov 	dx, VGA_CRTC_DATA
   875 00000572 AC                      	lodsb
   876 00000573 EE                      	out 	dx, al
   877                                  
   878 00000574 FEC4                    	inc 	ah
   879 00000576 E2F1                    	loop write_crtc
   880                                  
   881 00000578 58                      	pop 	ax
   882 00000579 59                      	pop 	cx
   883 0000057A 5A                      	pop 	dx
   884 0000057B 5E                      	pop 	si
   885 0000057C C3                      	ret
   886                                  
   887                                  ;	align	32
   888                                  ;fat_loader_entry:
   889                                  ;	incbin		"./loader_c.bin"
   890                                  
   891                                  ;========================================================================================
   892                                  ; DATA SECTION
   893                                  ;========================================================================================
   894                                  regs_90x60:
   895                                  ; MISC
   896 0000057D E7                      	db	0E7h
   897                                  ; SEQuencer
   898 0000057E 0301030002              	db	03h, 01h, 03h, 00h, 02h
   899                                  ; CRTC
   900 00000583 6B595A82608D0B3E        	db	6Bh, 59h,  5Ah, 82h, 60h,  8Dh, 0Bh,  3Eh,
   901 0000058B 0047060700000000        	db	00h, 47h,  06h, 07h, 00h,  00h, 00h,  00h,
   902 00000593 EA0CDF2D08E805A3        	db	0EAh, 0Ch, 0DFh, 2Dh, 08h, 0E8h, 05h, 0A3h,
   903 0000059B FF                      	db 	0FFh
   904                                  ; GC (no)
   905                                  ; AC (no)
   906                                  
   907                                  str_stage2loaded:
   908 0000059C 537461676520322042-     	db 	'Stage 2 Bootloader (boot2)', 0
   909 000005A5 6F6F746C6F61646572-
   910 000005AE 2028626F6F74322900 
   911                                  
   912                                  str_errorDetectMem:
   913 000005B7 4572726F7220646574-     	db 	"Error detecting available memory, cannot continue", 0
   914 000005C0 656374696E67206176-
   915 000005C9 61696C61626C65206D-
   916 000005D2 656D6F72792C206361-
   917 000005DB 6E6E6F7420636F6E74-
   918 000005E4 696E756500         
   919                                  
   920                                  str_floppyError:
   921 000005E9 466C6F707079204572-     	db 	"Floppy Error, press any key to retry", $0A, 0
   922 000005F2 726F722C2070726573-
   923 000005FB 7320616E79206B6579-
   924 00000604 20746F207265747279-
   925 0000060D 0A00               
   926                                  
   927                                  str_available_lomem:
   928 0000060F 436F6E74696E756F75-     	db 	"Continuous 01K blocks below 0x01000000: 0x", 0
   929 00000618 732030314B20626C6F-
   930 00000621 636B732062656C6F77-
   931 0000062A 203078303130303030-
   932 00000633 30303A20307800     
   933                                  
   934                                  str_available_himem:
   935 0000063A 436F6E74696E756F75-     	db 	"Continuous 64K blocks above 0x01000000: 0x", 0
   936 00000643 732036344B20626C6F-
   937 0000064C 636B732061626F7665-
   938 00000655 203078303130303030-
   939 0000065E 30303A20307800     
   940                                  
   941                                  str_select_partition:
   942 00000665 557365207468652063-     	db 	"Use the cursor to select the partition to boot from.", 0
   943 0000066E 7572736F7220746F20-
   944 00000677 73656C656374207468-
   945 00000680 652070617274697469-
   946 00000689 6F6E20746F20626F6F-
   947 00000692 742066726F6D2E00   
   948                                  
   949                                  str_err_not_bootable:
   950 0000069A 546869732070617274-     	db 	"This partition is not marked as bootable!", 0
   951 000006A3 6974696F6E20697320-
   952 000006AC 6E6F74206D61726B65-
   953 000006B5 6420617320626F6F74-
   954 000006BE 61626C652100       
   955                                  
   956                                  str_err_kern_not_found:
   957 000006C4 436F756C64206E6F74-     	db	"Could not find KERNEL.BIN at the root of the drive!", 0
   958 000006CD 2066696E64204B4552-
   959 000006D6 4E454C2E42494E2061-
   960 000006DF 742074686520726F6F-
   961 000006E8 74206F662074686520-
   962 000006F1 64726976652100     
   963                                  
   964                                  str_err_clear_err:
   965 000006F8 20<rept>                	times	0x40 db 0x20
   966 00000738 00                      	db	0
   967                                  
   968                                  
   969                                  str_kernel_loading:
   970 00000739 4C6F6164696E67206B-     	db 	"Loading kernel: ", 0
   971 00000742 65726E656C3A2000   
   972                                  
   973                                  str_kernel_loaded_ok:
   974 0000074A 4B65726E656C206C6F-     	db 	"Kernel loaded. Transferring control now...", 0
   975 00000753 616465642E20547261-
   976 0000075C 6E7366657272696E67-
   977 00000765 20636F6E74726F6C20-
   978 0000076E 6E6F772E2E2E00     
   979                                  
   980                                  str_err_loadkernel:
   981 00000775 436F756C64206E6F74-     	db 	"Could not load kernel: Fuck you", 0
   982 0000077E 206C6F6164206B6572-
   983 00000787 6E656C3A204675636B-
   984 00000790 20796F7500         
   985                                  
   986                                  BootDevice:
   987 00000795 00                      	db	0
   988                                  
   989                                  LastCursorPosition:
   990 00000796 0000                    	dw	0
   991                                  
   992                                  MemBlocksAbove16M:
   993 00000798 0000                    	dw	0
   994                                  
   995                                  MemBlocksBelow16M:
   996 0000079A 0000                    	dw	0
   997                                  
   998                                  MemMap_NumEntries:
   999 0000079C 0000                    	dw	0
  1000                                  
  1001                                  HDD_BootablePartitions:
  1002 0000079E 00000000                	dd	0
  1003                                  
  1004                                  HDD_BootablePartitionsFATType:
  1005 000007A2 00000000                	dd	0
  1006                                  
  1007                                  HDD_Selected:
  1008 000007A6 00                      	db	0
  1009                                  
  1010                                  HDD_PartitionNames:
  1011 000007A7 00<rept>                	times	(0xB+1)*4 db 0
  1012                                  
  1013                                  Temp_StrBuf:
  1014 000007D7 00<rept>                	times	0x20 db 0
  1015                                  
  1016 000007F7 90                      	align 2
  1017                                  ExtendedRead_Table:
  1018 000007F8 10                      	db	$10
  1019 000007F9 00                      	db	0
  1020 000007FA 0000                    	dw	0														; Num blocks
  1021 000007FC 0000                    	dw	0														; Dest
  1022 000007FE 0000                    	dw	0														; Memory page
  1023 00000800 00000000                	dd	0														; Starting LBA
  1024 00000804 00000000                	dd	0	
  1025                                  
  1026                                  kernel_cluster:
  1027 00000808 00000000                	dd	0
  1028                                  
  1029                                  kernel_filename:
  1030 0000080C 4B45524E454C202042-     	db	"KERNEL  BIN", 0
  1031 00000815 494E00             
  1032                                  
  1033                                  ;========================================================================================
  1034                                  ; Global Descriptor Table
  1035                                  ;========================================================================================
  1036 00000818 90<rept>                	align	$10
  1037                                  
  1038                                  gdt_start:
  1039 00000820 0000000000000000        	dd	$00, $00												; Null Descriptor
  1040                                  
  1041                                  	; Code segment
  1042 00000828 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
  1043 0000082A 0000                    	dw	$0000													; Base 0:15 = $0000
  1044 0000082C 00                      	db	$00														; Base 16:23 = $00
  1045 0000082D 9A                      	db	$9A														; Access byte: Present, ring 0, Exec, grow up, R/W
  1046 0000082E CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
  1047 0000082F 00                      	db	$00														; Base 24:31 = $00
  1048                                  
  1049                                  	; Data segment
  1050 00000830 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
  1051 00000832 0000                    	dw	$0000													; Base 0:15 = $0000
  1052 00000834 00                      	db	$00														; Base 16:23 = $00
  1053 00000835 92                      	db	$92														; Access byte: Present, ring 0, Not exec, grow up, R/W
  1054 00000836 CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
  1055 00000837 00                      	db	$00														; Base 24:31 = $00	
  1056                                  
  1057                                  gdt_table:
  1058 00000838 1700                    	dw	(gdt_table-gdt_start)-1									; Length
  1059 0000083A [20080000]              	dd	gdt_start												; Physical address to GDT	
  1060                                  
  1061 0000083E 90<rept>                	align 4														; DWORD align
  1062                                  	%include	"./fat.asm"
  1063                              <1> ;========================================================================================
  1064                              <1> ; FAT Filesystem Library v 0.1
  1065                              <1> ; By Tristan Seifert
  1066                              <1> ;
  1067                              <1> ; All sector values returned by functions are "logical," i.e. they are relative to the
  1068                              <1> ; first sector of the filesystem.
  1069                              <1> ;
  1070                              <1> ; In addition, this library does not offer full support for FAT12 due to the uncommonality
  1071                              <1> ; of it on media besides floppy disks.
  1072                              <1> ;========================================================================================
  1073                              <1> ; Equates
  1074                              <1> ;========================================================================================
  1075                              <1> 
  1076                              <1> ;========================================================================================
  1077                              <1> ; Initialises the FAT filesystem library
  1078                              <1> ;========================================================================================
  1079                              <1> FAT_Init:
  1080 00000840 B90001              <1> 	mov		cx, (1024/4)										; Clear 2 sectors worth
  1081 00000843 66BA[D00B0000]      <1> 	mov		edx, FAT_ReadBuffer									; Pointer to buffer
  1082 00000849 6631C0              <1> 	xor		eax, eax											; Clear value ($00000000)
  1083                              <1> 
  1084                              <1> .clearLoop:
  1085 0000084C 66678902            <1> 	mov		DWORD [edx], eax									; Clear a DWORD
  1086 00000850 6681C204000000      <1> 	add		edx, $04											; Increment pointer
  1087 00000857 E2F3                <1> 	loop	.clearLoop											; Loop
  1088                              <1> 
  1089                              <1> .done:
  1090 00000859 C3                  <1> 	ret
  1091                              <1>  
  1092                              <1> ;========================================================================================
  1093                              <1> ; Determines the type of FAT, give that the first logical sector of the partition is
  1094                              <1> ; pointed to by SI, and returns the FAT bit size in AL.
  1095                              <1> ;
  1096                              <1> ; This is how Microsoft recommends we determine FAT type:
  1097                              <1> ;
  1098                              <1> ; RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytesPerSec - 1)) / BPB_BytesPerSec
  1099                              <1> ; DataSectors = Total Sectors - (BPB_ReservedSectors + (BPB_NumFATs * FATSz) + RootDirSectors)
  1100                              <1> ; Count of clusters = DataSectors/BPB_SectorsPerCluster 
  1101                              <1> ;
  1102                              <1> ; FAT12: Total clusters < 4085
  1103                              <1> ; FAT16: Total clusters > 4085 && < 65525
  1104                              <1> ; FAT32: Total clusters > 65525
  1105                              <1> ;========================================================================================
  1106                              <1> FAT_DetermineType:
  1107 0000085A 60                  <1> 	pusha														; Push registers
  1108                              <1> 
  1109 0000085B E8EF00              <1> 	call	FAT_ReadBPB											; 
  1110                              <1> 
  1111                              <1> 	; Calculate RootDirSectors
  1112 0000085E 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1113 00000861 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1114 00000864 8B1E[8E0B]          <1> 	mov		bx,	WORD [FAT_BPB_RootEntCnt]						; Read root entries 
  1115 00000868 66C1E305            <1> 	shl		ebx, 5												; Each root entry is 32 bytes
  1116                              <1> 
  1117 0000086C A1[7C0B]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1118 0000086F 48                  <1> 	dec		ax													; Subtract one
  1119 00000870 6601D8              <1> 	add		eax, ebx											; Add root entry length to sector length
  1120                              <1> 
  1121 00000873 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1122 00000876 8B0E[7C0B]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1123 0000087A F7F1                <1> 	div		cx													; Divide by sector length (result = ax)
  1124 0000087C A3[980B]            <1> 	mov		WORD [FAT_RootDirSectors], ax						; Store result in memory
  1125                              <1> 
  1126                              <1> 	; Calculate number of data sectors
  1127 0000087F 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1128 00000882 A0[8C0B]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1129                              <1> 
  1130 00000885 668B0E[900B]        <1> 	mov		ecx, DWORD [FAT_BPB_FATSz]							; Read FAT size
  1131 0000088A 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in eax
  1132                              <1> 
  1133 0000088D 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1134 00000890 8B0E[8A0B]          <1> 	mov		cx, WORD [FAT_BPB_ReservedSectors]					; Read number of reserved sectors
  1135                              <1> 
  1136 00000894 6601C8              <1> 	add		eax, ecx											; Add count of reserved sectors to FAT size
  1137 00000897 668B0E[980B]        <1> 	mov		ecx, DWORD [FAT_RootDirSectors]						; Read RootDirSectors
  1138 0000089C 6601C8              <1> 	add		eax, ecx											; Add root directory sectors
  1139                              <1> 
  1140 0000089F 6691                <1> 	xchg	eax, ecx											; Subtract all of the above from total sectors
  1141                              <1> 
  1142 000008A1 66A1[940B]          <1> 	mov		eax, DWORD [FAT_BPB_TotSec]							; Read total sector count
  1143 000008A5 6629C8              <1> 	sub		eax, ecx											; Subtract from total sector count
  1144                              <1> 
  1145 000008A8 66A3[9C0B]          <1> 	mov		DWORD [FAT_DataSectors], eax						; Store to memory
  1146                              <1> 
  1147                              <1> 	; Calculate cluster count
  1148 000008AC 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1149 000008AF 8A1E[880B]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1150 000008B3 66A1[9C0B]          <1> 	mov		eax, DWORD [FAT_DataSectors]						; Read number of data sectors
  1151 000008B7 66F7F3              <1> 	div		ebx													; Divide by sectors/cluster value 
  1152                              <1> 
  1153 000008BA 66A3[A80B]          <1> 	mov		DWORD [FAT_TotalClusters], eax						; Store result in EAX
  1154                              <1> 
  1155                              <1> 	; Now, do some comparisons!
  1156 000008BE 663DF50F0000        <1> 	cmp		eax, 4085											; Is the FS FAT12?
  1157 000008C4 7F07                <1> 	jg		.notFAT12											; If not, branch
  1158                              <1> 
  1159 000008C6 C606[B00B]0C        <1> 	mov		BYTE [FAT_Type], 12									; FAT12
  1160 000008CB EB17                <1> 	jmp		SHORT .done											; Return
  1161                              <1> 
  1162                              <1> .notFAT12:
  1163 000008CD 663DF5FF0000        <1> 	cmp		eax, 65525											; Is the FS FAT16?
  1164 000008D3 7F0A                <1> 	jg		.notFAT16											; If not, branch
  1165                              <1> 
  1166 000008D5 E84C00              <1> 	call	FAT16_Calculate_RootDirSec							; Calculate location of root directory
  1167                              <1> 
  1168 000008D8 C606[B00B]10        <1> 	mov		BYTE [FAT_Type], 16									; FAT16
  1169 000008DD EB05                <1> 	jmp		SHORT .done											; Return
  1170                              <1> 
  1171                              <1> .notFAT16:
  1172                              <1> 	; Okay, if we get down here, it HAS to be FAT32 or a corrupt FS
  1173 000008DF C606[B00B]20        <1> 	mov		BYTE [FAT_Type], 32									; FAT32
  1174                              <1> 
  1175                              <1> .done:
  1176 000008E4 E80500              <1> 	call	FAT_Calculate_Misc									; Calculate miscellaneous stuff
  1177 000008E7 61                  <1> 	popa														; Restore registers
  1178                              <1> 
  1179 000008E8 A0[B00B]            <1> 	mov		al, BYTE [FAT_Type]									; Store FAT type in AL
  1180                              <1> 
  1181 000008EB C3                  <1> 	ret
  1182                              <1> 
  1183                              <1> ;========================================================================================
  1184                              <1> ; Calculates miscellaneous values that the FAT driver uses later
  1185                              <1> ;========================================================================================
  1186                              <1> FAT_Calculate_Misc:
  1187 000008EC 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1188 000008EF 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1189 000008F2 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1190                              <1> 
  1191 000008F5 8B0E[980B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1192 000008F9 8B1E[8A0B]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1193                              <1> 
  1194 000008FD 6601CB              <1> 	add		ebx, ecx											; Add to root dir sectors reserved sectors
  1195                              <1> 
  1196 00000900 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1197 00000903 8A0E[8C0B]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1198 00000907 66A1[900B]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1199 0000090B 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1200                              <1> 
  1201 0000090E 6601D8              <1> 	add		eax, ebx											; Add FAT sectors to root dir and reserved count
  1202                              <1> 
  1203 00000911 66A3[A00B]          <1> 	mov		DWORD [FAT_FirstDataSector], eax					; Store first data sector
  1204                              <1> 
  1205 00000915 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1206 00000918 8B0E[980B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1207 0000091C 6629C8              <1> 	sub		eax, ecx											; Subtract ecx
  1208 0000091F 66A3[A40B]          <1> 	mov		DWORD [FAT_FirstClusterLocation], eax				; Write shaften
  1209 00000923 C3                  <1> 	ret
  1210                              <1> 
  1211                              <1> ;========================================================================================
  1212                              <1> ; Calculates the sector for the root directory for FAT12 and FAT16.
  1213                              <1> ;========================================================================================
  1214                              <1> FAT16_Calculate_RootDirSec:
  1215 00000924 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1216 00000927 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1217 0000092A 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1218                              <1> 
  1219 0000092D 8B1E[8A0B]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1220                              <1> 
  1221 00000931 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1222 00000934 A0[8C0B]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1223                              <1> 
  1224 00000937 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1225 0000093A 8A0E[8C0B]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1226 0000093E 66A1[900B]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1227 00000942 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1228                              <1> 
  1229 00000945 6601D8              <1> 	add		eax, ebx											; Add reserved sector count
  1230                              <1> 
  1231 00000948 66A3[840B]          <1> 	mov		DWORD [FAT_BPB_RootClus], eax						; Write location of root cluster
  1232                              <1> 
  1233                              <1> .done:
  1234 0000094C C3                  <1> 	ret
  1235                              <1> 
  1236                              <1> ;========================================================================================
  1237                              <1> ; Reads the BPB from the FAT 1st sector in SI.
  1238                              <1> ;========================================================================================
  1239                              <1> FAT_ReadBPB:
  1240 0000094D 8B440B              <1> 	mov		ax, WORD [si+11]									; Read Bytes/sector
  1241 00000950 A3[7C0B]            <1> 	mov		WORD [FAT_BPB_BytesPerSec], ax						; ""
  1242                              <1> 
  1243 00000953 8A440D              <1> 	mov		al, BYTE [si+13]									; Read sectors/cluster
  1244 00000956 A2[880B]            <1> 	mov		BYTE [FAT_BPB_SectorsPerCluster], al				; ""
  1245                              <1> 
  1246 00000959 8B440E              <1> 	mov		ax, WORD [si+14]									; Read reserved sectors
  1247 0000095C A3[8A0B]            <1> 	mov		WORD [FAT_BPB_ReservedSectors], ax					; ""
  1248                              <1> 
  1249 0000095F 8A4410              <1> 	mov		al, BYTE [si+16]									; Read number of FATs
  1250 00000962 A2[8C0B]            <1> 	mov		BYTE [FAT_BPB_NumFATs], al							; ""
  1251                              <1> 
  1252 00000965 8B4411              <1> 	mov		ax, WORD [si+17]									; Read num root entries
  1253 00000968 A3[8E0B]            <1> 	mov		WORD [FAT_BPB_RootEntCnt], ax						; ""
  1254                              <1> 
  1255 0000096B 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1256                              <1> 
  1257 0000096E 668B4420            <1> 	mov		eax, DWORD [si+32]									; Read BPB_TotSec32 first
  1258 00000972 663D00000000        <1> 	cmp		eax, 0												; Is EAX zero?
  1259 00000978 7503                <1> 	jne		.writeTotSec										; If not, branch
  1260                              <1> 
  1261 0000097A 8B4413              <1> 	mov		ax, WORD [si+19]									; Read BPB_TotSec16 first
  1262                              <1> 
  1263                              <1> .writeTotSec:
  1264 0000097D 66A3[940B]          <1> 	mov		DWORD [FAT_BPB_TotSec], eax							; ""
  1265                              <1> 
  1266 00000981 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1267                              <1> 
  1268 00000984 8B4416              <1> 	mov		ax, WORD [si+22]									; Read BPB_FATSz16
  1269 00000987 3D0000              <1> 	cmp		ax, 0												; Is it zero?
  1270 0000098A 7507                <1> 	jne		.writeFATSz											; If not, branch.
  1271                              <1> 
  1272 0000098C 668B4424            <1> 	mov		eax, DWORD [si+36]									; Read BPB_FATSz32
  1273                              <1> 
  1274 00000990 E80500              <1> 	call	.readFAT32Specifics									; Read FAT32-specific data
  1275                              <1> 
  1276                              <1> .writeFATSz:
  1277 00000993 66A3[900B]          <1> 	mov		DWORD [FAT_BPB_FATSz], eax							; Write FAT size
  1278                              <1> 
  1279 00000997 C3                  <1> 	ret
  1280                              <1> 
  1281                              <1> ; All FAT32-specific stuff is read here
  1282                              <1> .readFAT32Specifics:
  1283 00000998 8B5C28              <1> 	mov		bx, WORD [si+40]									; Read BPB_ExtFlags
  1284 0000099B 891E[800B]          <1> 	mov		WORD [FAT_BPB_ExtFlags], bx							; Write BPB_ExtFlags
  1285                              <1> 
  1286 0000099F 8B5C2A              <1> 	mov		bx, WORD [si+42]									; Read BPB_FSVer
  1287 000009A2 891E[820B]          <1> 	mov		WORD [FAT_BPB_FSVer], bx							; Write BPB_FSVer
  1288                              <1> 
  1289 000009A6 668B5C2C            <1> 	mov		ebx, DWORD [si+44]									; Read BPB_RootClus
  1290 000009AA 66891E[840B]        <1> 	mov		DWORD [FAT_BPB_RootClus], ebx						; Write BPB_RootClus
  1291                              <1> 
  1292 000009AF 8B5C30              <1> 	mov		bx, WORD [si+48]									; Read BPB_FSInfo
  1293 000009B2 891E[7E0B]          <1> 	mov		WORD [FAT_BPB_FSInfo], bx							; Write BPB_FSInfo
  1294                              <1> 
  1295                              <1> 
  1296 000009B6 C3                  <1> 	ret
  1297                              <1> 
  1298                              <1> ;========================================================================================
  1299                              <1> ; Calculates the entry location for cluster N in the FAT.
  1300                              <1> ; eax: Cluster number
  1301                              <1> ; eax: Sector number containing the cluster
  1302                              <1> ; ebx: Offset in sector
  1303                              <1> ;========================================================================================
  1304                              <1> FAT_FindClusterInTable:
  1305 000009B7 60                  <1> 	pusha														; Back up regs
  1306                              <1> 
  1307 000009B8 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1308 000009BB 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1309                              <1> 
  1310 000009BE 8A1E[B00B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1311 000009C2 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1312 000009C5 7406                <1> 	je		.FAT32												; If so, jump
  1313                              <1> 
  1314 000009C7 66D1E0              <1> 	shl		eax, 1												; Multiply cluster by 2
  1315 000009CA E90400              <1> 	jmp		.cont												; Skip over shift below
  1316                              <1> 
  1317                              <1> .FAT32:
  1318 000009CD 66C1E002            <1> 	shl		eax, 2												; Multiply cluster by 4
  1319                              <1> 
  1320                              <1> .cont:
  1321                              <1> 	; eax = Offset into FAT table
  1322                              <1> 
  1323 000009D1 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1324 000009D4 8B0E[7C0B]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1325 000009D8 66F7F1              <1> 	div		ecx													; Divide offset by bytes/sector
  1326                              <1> 	; eax = quotient, edx = remainder
  1327                              <1> 
  1328 000009DB 8B1E[8A0B]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; BX = reserved sector count
  1329 000009DF 6601D8              <1> 	add		eax, ebx											; Add to FAT offset (sectors)
  1330                              <1> 
  1331 000009E2 66A3[F709]          <1> 	mov		DWORD [.secNum], eax								; Store sector number
  1332 000009E6 8916[FB09]          <1> 	mov		WORD [.secOff], dx									; Store offset into sector
  1333                              <1> 
  1334                              <1> .done:
  1335 000009EA 61                  <1> 	popa														; Restore regs
  1336                              <1> 
  1337 000009EB 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1338 000009EE 66A1[F709]          <1> 	mov		eax, DWORD [.secNum]								; Get sector number
  1339 000009F2 8B1E[FB09]          <1> 	mov		bx, WORD [.secOff]									; Get offset into sector
  1340                              <1> 
  1341 000009F6 C3                  <1> 	ret
  1342                              <1> 
  1343                              <1> .secNum:
  1344 000009F7 00000000            <1> 	dd		0
  1345                              <1> 
  1346                              <1> .secOff:
  1347 000009FB 0000                <1> 	dw		0
  1348                              <1> 
  1349                              <1> ;========================================================================================
  1350                              <1> ; Converts the cluster number in eax into a sector number.
  1351                              <1> ;========================================================================================
  1352                              <1> FAT_ClusterToSector:
  1353 000009FD 6651                <1> 	push	ecx													; Back up EBX
  1354                              <1> 
  1355 000009FF 6648                <1> 	dec		eax													; Subtract 2 from cluster
  1356 00000A01 6648                <1> 	dec		eax													; ""
  1357                              <1> 
  1358 00000A03 6631C9              <1> 	xor		ecx, ecx											; Clear EBX
  1359 00000A06 8A0E[880B]          <1> 	mov		cl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1360 00000A0A 66F7E1              <1> 	mul		ecx													; Multiply by number of sectors per cluster
  1361                              <1> 
  1362 00000A0D 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1363 00000A10 8B0E[980B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Root directory sector
  1364 00000A14 6601C8              <1> 	add		eax, ecx											; Add to sector count
  1365                              <1> 
  1366 00000A17 668B0E[A00B]        <1> 	mov		ecx, DWORD [FAT_FirstDataSector]					; Get first data sector
  1367 00000A1C 6601C8              <1> 	add		eax, ecx											; Add data sector offset
  1368                              <1> 
  1369 00000A1F 6659                <1> 	pop		ecx													; Restore EBX
  1370                              <1> 
  1371 00000A21 C3                  <1> 	ret
  1372                              <1> 
  1373                              <1> ;========================================================================================
  1374                              <1> ; Reads the sector containing the FAT entry for the specified cluster, then returns the
  1375                              <1> ; FAT read from the sector.
  1376                              <1> ; eax: Cluster
  1377                              <1> ; Sets carry flag if error.
  1378                              <1> ;========================================================================================
  1379                              <1> FAT_ReadFAT:
  1380 00000A22 E892FF              <1> 	call	FAT_FindClusterInTable								; Locate cluster
  1381 00000A25 6653                <1> 	push	ebx													; Push offset into sector to stack
  1382                              <1> 
  1383                              <1> 	; Read sector to memory
  1384 00000A27 E82500              <1> 	call	FAT_ReadSector										; Read sector
  1385 00000A2A 665B                <1> 	pop		ebx													; Pop offset into sector
  1386 00000A2C 721F                <1> 	jc 		SHORT .error										; If error, return
  1387                              <1> 
  1388                              <1> 	; Sector is now read to memory
  1389 00000A2E 8A1E[B00B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1390 00000A32 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1391 00000A35 740D                <1> 	je		.FAT32												; If so, jump
  1392                              <1> 
  1393 00000A37 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1394 00000A3A 678B83[D00B0000]    <1> 	mov		ax, WORD [FAT_ReadBuffer+ebx]						; Read FAT16 entry
  1395 00000A41 E90800              <1> 	jmp		.done												; Skip over read below
  1396                              <1> 
  1397                              <1> .FAT32:
  1398 00000A44 66678B83[D00B0000]  <1> 	mov		eax, DWORD [FAT_ReadBuffer+ebx]						; Read FAT32 entry
  1399                              <1> 
  1400                              <1> .done:
  1401 00000A4C C3                  <1> 	ret
  1402                              <1> 
  1403                              <1> .error:
  1404 00000A4D F9                  <1> 	stc															; Set carry
  1405 00000A4E C3                  <1> 	ret
  1406                              <1> 
  1407                              <1> ;========================================================================================
  1408                              <1> ; Reads a logical sector from the drive.
  1409                              <1> ; eax: Logical sector
  1410                              <1> ; Clears the carry flag if successful, set otherwise.
  1411                              <1> ;========================================================================================
  1412                              <1> FAT_ReadSector:
  1413 00000A4F 660306[AC0B]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1414                              <1> 
  1415 00000A54 668B1E[B40B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1416 00000A59 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1417 00000A5C 7429                <1> 	je		.done												; If they are the same sector, branch
  1418                              <1> 
  1419 00000A5E 66A3[C00B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1420 00000A62 C706[BA0B]0100      <1> 	mov		WORD [FAT_ERTable+0x02], 0x01						; Read one sector
  1421 00000A68 C706[BC0B][D00B]    <1> 	mov		WORD [FAT_ERTable+0x04], FAT_ReadBuffer				; Temporary sector buffer offset (seg 0)
  1422 00000A6E C706[BE0B]0000      <1> 	mov		WORD [FAT_ERTable+0x06], 0x00						; Page 0
  1423                              <1> 
  1424 00000A74 66A3[B40B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Store LBA we're loading
  1425                              <1> 
  1426 00000A78 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1427 00000A79 BE[B80B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1428 00000A7C B442                <1> 	mov 	ah, $42												; Extended Read
  1429 00000A7E 8A16[B10B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1430 00000A82 CD13                <1> 	int 	$13													; Perform read
  1431 00000A84 61                  <1> 	popa														; Pop registers
  1432 00000A85 7202                <1> 	jc 		SHORT .error										; If error, return
  1433                              <1> 
  1434                              <1> .done:
  1435 00000A87 F8                  <1> 	clc															; Clear carry
  1436 00000A88 C3                  <1> 	ret
  1437                              <1> 
  1438                              <1> .error:
  1439 00000A89 F9                  <1> 	stc															; Set carry
  1440 00000A8A C3                  <1> 	ret
  1441                              <1> 
  1442                              <1> ;========================================================================================
  1443                              <1> ; Tries to locate a file with the name pointed to by in esi in the root directory of the
  1444                              <1> ; FAT. If found, returns the first cluster of the file in eax, filesize in ebx, and
  1445                              <1> ; clears carry. If not found, sets carry.
  1446                              <1> ;
  1447                              <1> ; Note that this only searches the short filename.
  1448                              <1> ;========================================================================================
  1449                              <1> FAT_FindFileAtRoot:
  1450 00000A8B 60                  <1> 	pusha														; Push regs
  1451 00000A8C 66A1[840B]          <1> 	mov		eax, DWORD [FAT_BPB_RootClus]						; Read root sector location
  1452 00000A90 E86AFF              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1453 00000A93 E8B9FF              <1> 	call	FAT_ReadSector										; Read sector
  1454                              <1> 
  1455 00000A96 66BF[D00B0000]      <1> 	mov		edi, FAT_ReadBuffer									; FAT read buffer
  1456 00000A9C B91000              <1> 	mov		cx, (512/32)										; Search the first 512/32 entries
  1457                              <1> 
  1458                              <1> .searchLoop:
  1459 00000A9F 678A07              <1> 	mov		al, BYTE [edi]										; Read first byte of string
  1460                              <1> 
  1461 00000AA2 3CE5                <1> 	cmp		al, $0E5											; Is directory entry free?
  1462 00000AA4 7426                <1> 	je		.fileEntryIgnore									; If so, branch
  1463 00000AA6 3C00                <1> 	cmp		al, $00												; Is directory entry free and last one?
  1464 00000AA8 7428                <1> 	je		.notFound											; If so, exit loop.
  1465                              <1> 
  1466                              <1> 	; Store pointers
  1467 00000AAA 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1468 00000AAD 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1469 00000AB0 6689F8              <1> 	mov		eax, edi											; Copy read pointer to EAX
  1470 00000AB3 6689F2              <1> 	mov		edx, esi											; Copy filename compare ptr to EDX
  1471                              <1> 
  1472                              <1> 	; Compare filename
  1473 00000AB6 51                  <1> 	push	cx													; Push loop counter
  1474 00000AB7 B90B00              <1> 	mov		cx, $0B												; Filename is 11 bytes
  1475                              <1> 
  1476                              <1> .comparison:
  1477 00000ABA 678A18              <1> 	mov		bl, BYTE [eax]										; Read soruce ptr
  1478 00000ABD 673A1A              <1> 	cmp		bl, BYTE [edx]										; Compare against target
  1479 00000AC0 7509                <1> 	jne		.compareFailed										; If not equal, branch
  1480                              <1> 
  1481 00000AC2 6640                <1> 	inc		eax													; Increment read pointer
  1482 00000AC4 6642                <1> 	inc		edx													; Increment target pointer
  1483                              <1> 
  1484 00000AC6 E2F2                <1> 	loop	.comparison											; Compare 11 bytes
  1485                              <1> 
  1486 00000AC8 59                  <1> 	pop		cx													; Pop loop counter from stack
  1487 00000AC9 EB0A                <1> 	jmp		SHORT .found										; File was found
  1488                              <1> 
  1489                              <1> .compareFailed:
  1490 00000ACB 59                  <1> 	pop		cx													; Pop loop counter
  1491                              <1> 
  1492                              <1> .fileEntryIgnore:
  1493 00000ACC 81C72000            <1> 	add		di, $20												; Read next entry
  1494 00000AD0 E2CD                <1> 	loop	.searchLoop											; Loop through entries
  1495                              <1> 
  1496                              <1> ; Drop down here once loop finishes: file not found.
  1497                              <1> .notFound:
  1498 00000AD2 61                  <1> 	popa														; Pop registers
  1499 00000AD3 F9                  <1> 	stc															; Set carry
  1500 00000AD4 C3                  <1> 	ret
  1501                              <1> 
  1502                              <1> ; We found the file
  1503                              <1> .found:
  1504 00000AD5 678B471A            <1> 	mov		ax, WORD [edi+26]									; Read cluster low word
  1505 00000AD9 A3[F80A]            <1> 	mov		WORD [.clusterOfFile], ax							; ""
  1506 00000ADC 678B4714            <1> 	mov		ax, WORD [edi+20]									; Read cluster high word
  1507 00000AE0 A3[FA0A]            <1> 	mov		WORD [.clusterOfFile+2], ax							; ""
  1508                              <1> 
  1509 00000AE3 66678B471C          <1> 	mov		eax, DWORD [edi+28]									; Read filesize
  1510 00000AE8 66A3[FC0A]          <1> 	mov		DWORD [.sizeOfFile], eax							; ""
  1511                              <1> 
  1512 00000AEC 61                  <1> 	popa														; Pop registers
  1513 00000AED 66A1[F80A]          <1> 	mov		eax, DWORD [.clusterOfFile]							; Read file's cluster
  1514 00000AF1 668B1E[FC0A]        <1> 	mov		ebx, DWORD [.sizeOfFile]							; Read file's size
  1515 00000AF6 F8                  <1> 	clc															; Clear carry bit
  1516 00000AF7 C3                  <1> 	ret
  1517                              <1> 
  1518                              <1> 	align	4
  1519                              <1> .clusterOfFile:
  1520 00000AF8 00000000            <1> 	dd		0
  1521                              <1> .sizeOfFile:
  1522 00000AFC 00000000            <1> 	dd		0
  1523                              <1> 
  1524                              <1> ;========================================================================================
  1525                              <1> ; Reads the file whose first cluster is in eax to es:di.
  1526                              <1> ;
  1527                              <1> ; Note that this function returns after reading a maximum of 256 chunks.
  1528                              <1> ;========================================================================================
  1529                              <1> FAT_ReadFile:
  1530 00000B00 60                  <1> 	pusha														; Push all regisers
  1531                              <1> 
  1532 00000B01 E80800              <1> 	call	FAT_ReadCluster										; Read cluster
  1533 00000B04 7203                <1> 	jc 		SHORT .error										; If error, return
  1534                              <1> 
  1535                              <1> ;	xor		cx, cx												; Clear CX
  1536                              <1> ;	mov		gs, cx												; Clear GS
  1537                              <1> ;
  1538                              <1> ;.readLoop:
  1539                              <1> ;	call	FAT_ReadFAT											; Read FAT entry for current cluster
  1540                              <1> ;	and		eax, $0FFFFFFF										; Ignore high nybble
  1541                              <1> ;	cmp		eax, $0FFFFFF8										; End of chain marker?
  1542                              <1> ;	jae		.done												; If so, branch (unsigned compare)
  1543                              <1> ;
  1544                              <1> ;	call	FAT_ReadCluster										; Read cluster
  1545                              <1> ;	jc 		SHORT .error										; If error, return
  1546                              <1> ;
  1547                              <1> ;	mov		cx, gs												; Read GS
  1548                              <1> ;	inc		cx													; Increment GS
  1549                              <1> ;	mov		gs, cx												; Move back to GS
  1550                              <1> ;
  1551                              <1> ;	cmp		cl, $0FF											; Is it max? ($FF)
  1552                              <1> ;	je		.error												; If so, we're done
  1553                              <1> ;
  1554                              <1> ;	jmp		.readLoop											; Loop until all sectors of the file are read
  1555                              <1> 
  1556                              <1> .done:
  1557 00000B06 61                  <1> 	popa														; Pop registers
  1558 00000B07 F8                  <1> 	clc															; Clear carry
  1559 00000B08 C3                  <1> 	ret
  1560                              <1> 
  1561                              <1> .error:
  1562 00000B09 61                  <1> 	popa														; Pop registers
  1563 00000B0A F9                  <1> 	stc															; Set carry
  1564 00000B0B C3                  <1> 	ret
  1565                              <1> 
  1566                              <1> ;========================================================================================
  1567                              <1> ; Reads a logical sector from the drive.
  1568                              <1> ; eax: Logical cluster
  1569                              <1> ; es:di: Memory location (Incremented after read)
  1570                              <1> ; Clears the carry flag if successful, set otherwise.
  1571                              <1> ;========================================================================================
  1572                              <1> FAT_ReadCluster:
  1573 00000B0C 66A3[780B]          <1> 	mov		DWORD [.origCluster], eax							; Store original cluster
  1574 00000B10 E8EAFE              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1575                              <1> 
  1576 00000B13 660306[AC0B]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1577                              <1> 
  1578 00000B18 668B1E[B40B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1579 00000B1D 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1580 00000B20 742E                <1> 	je		.done												; If they are the same sector, branch
  1581 00000B22 66A3[B40B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Save sector we're reading
  1582                              <1> 
  1583 00000B26 31DB                <1> 	xor		bx, bx												; Clear BX
  1584 00000B28 8A1E[880B]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1585 00000B2C C706[BA0B]FF01      <1> 	mov		WORD [FAT_ERTable+0x02], $1FF							; Write sectors/cluster 
  1586 00000B32 66A3[C00B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1587 00000B36 893E[BC0B]          <1> 	mov		WORD [FAT_ERTable+0x04], di							; Offset in segment
  1588 00000B3A 8C06[BE0B]          <1> 	mov		WORD [FAT_ERTable+0x06], es							; Segment
  1589                              <1> 
  1590 00000B3E 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1591 00000B3F BE[B80B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1592 00000B42 B442                <1> 	mov 	ah, $42												; Extended Read		
  1593 00000B44 8A16[B10B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1594 00000B48 CD13                <1> 	int 	$13													; Perform read
  1595 00000B4A 61                  <1> 	popa														; Pop registers
  1596 00000B4B 7209                <1> 	jc 		SHORT .error										; If error, return
  1597                              <1> 
  1598 00000B4D E80C00              <1> 	call	.incrementReadPtr									; Increment read pointer
  1599                              <1> 
  1600                              <1> .done:	
  1601 00000B50 66A1[780B]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1602 00000B54 F8                  <1> 	clc															; Clear carry
  1603 00000B55 C3                  <1> 	ret
  1604                              <1> 
  1605                              <1> .error:
  1606 00000B56 66A1[780B]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1607 00000B5A F9                  <1> 	stc															; Set carry
  1608 00000B5B C3                  <1> 	ret
  1609                              <1> 
  1610                              <1> .incrementReadPtr:
  1611 00000B5C 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1612 00000B5F A1[7C0B]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1613 00000B62 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1614 00000B65 8A1E[880B]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read bytes per sector
  1615                              <1> 
  1616 00000B69 66F7E3              <1> 	mul		ebx													; EAX = value to add to write ptr
  1617 00000B6C 01C7                <1> 	add		di, ax												; Add cluster length to di
  1618 00000B6E 7107                <1> 	jno		.noOverflow											; If overflow bit isn't set, branch
  1619                              <1> 
  1620 00000B70 8CC0                <1> 	mov		ax, es												; Read segment we're writing to
  1621 00000B72 050010              <1> 	add		ax, $1000											; Write in next segment
  1622 00000B75 8EC0                <1> 	mov		es, ax												; Write to segment register
  1623                              <1> 
  1624                              <1> .noOverflow:
  1625 00000B77 C3                  <1> 	ret
  1626                              <1> 
  1627                              <1> 	align	4
  1628                              <1> .origCluster:
  1629 00000B78 00000000            <1> 	dd		0
  1630                              <1> 
  1631                              <1> ;========================================================================================
  1632                              <1> ; Data section
  1633                              <1> ;========================================================================================
  1634                              <1> 	align	4
  1635                              <1> FAT_BPB_BytesPerSec: ; file offset 11
  1636 00000B7C 0000                <1> 	dw		0
  1637                              <1> FAT_BPB_FSInfo: ; file offset 48, FAT32 only
  1638 00000B7E 0000                <1> 	dw		0
  1639                              <1> FAT_BPB_ExtFlags: ; file offset 40, FAT32 only
  1640 00000B80 0000                <1> 	dw		0
  1641                              <1> FAT_BPB_FSVer: ; file offset 42, FAT32 only
  1642 00000B82 0000                <1> 	dw		0
  1643                              <1> 
  1644                              <1> 	align	4
  1645                              <1> FAT_BPB_RootClus: ; file offset 44, FAT32 only
  1646 00000B84 00000000            <1> 	dd		0
  1647                              <1> FAT_BPB_SectorsPerCluster: ; file offset 13
  1648 00000B88 00                  <1> 	db		0
  1649                              <1> 
  1650 00000B89 90                  <1> 	align	2
  1651                              <1> FAT_BPB_ReservedSectors: ; file offset 14
  1652 00000B8A 0000                <1> 	dw		0
  1653                              <1> FAT_BPB_NumFATs: ; file offset 16
  1654 00000B8C 00                  <1> 	db		0
  1655                              <1> 
  1656 00000B8D 90                  <1> 	align	2
  1657                              <1> FAT_BPB_RootEntCnt:	; file offset 17
  1658 00000B8E 0000                <1> 	dw		0
  1659                              <1> 
  1660                              <1> 	align	4
  1661                              <1> FAT_BPB_FATSz: ; file offset 22 if FAT16, 36 if FAT32 and word at 22 is 0
  1662 00000B90 00000000            <1> 	dd		0
  1663                              <1> 
  1664                              <1> ; Works with FAT32
  1665                              <1> ; For the total sector count, try to read BPB_FATSz16 first (19), then the 32-bit at off 32
  1666                              <1> FAT_BPB_TotSec: ; file offset 32 if 19 = 0
  1667 00000B94 00000000            <1> 	dd		0
  1668                              <1> 
  1669                              <1> ; Calculated when identifying FS
  1670                              <1> FAT_RootDirSectors:
  1671 00000B98 0000                <1> 	dw		0
  1672                              <1> 
  1673 00000B9A 90<rept>            <1> 	align	4
  1674                              <1> FAT_DataSectors:
  1675 00000B9C 00000000            <1> 	dd		0
  1676                              <1> FAT_FirstDataSector:
  1677 00000BA0 00000000            <1> 	dd		0
  1678                              <1> FAT_FirstClusterLocation:
  1679 00000BA4 00000000            <1> 	dd		0
  1680                              <1> FAT_TotalClusters:
  1681 00000BA8 00000000            <1> 	dd		0
  1682                              <1> 
  1683                              <1> ; Offset into drive in sectors to the start of the FAT partition
  1684                              <1> FAT_PartitionOffset:
  1685 00000BAC 00000000            <1> 	dd		0
  1686                              <1> FAT_Type:
  1687 00000BB0 00                  <1> 	db		0
  1688                              <1> 
  1689                              <1> ; BIOS drive to read from
  1690                              <1> FAT_Drive:
  1691 00000BB1 00                  <1> 	db		0
  1692                              <1> 
  1693 00000BB2 90<rept>            <1> 	align	4
  1694                              <1> FAT_LastLoadedSector:
  1695 00000BB4 00000000            <1> 	dd		0
  1696                              <1> 
  1697                              <1> 	align	4
  1698                              <1> FAT_ERTable:
  1699 00000BB8 10                  <1> 	db	$10
  1700 00000BB9 00                  <1> 	db	0
  1701 00000BBA 0000                <1> 	dw	0														; Num blocks
  1702 00000BBC 0000                <1> 	dw	0														; Dest
  1703 00000BBE 0000                <1> 	dw	0														; Memory page
  1704 00000BC0 00000000            <1> 	dd	0														; Starting LBA
  1705 00000BC4 00000000            <1> 	dd	0	
  1706                              <1> 
  1707 00000BC8 90<rept>            <1> 	align	$10
  1708                              <1> FAT_ReadBuffer:
  1709                                  
  1710                                  SectorBuf:
  1711 00000BD0 00<rept>                	times	512 db 0

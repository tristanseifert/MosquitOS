     1                                  	BITS	16
     2                                  	org		$0500
     3                                  
     4                                  ; Kernel will be loaded to segment $0A80, or $00A800 physical
     5                                  kern_loc:				EQU $0A80
     6                                  kern_loc_phys:			EQU kern_loc<<4
     7                                  kern_start:				EQU 6
     8                                  kern_len:				EQU 32									; Length in sectors
     9                                  
    10                                  ; Location to store various BIOS info at
    11                                  Kern_Info_Struct:		EQU $0160								; $001600 phys (len = $400 max)
    12                                  Kern_Info_StructPhys:	EQU (Kern_Info_Struct<<4)
    13                                  VESA_SupportedModes:	EQU	$01A0								; $001A00 phys (len = $200)
    14                                  BIOS_MemMapSeg:			EQU	$0200								; $002000 phys (len = $800 max)
    15                                  
    16                                  ; Physical protected mode addresses
    17                                  MMU_PageDir:			EQU $003000
    18                                  MMU_PageTable1:			EQU $004000
    19                                  MMU_PageTable2:			EQU $005000
    20                                  MMU_PageTable3:			EQU $006000
    21                                  MMU_PageTable4:			EQU $007000
    22                                  MMU_PageTable5:			EQU $008000
    23                                  
    24                                  ;	+$00 uint32_t munchieValue; // Should be "KERN"
    25                                  ;	+$04 uint16_t supportBits;
    26                                  ;	+$06 uint16_t high16Mem; // 64K blocks above 16M
    27                                  ;	+$08 uint16_t low16Mem; // 1k blocks below 16M
    28                                  ;	+$0A uint32_t memMap; // 32-bit ptr to list
    29                                  ;	+$0E uint16_t numMemMapEnt; // Number of entries in above map
    30                                  ;	+$10 uint8_t vesaSupport;
    31                                  ;	+$11 uint8_t bootDrive;
    32                                  ;	+$12 uint32_t vesaMap;
    33                                  
    34                                  stage2_start:
    35 00000000 B80080                  	mov		ax, $8000											; AX = stack segment value (Stack to go at $80000)
    36 00000003 8ED0                    	mov 	ss, ax
    37 00000005 BC0010                  	mov 	sp, 4096											; Set up SP
    38                                  
    39 00000008 8CC8                    	mov 	ax, cs												; Set data segment to where we're loaded
    40 0000000A 8ED8                    	mov 	ds, ax
    41                                  
    42 0000000C 8816[8D07]              	mov		BYTE [BootDevice], dl								; Save boot device number
    43 00000010 8816[A10B]              	mov		BYTE [FAT_Drive], dl								; Set FAT read drive
    44                                  
    45 00000014 66C70600164B45524E      	mov		DWORD [Kern_Info_StructPhys], "KERN"				; Set magic value for kern struct
    46                                  
    47 0000001D A0[8D07]                	mov		al, [BootDevice]									; Set boot drive
    48 00000020 A21116                  	mov		BYTE [Kern_Info_StructPhys+$11], al					; ""
    49                                  
    50                                  	; Set up video
    51 00000023 B400                    	mov		ah, $00												; Change video mode
    52 00000025 B003                    	mov		al, $03												; 80x25 text mode
    53 00000027 CD10                    	int		$10													; Call video BIOS
    54                                  
    55 00000029 BE[9405]                	mov 	si, str_stage2loaded								; Put string position into SI
    56 0000002C 31D2                    	xor		dx, dx												; Cursor position
    57 0000002E BF2F00                  	mov		di, $2F												; Set colour
    58 00000031 E8BA03                  	call 	print_string										; Call string printing routine
    59                                  
    60                                  	; Call VESA BIOS routines to get supported video modes
    61 00000034 B8A001                  	mov		ax, VESA_SupportedModes								; Memory location of supported mode struct
    62 00000037 8EC0                    	mov		es, ax												; ""
    63 00000039 31FF                    	xor		di, di												; Offset 0 in segment
    64                                  
    65 0000003B 2666C70556424532        	mov		[es:di], DWORD "VBE2"								; Tell BIOS we want 512 bytes of data
    66                                  
    67 00000043 B8004F                  	mov		ax, $4F00											; VESA BIOS routines â€” get supported modes
    68 00000046 CD10                    	int		$10													; Perform lookup
    69                                  
    70 00000048 84E4                    	test	ah, ah												; Is AH not zero (i.e. error)
    71 0000004A 7400                    	je		.vesaDone											; If so, VESA is unsupported
    72                                  
    73                                  .vesaDone:
    74                                  	; Call BIOS to get memory information
    75 0000004C 31C9                    	xor 	cx, cx
    76 0000004E 31D2                    	xor 	dx, dx
    77 00000050 B801E8                  	mov 	ax, $0E801
    78 00000053 CD15                    	int 	$15													; Request upper memory size
    79 00000055 7250                    	jc 		error_memoryDetect
    80 00000057 80FC86                  	cmp 	ah, $86												; Unsupported function
    81 0000005A 744B                    	je		error_memoryDetect
    82 0000005C 80FC80                  	cmp		ah, $80												; Invalid command
    83 0000005F 7446                    	je		error_memoryDetect
    84 00000061 E304                    	jcxz 	.useax												; Was the CX result invalid?
    85                                   
    86 00000063 89C8                    	mov		ax, cx												; Number of continuous 1K blocks (1M-16M)
    87 00000065 89D3                    	mov		bx, dx												; Number of continuous 64K block above 16M
    88                                  
    89                                  .useax:
    90 00000067 31FF                    	xor		di, di												; Clear DI
    91 00000069 891E[9007]              	mov		WORD [MemBlocksAbove16M], bx						; Store amount of memory available
    92 0000006D 891E0616                	mov		WORD [Kern_Info_StructPhys+$06], bx					; Highmem
    93 00000071 A3[9207]                	mov		WORD [MemBlocksBelow16M], ax						; ""
    94 00000074 A30816                  	mov		WORD [Kern_Info_StructPhys+$08], ax					; Lowmem
    95                                  
    96 00000077 E84F03                  	call	display_memsize										; Display the memory size
    97                                  
    98                                  	; Fetch memory map
    99 0000007A B80002                  	mov 	ax, BIOS_MemMapSeg									; Write mem map to $01800 in physical space
   100 0000007D 8EC0                    	mov 	es, ax
   101 0000007F 31FF                    	xor		di, di												; Start of segment
   102                                  
   103 00000081 E81304                  	call	fetch_mem_map										; Fetch a memory map
   104 00000084 7221                    	jc 		SHORT error_memoryDetect							; Branch if error
   105                                  
   106 00000086 892E0E16                	mov		WORD [Kern_Info_StructPhys+$0E], bp					; ""
   107 0000008A 66C7060A1600200000      	mov		DWORD [Kern_Info_StructPhys+$0A], (BIOS_MemMapSeg<<4); Physical location of table
   108                                  
   109                                  	; Initialise FAT library
   110 00000093 E89A07                  	call	FAT_Init
   111                                  
   112                                  	; Check which partitions are bootable from MBR partition map
   113 00000096 E87F02                  	call	find_bootable_partitions
   114 00000099 C606[9E07]00            	mov		BYTE [HDD_Selected], 0								; Clear HDD selection
   115                                  
   116                                  	; Set up the partition chooser UI
   117 0000009E E8FA00                  	call	render_partition_chooser
   118                                  
   119                                  	; Process keypresses, and loads kernel from FS if ENTER is pressed
   120 000000A1 E8F001                  	call	chooser_loop
   121 000000A4 E90800                  	jmp		boot
   122                                  
   123                                  ;========================================================================================
   124                                  ; Memory detection error handler
   125                                  ;========================================================================================
   126                                  error_memoryDetect:
   127 000000A7 BE[AF05]                	mov 	si, str_errorDetectMem								; Put string position into SI
   128 000000AA E83B03                  	call 	print_error											; Call string printing routine
   129 000000AD EBFE                    	jmp		$
   130                                  
   131                                  ;========================================================================================
   132                                  ; Code to boot the kernel
   133                                  ;========================================================================================
   134                                  boot:
   135                                  	; Hide cursor
   136 000000AF 31D2                    	xor		dx, dx												; Clear dx
   137 000000B1 F7D2                    	not		dx													; dx = $FFFF
   138 000000B3 B402                    	mov 	ah, $02												; Set cursor position
   139 000000B5 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   140 000000B7 CD10                    	int		$10													; Set cursor
   141                                  
   142                                  	; Set up GDT
   143 000000B9 FA                      	cli															; Disable ints
   144 000000BA 0F0116[2808]            	lgdt	[gdt_table]											; Set up GDTR
   145                                  
   146                                  	; Jump into protected mode, woot!
   147 000000BF 0F20C0                  	mov		eax, cr0											; Get control reg
   148 000000C2 0C01                    	or		al, 00000001b										; Set PE bit
   149 000000C4 0F22C0                  	mov		cr0, eax											; Write control reg
   150                                  
   151                                  	; Set up selectors
   152 000000C7 B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   153 000000CA 8ED8                    	mov		ds, ax												; Set data selector
   154                                  
   155 000000CC B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   156 000000CF 8EC0                    	mov		es, ax												; Update other selectors to point to data segment
   157 000000D1 8EE0                    	mov		fs, ax
   158 000000D3 8EE8                    	mov		gs, ax
   159 000000D5 8ED0                    	mov		ss, ax
   160                                  
   161                                  	; The kernel is loaded to $00003000 phys (segmented address 0300h:0000h)
   162 000000D7 66                      	db		$66													; 32-bit prefix
   163 000000D8 EA                      	db		$0EA												; Far jump opcode
   164 000000D9 [DF000000]              	dd		copy_kernel											; Jump to kernel copying routine
   165 000000DD 0800                    	dw		$08													; Selector for CODE32_DESCRIPTOR
   166                                  
   167                                  	BITS	32
   168                                  copy_kernel:
   169 000000DF BC00004000              	mov		esp, $400000										; Stackzors at $400000
   170                                  
   171 000000E4 B800A80000              	mov		eax, kern_loc_phys									; Physical kernel location
   172 000000E9 BB00001000              	mov		ebx, $00100000										; Destination memory address
   173 000000EE B900400000              	mov		ecx, $4000											; Number of long-words to copy (64KB)
   174                                  
   175 000000F3 90                      	align	4													; DWORD align
   176                                  .copy:
   177 000000F4 8B10                    	mov		edx, DWORD [eax]									; Read a DWORD from lowmem
   178 000000F6 8913                    	mov		DWORD [ebx], edx									; Write DWORD to himem
   179                                  
   180 000000F8 0504000000              	add		eax, $04											; Increment read ptr
   181 000000FD 81C304000000            	add		ebx, $04											; Increment write ptr
   182                                  
   183 00000103 E2EF                    	loop	.copy												; Loop and copy everything
   184                                  
   185                                  	; Here, we build a page directory and table to map $C0000000 to $00100000.
   186 00000105 31C0                    	xor		eax, eax
   187 00000107 BB00300000              	mov		ebx, MMU_PageDir
   188 0000010C B900100000              	mov		ecx, $1000
   189                                  
   190                                  .clrTablesLoop:
   191 00000111 8903                    	mov		DWORD [ebx], eax
   192 00000113 81C304000000            	add		ebx, $04
   193 00000119 E2F6                    	loop	.clrTablesLoop
   194                                  
   195                                  
   196                                  	; Since we only need to map 4M for right now, concern ourselves only with entry 0x300 and 0x000
   197                                  	; Also, map 0x00000000 to 0x003FFFFF
   198 0000011B C70500300000034000-     	mov		DWORD [MMU_PageDir+0x000], (MMU_PageTable1 | $3)
   199 00000124 00                 
   200                                  
   201 00000125 C705003C0000035000-     	mov		DWORD [MMU_PageDir+0xC00], (MMU_PageTable2 | $3)
   202 0000012E 00                 
   203 0000012F C705043C0000036000-     	mov		DWORD [MMU_PageDir+0xC04], (MMU_PageTable3 | $3)
   204 00000138 00                 
   205 00000139 C705083C0000037000-     	mov		DWORD [MMU_PageDir+0xC08], (MMU_PageTable4 | $3)
   206 00000142 00                 
   207 00000143 C7050C3C0000038000-     	mov		DWORD [MMU_PageDir+0xC0C], (MMU_PageTable5 | $3)
   208 0000014C 00                 
   209                                  
   210                                  
   211                                  	; Run a loop 1024 times to fill the first page table
   212 0000014D B900040000              	mov		ecx, $400
   213 00000152 31DB                    	xor		ebx, ebx											; Page table offset
   214 00000154 B807000000              	mov		eax, DWORD $00000007									; Physical address start
   215                                  
   216                                  .fillPageTable1:
   217 00000159 89049D00400000          	mov		DWORD [MMU_PageTable1+ebx*4], eax					; Write physical location
   218                                  
   219 00000160 43                      	inc		ebx													; Go to next entry in page table
   220 00000161 0500100000              	add		eax, $1000											; Increment physical address
   221 00000166 E2F1                    	loop	.fillPageTable1
   222                                  
   223                                  
   224                                  	; Run a loop 8192 times to fill the second page table
   225 00000168 B900100000              	mov		ecx, $1000
   226 0000016D 31DB                    	xor		ebx, ebx											; Page table offset
   227 0000016F B807001000              	mov		eax, DWORD $00100007								; Physical address start
   228                                  
   229                                  .fillPageTable2:
   230 00000174 89049D00500000          	mov		DWORD [MMU_PageTable2+ebx*4], eax					; Write physical location
   231                                  
   232 0000017B 43                      	inc		ebx													; Go to next entry in page table
   233 0000017C 0500100000              	add		eax, $1000											; Increment physical address
   234 00000181 E2F1                    	loop	.fillPageTable2
   235                                  
   236                                  
   237                                  	; Set paging directory to CR3
   238 00000183 B800300000              	mov		eax, MMU_PageDir
   239 00000188 0F22D8                  	mov		cr3, eax
   240                                  
   241                                  	; Enable paging in CR0
   242 0000018B 0F20C0                  	mov		eax, cr0
   243 0000018E 0D00000080              	or		eax, $80000000
   244 00000193 0F22C0                  	mov		cr0, eax
   245                                  
   246                                  	; Jump into kernel
   247 00000196 E9(000000C0)            	jmp		$0C0000000
   248                                  
   249                                  	BITS	16
   250                                  
   251                                  ;========================================================================================
   252                                  ; Renders the partition chooser
   253                                  ;========================================================================================
   254                                  render_partition_chooser:
   255 0000019B BE[5D06]                	mov 	si, str_select_partition							; Put string position into SI
   256 0000019E BA0105                  	mov		dx, $0501											; Cursor position
   257 000001A1 BF0700                  	mov		di, $07												; Set colour
   258 000001A4 E84702                  	call 	print_string										; Call string printing routine
   259                                  
   260 000001A7 C706[8E07]0407          	mov		WORD [LastCursorPosition], 0x0704					; Read last cursor position
   261                                  
   262 000001AD 66BA[96070000]          	mov		edx, HDD_BootablePartitions							; EDX contains bootable partition ptr
   263 000001B3 B90400                  	mov		cx, $04												; Loop 4x
   264                                  
   265                                  .disp_loop:
   266 000001B6 678A02                  	mov		al, BYTE [edx]										; Read bootability
   267 000001B9 2480                    	and		al, $80												; Get high bit only
   268 000001BB 3C80                    	cmp		al, $80												; Is it $80?
   269 000001BD 7505                    	jne		.not_bootable										; If not, it's not a bootable drive
   270                                  
   271 000001BF E81300                  	call	.render_boot										; Render bootable drive label
   272                                  
   273 000001C2 EB03                    	jmp		SHORT .next											; Skip over non-bootable code
   274                                  
   275                                  .not_bootable:
   276 000001C4 E87900                  	call	.render_noboot										; Render non-bootable drive label
   277                                  
   278                                  .next:
   279 000001C7 6642                    	inc		edx													; Go to next item
   280 000001C9 E2EB                    	loop	.disp_loop											; Loop over all 4 partitions
   281                                  
   282 000001CB BA010C                  	mov		dx, $0C01
   283 000001CE BE[F006]                	mov		si, str_err_clear_err								; Clear error
   284 000001D1 E81A02                  	call	print_string										; Display
   285                                  
   286 000001D4 C3                      	ret
   287                                  
   288                                  ;========================================================================================
   289                                  ; Renders an entry for a bootable drive
   290                                  ;========================================================================================
   291                                  .render_boot:
   292 000001D5 B004                    	mov		al, $04												; Max drive num to al
   293 000001D7 28C8                    	sub		al, cl												; Subtract loop counter
   294 000001D9 A2[3C02]                	mov		BYTE [.index], al									; Write index
   295 000001DC 0430                    	add		al, $30												; ASCII numbers
   296                                  
   297 000001DE 66C706[CF07]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   298 000001E6 2C                 
   299 000001E7 A2[D307]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   300 000001EA C706[D407]3A20          	mov		WORD [Temp_StrBuf+5], ": "							; Colon, space
   301                                  
   302 000001F0 60                      	pusha														; Push registers
   303 000001F1 66BA[D6070000]          	mov		edx, Temp_StrBuf+7									; String buffer write place
   304 000001F7 66BB[9F070000]          	mov		ebx, HDD_PartitionNames								; Partition names
   305 000001FD B90C00                  	mov		cx, $0C												; $0C characters
   306                                  
   307                                  .copyNameLoop:
   308 00000200 678A03                  	mov		al, BYTE [ebx]										; Copy a character
   309 00000203 678802                  	mov		BYTE [edx], al										; Write to temp buffer
   310 00000206 6643                    	inc		ebx													; Increment read pointer
   311 00000208 6642                    	inc		edx													; Increment write pointer
   312 0000020A E2F4                    	loop	.copyNameLoop
   313                                  
   314 0000020C 67C742FF0A00            	mov		WORD [edx-1], 0x000A								; Insert newline
   315                                  
   316 00000212 6631C0                  	xor		eax, eax											; Clear EAX
   317 00000215 66BA[9A070000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type matrix
   318 0000021B 0216[3C02]              	add		dl, BYTE [.index]
   319 0000021F 678A02                  	mov		al, BYTE [edx]										; Read FAT type to AL
   320                                  
   321 00000222 8A1E[9E07]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   322 00000226 80E303                  	and		bl, $3												; Get low 2 bits only
   323 00000229 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   324 0000022B 7503                    	jne		.no_highlight										; If not, branch.
   325                                  
   326 0000022D BF7000                  	mov		di, $070											; Black text on white background
   327                                  
   328                                  .no_highlight:
   329 00000230 8B16[8E07]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   330 00000234 BE[CF07]                	mov		si, Temp_StrBuf										; Temporary string buffer
   331 00000237 E8B401                  	call 	print_string										; Call string printing routine
   332 0000023A 61                      	popa														; Pop registers
   333                                  
   334 0000023B C3                      	ret
   335                                  
   336                                  .index:
   337 0000023C 00                      	db	0
   338                                  
   339                                  ;========================================================================================
   340                                  ; Renders an entry for a non-bootable drive.
   341                                  ;========================================================================================
   342 0000023D 90<rept>                	align 4
   343                                  
   344                                  .render_noboot:
   345 00000240 B004                    	mov		al, $04												; Max drive num to al
   346 00000242 28C8                    	sub		al, cl												; Subtract loop counter
   347 00000244 0430                    	add		al, $30												; ASCII numbers
   348                                  
   349 00000246 66C706[CF07]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   350 0000024E 2C                 
   351 0000024F A2[D307]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   352 00000252 66C706[D407]3A204E-     	mov		DWORD [Temp_StrBuf+5], ": No"						; "Not Bootable"
   353 0000025A 6F                 
   354 0000025B 66C706[D807]742042-     	mov		DWORD [Temp_StrBuf+9], "t Bo"
   355 00000263 6F                 
   356 00000264 66C706[DC07]6F7461-     	mov		DWORD [Temp_StrBuf+13], "otab"
   357 0000026C 62                 
   358 0000026D C706[E007]6C65          	mov		WORD [Temp_StrBuf+17], "le"
   359 00000273 C706[E207]0A00          	mov		WORD [Temp_StrBuf+19], 0x000A						; Newline, terminator
   360                                  
   361 00000279 60                      	pusha														; Push registers
   362                                  
   363 0000027A 8A1E[9E07]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   364 0000027E 80E303                  	and		bl, $3												; Get low 2 bits only
   365 00000281 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   366 00000283 7503                    	jne		.no_highlight2										; If not, branch.
   367                                  
   368 00000285 BF7000                  	mov		di, $070											; Black text on white background
   369                                  
   370                                  .no_highlight2:
   371 00000288 8B16[8E07]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   372 0000028C BE[CF07]                	mov		si, Temp_StrBuf										; Temporary string buffer
   373 0000028F E85C01                  	call 	print_string										; Call string printing routine
   374 00000292 61                      	popa														; Pop registers
   375                                  
   376 00000293 C3                      	ret
   377                                  
   378                                  ;========================================================================================
   379                                  ; Handle keypresses for chooser
   380                                  ;========================================================================================
   381                                  chooser_loop:
   382 00000294 E91500                  	jmp		partition_chooser_enter
   383                                  
   384 00000297 30E4                    	xor		ah, ah												; Wait for keystroke
   385 00000299 CD16                    	int		$16													; Call into BIOS
   386                                  
   387 0000029B 80FC50                  	cmp		ah, $50												; Down pressed?
   388 0000029E 7459                    	je		partition_chooser_dn
   389                                  
   390 000002A0 80FC48                  	cmp		ah, $48												; Up pressed?
   391 000002A3 7463                    	je		partition_chooser_up
   392                                  
   393 000002A5 80FC1C                  	cmp		ah, $1C												; Enter pressed?
   394 000002A8 7402                    	je		partition_chooser_enter
   395                                  
   396 000002AA EBE8                    	jmp		chooser_loop
   397                                  
   398                                  partition_chooser_enter:
   399 000002AC 31DB                    	xor		bx, bx												; Clear BX
   400 000002AE 8A1E[9E07]              	mov		bl, BYTE [HDD_Selected]								; Get selection
   401                                  
   402 000002B2 8A87[9607]              	mov		al, BYTE [HDD_BootablePartitions+bx]				; Check bootability status
   403 000002B6 2480                    	and		al, $80												; Get high bit only
   404 000002B8 3C80                    	cmp		al, $80
   405 000002BA 7527                    	jne		.noBootErr											; If not bootable, branch
   406                                  
   407                                  
   408 000002BC BE[0408]                	mov		si, kernel_filename									; Filename to find
   409 000002BF E8B907                  	call	FAT_FindFileAtRoot									; Find file
   410 000002C2 722A                    	jc		.fileNotFound										; Carry set = KERNEL.BIN not found
   411                                  
   412 000002C4 66A3[0008]              	mov		DWORD [kernel_cluster], eax							; Store cluster
   413                                  
   414 000002C8 31C0                    	xor		ax, ax												; Segment 0
   415 000002CA 8EC0                    	mov		es, ax												; Write segment											
   416 000002CC BF00A8                  	mov		di, kern_loc_phys									; Offset into segment
   417                                  
   418 000002CF 66A1[0008]              	mov		eax, DWORD [kernel_cluster]							; Kernel's cluster location
   419 000002D3 E81A08                  	call	FAT_ReadFile										; Read file
   420                                  
   421 000002D6 BE[4207]                	mov 	si, str_kernel_loaded_ok							; Put string position into SI
   422 000002D9 BA010C                  	mov		dx, $0C01											; Cursor position
   423 000002DC BF0200                  	mov		di, $02												; Set colour
   424 000002DF E80C01                  	call 	print_string										; Call string printing routine
   425                                  
   426 000002E2 C3                      	ret
   427                                  
   428                                  .noBootErr:
   429 000002E3 BA010C                  	mov		dx, $0C01
   430 000002E6 BE[9206]                	mov		si, str_err_not_bootable							; Not bootable error
   431 000002E9 E8FC00                  	call	print_error											; Display
   432 000002EC EBA6                    	jmp		chooser_loop
   433                                  
   434                                  .fileNotFound:
   435 000002EE BA010C                  	mov		dx, $0C01
   436 000002F1 BE[BC06]                	mov		si, str_err_kern_not_found							; Not found error
   437 000002F4 E8F100                  	call	print_error											; Display
   438 000002F7 EB9B                    	jmp		chooser_loop
   439                                  
   440                                  partition_chooser_dn:
   441 000002F9 A0[9E07]                	mov		al, BYTE [HDD_Selected]								; Read selection
   442 000002FC FEC8                    	dec		al													; Move cursor up
   443 000002FE 2403                    	and		al, $03												; Get low 2 bits only
   444 00000300 A2[9E07]                	mov		BYTE [HDD_Selected], al								; Restore
   445                                  
   446 00000303 E895FE                  	call	render_partition_chooser							; Update display
   447 00000306 EB8C                    	jmp		chooser_loop
   448                                  
   449                                  partition_chooser_up:
   450 00000308 A0[9E07]                	mov		al, BYTE [HDD_Selected]								; Read selection
   451 0000030B FEC0                    	inc		al													; Move cursor down
   452 0000030D 2403                    	and		al, $03												; Get low 2 bits only
   453 0000030F A2[9E07]                	mov		BYTE [HDD_Selected], al								; Restore
   454                                  
   455 00000312 E886FE                  	call	render_partition_chooser							; Update display
   456 00000315 E97CFF                  	jmp		chooser_loop
   457                                  
   458                                  ;========================================================================================
   459                                  ; Finds all partitions that are bootable.
   460                                  ;========================================================================================
   461                                  find_bootable_partitions:
   462 00000318 B90400                  	mov		cx, $4												; MBR contains 4 partition maps
   463                                  
   464 0000031B B8C007                  	mov		ax, $07C0											; Bootloader at 0x7C00
   465 0000031E 8EC0                    	mov		es, ax												; Set ES to the bootloader's place in memory
   466 00000320 BFBE01                  	mov		di, $1BE											; Start of partition map
   467                                  
   468 00000323 8CD8                    	mov		ax, ds												; Fetch data segment
   469 00000325 8EE8                    	mov		gs, ax												; Set GS to data segment
   470                                  
   471 00000327 66BE[96070000]          	mov		esi, HDD_BootablePartitions							; ESI contains bootable partition ptr
   472 0000032D 66BA[9F070000]          	mov		edx, HDD_PartitionNames								; Partition name ptr
   473                                  
   474                                  .loop:
   475 00000333 268A05                  	mov		al, BYTE [es:di]									; Read bootable flag
   476 00000336 2480                    	and		al, $80												; Get high bit only
   477 00000338 3C80                    	cmp		al, $80												; Is it $80?
   478 0000033A 754B                    	jne		.not_bootable										; If not, it's not a bootable drive
   479                                  
   480 0000033C 678806                  	mov		BYTE [esi], al										; Write bootability flag
   481                                  
   482 0000033F 880E[9E07]              	mov		BYTE [HDD_Selected], cl								; Write index
   483                                  
   484                                  	; Try to read the LBA of the partition
   485 00000343 26668B4508              	mov		eax, DWORD [es:di+8]								; Read partition LBA
   486 00000348 663D00000000            	cmp		eax, $00											; Is it zero?
   487 0000034E 7437                    	je		.no_valid_lba										; If so, fuck off
   488                                  
   489 00000350 66A3[F807]              	mov		DWORD [ExtendedRead_Table+0x08], eax				; Write LBA
   490 00000354 C706[F207]0100          	mov		WORD [ExtendedRead_Table+0x02], 0x01				; Read one sector
   491 0000035A C706[F407][C00B]        	mov		WORD [ExtendedRead_Table+0x04], SectorBuf			; Temporary sector buffer offset (seg 0)
   492                                  
   493 00000360 66A3[9C0B]              	mov		DWORD [FAT_PartitionOffset], eax					; Write offset into FAT
   494                                  
   495 00000364 60                      	pusha														; Push registers (BIOS may clobber them)
   496 00000365 BE[F007]                	mov 	si, ExtendedRead_Table								; address of "disk address packet"
   497 00000368 B442                    	mov 	ah, $42												; Extended Read
   498 0000036A 8A16[8D07]              	mov		dl, BYTE [BootDevice]								; Device number
   499 0000036E CD13                    	int 	$13
   500 00000370 61                      	popa														; Pop registers
   501 00000371 7214                    	jc 		SHORT .no_valid_lba									; If error, fuck off
   502                                  
   503 00000373 E82100                  	call	.typeDetermine										; Determine type and label loc
   504                                  
   505 00000376 51                      	push	cx													; Back up original loop counter
   506                                  
   507 00000377 B90B00                  	mov		cx, $0B												; Copy 0xB bytes
   508                                  .copy_str_loop:
   509 0000037A 678A18                  	mov		bl, BYTE [eax]										; Copy from source
   510 0000037D 67881A                  	mov		BYTE [edx], bl										; Write to target buffer
   511 00000380 6640                    	inc		eax													; Increment read pointer
   512 00000382 6642                    	inc		edx													; Increment write pointer
   513 00000384 E2F4                    	loop	.copy_str_loop										; Copy all bytes.
   514                                  
   515 00000386 59                      	pop		cx													; Restore original loop counter.
   516                                  
   517                                  .no_valid_lba:
   518                                  
   519                                  .not_bootable:
   520 00000387 81C71000                	add		di, $10												; Go to next entry in bootsector
   521 0000038B 6646                    	inc		esi													; Write next bootability flag
   522 0000038D 6681C20C000000          	add		edx, $0C											; Each entry of partition names is 0x0C in length
   523 00000394 E29D                    	loop	.loop												; Loop through all partitions
   524                                  
   525                                  .done:
   526 00000396 C3                      	ret
   527                                  
   528                                  ; Determines FAT type and stores pointer to read volume label in eax
   529                                  .typeDetermine:
   530 00000397 6656                    	push	esi													; Push old ESI
   531 00000399 BE[C00B]                	mov		si, SectorBuf										; Sector buffer
   532 0000039C E8AB04                  	call	FAT_DetermineType									; Determine type of FS
   533 0000039F 665E                    	pop		esi													; Pop ESI
   534                                  
   535 000003A1 6652                    	push	edx													; Back up EDX
   536 000003A3 B304                    	mov		bl, $04												; Max drive num to al
   537 000003A5 28CB                    	sub		bl, cl												; Subtract loop counter
   538                                  
   539 000003A7 66BA[9A070000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type ptr
   540 000003AD 28DA                    	sub		dl, bl												; Subtract index
   541 000003AF 678802                  	mov		BYTE [edx], al										; Write FAT size
   542 000003B2 665A                    	pop		edx													; Restore EDX
   543                                  
   544 000003B4 3C20                    	cmp		al, $20												; Is it a FAT32 volume?
   545 000003B6 7509                    	jne		.fat16_label										; If so, branch
   546                                  
   547 000003B8 66B8[070C0000]          	mov		eax, SectorBuf+$47									; FAT32 has volume label at 0x47
   548                                  
   549 000003BE E90600                  	jmp		.copy												; Copy label
   550                                  
   551                                  	; Extract volume label from sector buffer
   552                                  .fat16_label:
   553 000003C1 66B8[EB0B0000]          	mov		eax, SectorBuf+$2B									; FAT16 has volume label at 0x2B
   554                                  
   555                                  .copy:
   556 000003C7 C3                      	ret
   557                                  
   558                                  .index:
   559 000003C8 00                      	db		0
   560                                  
   561                                  ;========================================================================================
   562                                  ; Displays the memory size on the screen 
   563                                  ;========================================================================================
   564                                  display_memsize:
   565 000003C9 BE[0706]                	mov 	si, str_available_lomem								; Put string position into SI
   566 000003CC BA0002                  	mov		dx, $0200
   567 000003CF E81C00                  	call 	print_string										; Call string printing routine
   568 000003D2 A1[9207]                	mov		ax, WORD [MemBlocksBelow16M]						; Get total of memory blocks to EDX
   569 000003D5 E88100                  	call	hex_to_ascii
   570                                  
   571 000003D8 BE[3206]                	mov 	si, str_available_himem								; Put string position into SI
   572 000003DB BA0003                  	mov		dx, $0300
   573 000003DE E80D00                  	call 	print_string										; Call string printing routine
   574 000003E1 A1[9007]                	mov		ax, WORD [MemBlocksAbove16M]						; Get total of memory blocks to EDX
   575 000003E4 E87200                  	call	hex_to_ascii
   576                                  
   577 000003E7 C3                      	ret
   578                                  
   579                                  ;========================================================================================
   580                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h with the styling
   581                                  ; required for an error string.
   582                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   583                                  ;========================================================================================
   584                                  print_error:
   585 000003E8 BF4F00                  	mov		di, $04F											; White text on red background
   586 000003EB E90000                  	jmp 	print_string										; Call string printing routine
   587                                  
   588                                  ;========================================================================================
   589                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h.
   590                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   591                                  ;========================================================================================
   592                                  print_string:
   593 000003EE 52                      	push	dx													; Push column
   594                                  
   595 000003EF 85FF                    	test	di, di												; Check if DI is set
   596 000003F1 7406                    	jz		.useDefaultColour									; If so, branch
   597                                  
   598 000003F3 89F8                    	mov		ax, di												; Set colour
   599 000003F5 88C3                    	mov		bl, al												; Get low byte only
   600 000003F7 EB02                    	jmp		SHORT .setCursor
   601                                  
   602                                  .useDefaultColour:
   603 000003F9 B307                    	mov		bl, $007											; Light gray text on black background
   604                                  
   605                                  .setCursor:
   606 000003FB B402                    	mov 	ah, $02												; Set cursor position
   607 000003FD 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   608 000003FF CD10                    	int		$10													; Set cursor
   609                                  
   610                                  .repeat:
   611 00000401 AC                      	lodsb														; Get character from string
   612 00000402 3C00                    	cmp 	al, 0
   613 00000404 7417                    	je		.done												; If char is zero, end of string
   614                                  	
   615 00000406 3C0A                    	cmp 	al, $0A												; Process newline
   616 00000408 741B                    	je		.newline
   617                                  
   618 0000040A B90100                  	mov		cx, $01												; Write one ASCII character
   619 0000040D 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   620 0000040F B409                    	mov 	ah, $09												; Write character
   621 00000411 CD10                    	int		$10													; Print character
   622                                  
   623 00000413 B402                    	mov 	ah, $02												; Set cursor position
   624 00000415 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   625 00000417 FEC2                    	inc		dl													; Increment column
   626 00000419 CD10                    	int		$10													; Set cursor
   627                                  
   628 0000041B EBE4                    	jmp		.repeat
   629                                  
   630                                  .done:
   631 0000041D 8916[8E07]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   632 00000421 5A                      	pop		dx													; Pop position
   633 00000422 31FF                    	xor		di, di												; Clear colour
   634 00000424 C3                      	ret
   635                                  
   636                                  .newline:
   637 00000425 5A                      	pop		dx													; Get original column
   638 00000426 FEC6                    	inc		dh													; Increment row
   639 00000428 52                      	push	dx													; Push it back to stack
   640 00000429 EBD6                    	jmp		.repeat
   641                                  
   642                                  ;========================================================================================
   643                                  ; Prints the character in al to the screen at the current cursor position, using the
   644                                  ; colour in di.
   645                                  ;========================================================================================
   646                                  putc:
   647 0000042B 85FF                    	test	di, di												; Check if DI is set
   648 0000042D 7406                    	jz		.useDefaultColour									; If so, branch
   649                                  
   650 0000042F 89F8                    	mov		ax, di												; Set colour
   651 00000431 88C3                    	mov		bl, al												; Get low byte only
   652 00000433 EB02                    	jmp		SHORT .setCursor
   653                                  
   654                                  .useDefaultColour:
   655 00000435 B307                    	mov		bl, $007											; Light gray text on black background
   656                                  
   657                                  .setCursor:
   658 00000437 8B16[8E07]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   659 0000043B B402                    	mov 	ah, $02												; Set cursor position
   660 0000043D B700                    	mov		bh, $0												; Video page 0
   661 0000043F CD10                    	int		$10													; Set cursor
   662                                  
   663 00000441 B90100                  	mov		cx, $01												; Write one ASCII character
   664 00000444 B700                    	mov		bh, $0												; Video page 0
   665 00000446 B409                    	mov 	ah, $09												; Write character
   666 00000448 CD10                    	int		$10													; Print character
   667                                  
   668 0000044A FEC2                    	inc		dl													; Increment column
   669                                  
   670 0000044C B402                    	mov 	ah, $02												; Set cursor position
   671 0000044E B700                    	mov		bh, $0												; Video page 0
   672 00000450 CD10                    	int		$10													; Set cursor
   673                                  
   674 00000452 8916[8E07]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   675 00000456 31FF                    	xor		di, di												; Clear colour
   676 00000458 C3                      	ret
   677                                  
   678                                  ;========================================================================================
   679                                  ; Prints the value in eax to the screen.
   680                                  ;========================================================================================
   681                                  hex_to_ascii:
   682 00000459 31C9                    	xor 	cx, cx
   683                                  
   684 0000045B 88E1                    	mov 	cl, ah												; Move high byte of ax to cl
   685 0000045D E81000                  	call 	.nibble_high										; Print low nibble to ASCII
   686 00000460 88E1                    	mov 	cl, ah
   687 00000462 E81100                  	call 	.nibble_low
   688 00000465 88C1                    	mov 	cl, al
   689 00000467 E80600                  	call 	.nibble_high
   690 0000046A 88C1                    	mov 	cl, al
   691 0000046C E80700                  	call 	.nibble_low
   692 0000046F C3                      	ret
   693                                  
   694                                  .nibble_high:
   695 00000470 C0E904                  	shr 	cl, $04
   696 00000473 E90600                  	jmp 	.convert_check
   697                                  
   698                                  .nibble_low:
   699 00000476 80E10F                  	and 	cl, $0F
   700 00000479 E90000                  	jmp 	.convert_check
   701                                  
   702                                  .convert_check:
   703 0000047C 80F90A                  	cmp 	cl, $0A
   704 0000047F 7D0B                    	jge 	.letter
   705 00000481 80C130                  	add 	cl, $30
   706 00000484 50                      	push 	ax
   707 00000485 88C8                    	mov 	al, cl
   708 00000487 E8A1FF                  	call 	putc
   709 0000048A 58                      	pop 	ax
   710 0000048B C3                      	ret
   711                                  
   712                                  .letter:
   713 0000048C 80C137                  	add 	cl, $37
   714 0000048F 50                      	push	ax
   715 00000490 88C8                    	mov 	al, cl
   716 00000492 E896FF                  	call	putc
   717 00000495 58                      	pop 	ax
   718 00000496 C3                      	ret
   719                                  
   720                                  ;========================================================================================
   721                                  ; Uses BIOS INT $15, EAX $E820 function to get the memory map of the system
   722                                  ; input: 	es:di = destination buffer for 24 byte entries
   723                                  ; output: 	bp = entry count, trashes all registers except esi
   724                                  ;========================================================================================
   725                                  fetch_mem_map:
   726 00000497 6631DB                  	xor		ebx, ebx											; Clear EBX
   727 0000049A 31ED                    	xor		bp, bp												; Use BP as an entry count
   728 0000049C 66BA50414D53            	mov		edx, $0534D4150										; Place "SMAP" into edx (magic value)
   729 000004A2 66B820E80000            	mov		eax, $0E820											; Function call
   730                                  
   731 000004A8 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   732 000004B1 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   733 000004B7 CD15                    	int		$15
   734                                  
   735 000004B9 7257                    	jc		SHORT .error										; If carry set, the function is unsupported
   736                                  
   737 000004BB 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   738 000004C1 6639D0                  	cmp		eax, edx											; On success, EAX = "SMAP"
   739 000004C4 754C                    	jne		SHORT .error
   740                                  
   741 000004C6 6685DB                  	test	ebx, ebx											; ebx = 0 implies list is only 1 entry long (worthless)
   742 000004C9 7447                    	je		SHORT .error
   743                                  
   744 000004CB EB1F                    	jmp		SHORT .startLoop									; Jump into the loop
   745                                  
   746                                  .getEntryLoop:
   747 000004CD 66B820E80000            	mov		eax, $0E820											; Reset command (EAX, ECX are trashed)
   748 000004D3 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   749 000004DC 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   750 000004E2 CD15                    	int		$15
   751                                  
   752 000004E4 722A                    	jc		SHORT .done											; If carry set, we are done
   753 000004E6 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   754                                  
   755                                  .startLoop:
   756 000004EC E31D                    	jcxz	.skipEntry											; Skip any 0 length entries
   757                                  
   758 000004EE 80F914                  	cmp		cl, 20												; Did we get 24-byte ACPI 3.x data?
   759 000004F1 7607                    	jbe		SHORT .notext
   760                                  
   761 000004F3 26F6451401              	test	BYTE [es:di+20], 1									; If so, is the "ignore this data" bit clear?
   762 000004F8 7411                    	je		SHORT .skipEntry
   763                                  
   764                                  .notext:
   765 000004FA 26668B4D08              	mov		ecx, [es:di+8]										; get lower dword of memory region length
   766 000004FF 26660B4D0C              	or		ecx, [es:di+12]										; Check if zero (OR with upper dword)
   767 00000504 7405                    	jz		.skipEntry											; If length qword is 0, skip entry
   768                                  
   769 00000506 45                      	inc		bp													; We got a good entry, increment count, go to next entry
   770                                  
   771 00000507 81C71800                	add		di, 24
   772                                  
   773                                  .skipEntry:
   774 0000050B 6685DB                  	test	ebx, ebx											; If EBX = 0, then the BIOS has given us all entries
   775 0000050E 75BD                    	jne		SHORT .getEntryLoop
   776                                  
   777                                  .done:
   778 00000510 F8                      	clc															; There is "jc" on end of list to this point, so the carry must be cleared
   779 00000511 C3                      	ret
   780                                  
   781                                  .error:
   782 00000512 F9                      	stc															; Set carry if this BIOS sucks ass and doesn't support this
   783 00000513 C3                      	ret
   784                                  
   785                                  ;========================================================================================
   786                                  ; Writes a register dump to the VGA hardware
   787                                  ;========================================================================================
   788                                  VGA_MISC_WRITE		EQU	$3C2
   789                                  VGA_SEQ_INDEX		EQU	$3C4
   790                                  VGA_SEQ_DATA		EQU	$3C5
   791                                  VGA_CRTC_INDEX		EQU	$3D4
   792                                  VGA_CRTC_DATA		EQU	$3D5
   793                                  VGA_INSTAT_READ		EQU	$3DA
   794                                  
   795                                  NUM_SEQ_REGS		EQU	5
   796                                  NUM_CRTC_REGS		EQU	25
   797                                  
   798                                  write_regs:
   799 00000514 56                      	push 	si
   800 00000515 52                      	push 	dx
   801 00000516 51                      	push 	cx
   802 00000517 50                      	push 	ax
   803 00000518 FC                      	cld
   804                                  
   805                                  ; write MISC register
   806 00000519 BAC203                  	mov 	dx, VGA_MISC_WRITE
   807 0000051C AC                      	lodsb
   808 0000051D EE                      	out 	dx, al
   809                                  
   810                                  ; write SEQuencer registers
   811 0000051E B90500                  	mov 	cx, NUM_SEQ_REGS
   812 00000521 30E4                    	xor 	ah, ah
   813                                  
   814                                  write_seq:
   815 00000523 BAC403                  	mov 	dx, VGA_SEQ_INDEX
   816 00000526 88E0                    	mov 	al, ah
   817 00000528 EE                      	out 	dx, al
   818                                  
   819 00000529 BAC503                  	mov 	dx, VGA_SEQ_DATA
   820 0000052C AC                      	lodsb
   821 0000052D EE                      	out 	dx, al
   822                                  
   823 0000052E FEC4                    	inc 	ah
   824 00000530 E2F1                    	loop 	write_seq
   825                                  
   826                                  ; write CRTC registers
   827                                  ; Unlock CRTC registers: enable writes to CRTC regs 0-7
   828 00000532 BAD403                  	mov 	dx, VGA_CRTC_INDEX
   829 00000535 B011                    	mov 	al, 17
   830 00000537 EE                      	out 	dx, al
   831                                  
   832 00000538 BAD503                  	mov 	dx, VGA_CRTC_DATA
   833 0000053B EC                      	in		al, dx
   834 0000053C 247F                    	and 	al, $7F
   835 0000053E EE                      	out 	dx, al
   836                                  
   837                                  ; Unlock CRTC registers: enable access to vertical retrace regs
   838 0000053F BAD403                  	mov 	dx, VGA_CRTC_INDEX
   839 00000542 B003                    	mov 	al, 3
   840 00000544 EE                      	out 	dx, al
   841                                  
   842 00000545 BAD503                  	mov 	dx ,VGA_CRTC_DATA
   843 00000548 EC                      	in		al, dx
   844 00000549 0C80                    	or		al, $80
   845 0000054B EE                      	out		dx, al
   846                                  
   847                                  ; make sure CRTC registers remain unlocked
   848 0000054C 8A4411                  	mov		al,[si + 17]
   849 0000054F 247F                    	and 	al, $7F
   850 00000551 884411                  	mov 	[si + 17],al
   851                                  
   852 00000554 8A4403                  	mov 	al,[si + 3]
   853 00000557 0C80                    	or		al, $80
   854 00000559 884403                  	mov 	[si + 3], al
   855                                  
   856                                  ; now, finally, write them
   857 0000055C B91900                  	mov 	cx, NUM_CRTC_REGS
   858 0000055F B400                    	mov 	ah, 0
   859                                  
   860                                  write_crtc:
   861 00000561 BAD403                  	mov 	dx, VGA_CRTC_INDEX
   862 00000564 88E0                    	mov 	al, ah
   863 00000566 EE                      	out 	dx, al
   864                                  
   865 00000567 BAD503                  	mov 	dx, VGA_CRTC_DATA
   866 0000056A AC                      	lodsb
   867 0000056B EE                      	out 	dx, al
   868                                  
   869 0000056C FEC4                    	inc 	ah
   870 0000056E E2F1                    	loop write_crtc
   871                                  
   872 00000570 58                      	pop 	ax
   873 00000571 59                      	pop 	cx
   874 00000572 5A                      	pop 	dx
   875 00000573 5E                      	pop 	si
   876 00000574 C3                      	ret
   877                                  
   878                                  ;	align	32
   879                                  ;fat_loader_entry:
   880                                  ;	incbin		"./loader_c.bin"
   881                                  
   882                                  ;========================================================================================
   883                                  ; DATA SECTION
   884                                  ;========================================================================================
   885                                  regs_90x60:
   886                                  ; MISC
   887 00000575 E7                      	db	0E7h
   888                                  ; SEQuencer
   889 00000576 0301030002              	db	03h, 01h, 03h, 00h, 02h
   890                                  ; CRTC
   891 0000057B 6B595A82608D0B3E        	db	6Bh, 59h,  5Ah, 82h, 60h,  8Dh, 0Bh,  3Eh,
   892 00000583 0047060700000000        	db	00h, 47h,  06h, 07h, 00h,  00h, 00h,  00h,
   893 0000058B EA0CDF2D08E805A3        	db	0EAh, 0Ch, 0DFh, 2Dh, 08h, 0E8h, 05h, 0A3h,
   894 00000593 FF                      	db 	0FFh
   895                                  ; GC (no)
   896                                  ; AC (no)
   897                                  
   898                                  str_stage2loaded:
   899 00000594 537461676520322042-     	db 	'Stage 2 Bootloader (boot2)', 0
   900 0000059D 6F6F746C6F61646572-
   901 000005A6 2028626F6F74322900 
   902                                  
   903                                  str_errorDetectMem:
   904 000005AF 4572726F7220646574-     	db 	"Error detecting available memory, cannot continue", 0
   905 000005B8 656374696E67206176-
   906 000005C1 61696C61626C65206D-
   907 000005CA 656D6F72792C206361-
   908 000005D3 6E6E6F7420636F6E74-
   909 000005DC 696E756500         
   910                                  
   911                                  str_floppyError:
   912 000005E1 466C6F707079204572-     	db 	"Floppy Error, press any key to retry", $0A, 0
   913 000005EA 726F722C2070726573-
   914 000005F3 7320616E79206B6579-
   915 000005FC 20746F207265747279-
   916 00000605 0A00               
   917                                  
   918                                  str_available_lomem:
   919 00000607 436F6E74696E756F75-     	db 	"Continuous 01K blocks below 0x01000000: 0x", 0
   920 00000610 732030314B20626C6F-
   921 00000619 636B732062656C6F77-
   922 00000622 203078303130303030-
   923 0000062B 30303A20307800     
   924                                  
   925                                  str_available_himem:
   926 00000632 436F6E74696E756F75-     	db 	"Continuous 64K blocks above 0x01000000: 0x", 0
   927 0000063B 732036344B20626C6F-
   928 00000644 636B732061626F7665-
   929 0000064D 203078303130303030-
   930 00000656 30303A20307800     
   931                                  
   932                                  str_select_partition:
   933 0000065D 557365207468652063-     	db 	"Use the cursor to select the partition to boot from.", 0
   934 00000666 7572736F7220746F20-
   935 0000066F 73656C656374207468-
   936 00000678 652070617274697469-
   937 00000681 6F6E20746F20626F6F-
   938 0000068A 742066726F6D2E00   
   939                                  
   940                                  str_err_not_bootable:
   941 00000692 546869732070617274-     	db 	"This partition is not marked as bootable!", 0
   942 0000069B 6974696F6E20697320-
   943 000006A4 6E6F74206D61726B65-
   944 000006AD 6420617320626F6F74-
   945 000006B6 61626C652100       
   946                                  
   947                                  str_err_kern_not_found:
   948 000006BC 436F756C64206E6F74-     	db	"Could not find KERNEL.BIN at the root of the drive!", 0
   949 000006C5 2066696E64204B4552-
   950 000006CE 4E454C2E42494E2061-
   951 000006D7 742074686520726F6F-
   952 000006E0 74206F662074686520-
   953 000006E9 64726976652100     
   954                                  
   955                                  str_err_clear_err:
   956 000006F0 20<rept>                	times	0x40 db 0x20
   957 00000730 00                      	db	0
   958                                  
   959                                  
   960                                  str_kernel_loading:
   961 00000731 4C6F6164696E67206B-     	db 	"Loading kernel: ", 0
   962 0000073A 65726E656C3A2000   
   963                                  
   964                                  str_kernel_loaded_ok:
   965 00000742 4B65726E656C206C6F-     	db 	"Kernel loaded. Transferring control now...", 0
   966 0000074B 616465642E20547261-
   967 00000754 6E7366657272696E67-
   968 0000075D 20636F6E74726F6C20-
   969 00000766 6E6F772E2E2E00     
   970                                  
   971                                  str_err_loadkernel:
   972 0000076D 436F756C64206E6F74-     	db 	"Could not load kernel: Fuck you", 0
   973 00000776 206C6F6164206B6572-
   974 0000077F 6E656C3A204675636B-
   975 00000788 20796F7500         
   976                                  
   977                                  BootDevice:
   978 0000078D 00                      	db	0
   979                                  
   980                                  LastCursorPosition:
   981 0000078E 0000                    	dw	0
   982                                  
   983                                  MemBlocksAbove16M:
   984 00000790 0000                    	dw	0
   985                                  
   986                                  MemBlocksBelow16M:
   987 00000792 0000                    	dw	0
   988                                  
   989                                  MemMap_NumEntries:
   990 00000794 0000                    	dw	0
   991                                  
   992                                  HDD_BootablePartitions:
   993 00000796 00000000                	dd	0
   994                                  
   995                                  HDD_BootablePartitionsFATType:
   996 0000079A 00000000                	dd	0
   997                                  
   998                                  HDD_Selected:
   999 0000079E 00                      	db	0
  1000                                  
  1001                                  HDD_PartitionNames:
  1002 0000079F 00<rept>                	times	(0xB+1)*4 db 0
  1003                                  
  1004                                  Temp_StrBuf:
  1005 000007CF 00<rept>                	times	0x20 db 0
  1006                                  
  1007 000007EF 90                      	align 2
  1008                                  ExtendedRead_Table:
  1009 000007F0 10                      	db	$10
  1010 000007F1 00                      	db	0
  1011 000007F2 0000                    	dw	0														; Num blocks
  1012 000007F4 0000                    	dw	0														; Dest
  1013 000007F6 0000                    	dw	0														; Memory page
  1014 000007F8 00000000                	dd	0														; Starting LBA
  1015 000007FC 00000000                	dd	0	
  1016                                  
  1017                                  kernel_cluster:
  1018 00000800 00000000                	dd	0
  1019                                  
  1020                                  kernel_filename:
  1021 00000804 4B45524E454C202042-     	db	"KERNEL  BIN", 0
  1022 0000080D 494E00             
  1023                                  
  1024                                  ;========================================================================================
  1025                                  ; Global Descriptor Table
  1026                                  ;========================================================================================
  1027                                  	align	$10
  1028                                  
  1029                                  gdt_start:
  1030 00000810 0000000000000000        	dd	$00, $00												; Null Descriptor
  1031                                  
  1032                                  	; Code segment
  1033 00000818 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
  1034 0000081A 0000                    	dw	$0000													; Base 0:15 = $0000
  1035 0000081C 00                      	db	$00														; Base 16:23 = $00
  1036 0000081D 9A                      	db	$9A														; Access byte: Present, ring 0, Exec, grow up, R/W
  1037 0000081E CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
  1038 0000081F 00                      	db	$00														; Base 24:31 = $00
  1039                                  
  1040                                  	; Data segment
  1041 00000820 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
  1042 00000822 0000                    	dw	$0000													; Base 0:15 = $0000
  1043 00000824 00                      	db	$00														; Base 16:23 = $00
  1044 00000825 92                      	db	$92														; Access byte: Present, ring 0, Not exec, grow up, R/W
  1045 00000826 CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
  1046 00000827 00                      	db	$00														; Base 24:31 = $00	
  1047                                  
  1048                                  gdt_table:
  1049 00000828 1700                    	dw	(gdt_table-gdt_start)-1									; Length
  1050 0000082A [10080000]              	dd	gdt_start												; Physical address to GDT	
  1051                                  
  1052 0000082E 90<rept>                	align 4														; DWORD align
  1053                                  	%include	"./fat.asm"
  1054                              <1> ;========================================================================================
  1055                              <1> ; FAT Filesystem Library v 0.1
  1056                              <1> ; By Tristan Seifert
  1057                              <1> ;
  1058                              <1> ; All sector values returned by functions are "logical," i.e. they are relative to the
  1059                              <1> ; first sector of the filesystem.
  1060                              <1> ;
  1061                              <1> ; In addition, this library does not offer full support for FAT12 due to the uncommonality
  1062                              <1> ; of it on media besides floppy disks.
  1063                              <1> ;========================================================================================
  1064                              <1> ; Equates
  1065                              <1> ;========================================================================================
  1066                              <1> 
  1067                              <1> ;========================================================================================
  1068                              <1> ; Initialises the FAT filesystem library
  1069                              <1> ;========================================================================================
  1070                              <1> FAT_Init:
  1071 00000830 B90001              <1> 	mov		cx, (1024/4)										; Clear 2 sectors worth
  1072 00000833 66BA[C00B0000]      <1> 	mov		edx, FAT_ReadBuffer									; Pointer to buffer
  1073 00000839 6631C0              <1> 	xor		eax, eax											; Clear value ($00000000)
  1074                              <1> 
  1075                              <1> .clearLoop:
  1076 0000083C 66678902            <1> 	mov		DWORD [edx], eax									; Clear a DWORD
  1077 00000840 6681C204000000      <1> 	add		edx, $04											; Increment pointer
  1078 00000847 E2F3                <1> 	loop	.clearLoop											; Loop
  1079                              <1> 
  1080                              <1> .done:
  1081 00000849 C3                  <1> 	ret
  1082                              <1>  
  1083                              <1> ;========================================================================================
  1084                              <1> ; Determines the type of FAT, give that the first logical sector of the partition is
  1085                              <1> ; pointed to by SI, and returns the FAT bit size in AL.
  1086                              <1> ;
  1087                              <1> ; This is how Microsoft recommends we determine FAT type:
  1088                              <1> ;
  1089                              <1> ; RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytesPerSec - 1)) / BPB_BytesPerSec
  1090                              <1> ; DataSectors = Total Sectors - (BPB_ReservedSectors + (BPB_NumFATs * FATSz) + RootDirSectors)
  1091                              <1> ; Count of clusters = DataSectors/BPB_SectorsPerCluster 
  1092                              <1> ;
  1093                              <1> ; FAT12: Total clusters < 4085
  1094                              <1> ; FAT16: Total clusters > 4085 && < 65525
  1095                              <1> ; FAT32: Total clusters > 65525
  1096                              <1> ;========================================================================================
  1097                              <1> FAT_DetermineType:
  1098 0000084A 60                  <1> 	pusha														; Push registers
  1099                              <1> 
  1100 0000084B E8EF00              <1> 	call	FAT_ReadBPB											; 
  1101                              <1> 
  1102                              <1> 	; Calculate RootDirSectors
  1103 0000084E 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1104 00000851 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1105 00000854 8B1E[7E0B]          <1> 	mov		bx,	WORD [FAT_BPB_RootEntCnt]						; Read root entries 
  1106 00000858 66C1E305            <1> 	shl		ebx, 5												; Each root entry is 32 bytes
  1107                              <1> 
  1108 0000085C A1[6C0B]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1109 0000085F 48                  <1> 	dec		ax													; Subtract one
  1110 00000860 6601D8              <1> 	add		eax, ebx											; Add root entry length to sector length
  1111                              <1> 
  1112 00000863 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1113 00000866 8B0E[6C0B]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1114 0000086A F7F1                <1> 	div		cx													; Divide by sector length (result = ax)
  1115 0000086C A3[880B]            <1> 	mov		WORD [FAT_RootDirSectors], ax						; Store result in memory
  1116                              <1> 
  1117                              <1> 	; Calculate number of data sectors
  1118 0000086F 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1119 00000872 A0[7C0B]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1120                              <1> 
  1121 00000875 668B0E[800B]        <1> 	mov		ecx, DWORD [FAT_BPB_FATSz]							; Read FAT size
  1122 0000087A 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in eax
  1123                              <1> 
  1124 0000087D 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1125 00000880 8B0E[7A0B]          <1> 	mov		cx, WORD [FAT_BPB_ReservedSectors]					; Read number of reserved sectors
  1126                              <1> 
  1127 00000884 6601C8              <1> 	add		eax, ecx											; Add count of reserved sectors to FAT size
  1128 00000887 668B0E[880B]        <1> 	mov		ecx, DWORD [FAT_RootDirSectors]						; Read RootDirSectors
  1129 0000088C 6601C8              <1> 	add		eax, ecx											; Add root directory sectors
  1130                              <1> 
  1131 0000088F 6691                <1> 	xchg	eax, ecx											; Subtract all of the above from total sectors
  1132                              <1> 
  1133 00000891 66A1[840B]          <1> 	mov		eax, DWORD [FAT_BPB_TotSec]							; Read total sector count
  1134 00000895 6629C8              <1> 	sub		eax, ecx											; Subtract from total sector count
  1135                              <1> 
  1136 00000898 66A3[8C0B]          <1> 	mov		DWORD [FAT_DataSectors], eax						; Store to memory
  1137                              <1> 
  1138                              <1> 	; Calculate cluster count
  1139 0000089C 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1140 0000089F 8A1E[780B]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1141 000008A3 66A1[8C0B]          <1> 	mov		eax, DWORD [FAT_DataSectors]						; Read number of data sectors
  1142 000008A7 66F7F3              <1> 	div		ebx													; Divide by sectors/cluster value 
  1143                              <1> 
  1144 000008AA 66A3[980B]          <1> 	mov		DWORD [FAT_TotalClusters], eax						; Store result in EAX
  1145                              <1> 
  1146                              <1> 	; Now, do some comparisons!
  1147 000008AE 663DF50F0000        <1> 	cmp		eax, 4085											; Is the FS FAT12?
  1148 000008B4 7F07                <1> 	jg		.notFAT12											; If not, branch
  1149                              <1> 
  1150 000008B6 C606[A00B]0C        <1> 	mov		BYTE [FAT_Type], 12									; FAT12
  1151 000008BB EB17                <1> 	jmp		SHORT .done											; Return
  1152                              <1> 
  1153                              <1> .notFAT12:
  1154 000008BD 663DF5FF0000        <1> 	cmp		eax, 65525											; Is the FS FAT16?
  1155 000008C3 7F0A                <1> 	jg		.notFAT16											; If not, branch
  1156                              <1> 
  1157 000008C5 E84C00              <1> 	call	FAT16_Calculate_RootDirSec							; Calculate location of root directory
  1158                              <1> 
  1159 000008C8 C606[A00B]10        <1> 	mov		BYTE [FAT_Type], 16									; FAT16
  1160 000008CD EB05                <1> 	jmp		SHORT .done											; Return
  1161                              <1> 
  1162                              <1> .notFAT16:
  1163                              <1> 	; Okay, if we get down here, it HAS to be FAT32 or a corrupt FS
  1164 000008CF C606[A00B]20        <1> 	mov		BYTE [FAT_Type], 32									; FAT32
  1165                              <1> 
  1166                              <1> .done:
  1167 000008D4 E80500              <1> 	call	FAT_Calculate_Misc									; Calculate miscellaneous stuff
  1168 000008D7 61                  <1> 	popa														; Restore registers
  1169                              <1> 
  1170 000008D8 A0[A00B]            <1> 	mov		al, BYTE [FAT_Type]									; Store FAT type in AL
  1171                              <1> 
  1172 000008DB C3                  <1> 	ret
  1173                              <1> 
  1174                              <1> ;========================================================================================
  1175                              <1> ; Calculates miscellaneous values that the FAT driver uses later
  1176                              <1> ;========================================================================================
  1177                              <1> FAT_Calculate_Misc:
  1178 000008DC 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1179 000008DF 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1180 000008E2 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1181                              <1> 
  1182 000008E5 8B0E[880B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1183 000008E9 8B1E[7A0B]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1184                              <1> 
  1185 000008ED 6601CB              <1> 	add		ebx, ecx											; Add to root dir sectors reserved sectors
  1186                              <1> 
  1187 000008F0 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1188 000008F3 8A0E[7C0B]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1189 000008F7 66A1[800B]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1190 000008FB 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1191                              <1> 
  1192 000008FE 6601D8              <1> 	add		eax, ebx											; Add FAT sectors to root dir and reserved count
  1193                              <1> 
  1194 00000901 66A3[900B]          <1> 	mov		DWORD [FAT_FirstDataSector], eax					; Store first data sector
  1195                              <1> 
  1196 00000905 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1197 00000908 8B0E[880B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1198 0000090C 6629C8              <1> 	sub		eax, ecx											; Subtract ecx
  1199 0000090F 66A3[940B]          <1> 	mov		DWORD [FAT_FirstClusterLocation], eax				; Write shaften
  1200 00000913 C3                  <1> 	ret
  1201                              <1> 
  1202                              <1> ;========================================================================================
  1203                              <1> ; Calculates the sector for the root directory for FAT12 and FAT16.
  1204                              <1> ;========================================================================================
  1205                              <1> FAT16_Calculate_RootDirSec:
  1206 00000914 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1207 00000917 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1208 0000091A 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1209                              <1> 
  1210 0000091D 8B1E[7A0B]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1211                              <1> 
  1212 00000921 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1213 00000924 A0[7C0B]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1214                              <1> 
  1215 00000927 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1216 0000092A 8A0E[7C0B]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1217 0000092E 66A1[800B]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1218 00000932 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1219                              <1> 
  1220 00000935 6601D8              <1> 	add		eax, ebx											; Add reserved sector count
  1221                              <1> 
  1222 00000938 66A3[740B]          <1> 	mov		DWORD [FAT_BPB_RootClus], eax						; Write location of root cluster
  1223                              <1> 
  1224                              <1> .done:
  1225 0000093C C3                  <1> 	ret
  1226                              <1> 
  1227                              <1> ;========================================================================================
  1228                              <1> ; Reads the BPB from the FAT 1st sector in SI.
  1229                              <1> ;========================================================================================
  1230                              <1> FAT_ReadBPB:
  1231 0000093D 8B440B              <1> 	mov		ax, WORD [si+11]									; Read Bytes/sector
  1232 00000940 A3[6C0B]            <1> 	mov		WORD [FAT_BPB_BytesPerSec], ax						; ""
  1233                              <1> 
  1234 00000943 8A440D              <1> 	mov		al, BYTE [si+13]									; Read sectors/cluster
  1235 00000946 A2[780B]            <1> 	mov		BYTE [FAT_BPB_SectorsPerCluster], al				; ""
  1236                              <1> 
  1237 00000949 8B440E              <1> 	mov		ax, WORD [si+14]									; Read reserved sectors
  1238 0000094C A3[7A0B]            <1> 	mov		WORD [FAT_BPB_ReservedSectors], ax					; ""
  1239                              <1> 
  1240 0000094F 8A4410              <1> 	mov		al, BYTE [si+16]									; Read number of FATs
  1241 00000952 A2[7C0B]            <1> 	mov		BYTE [FAT_BPB_NumFATs], al							; ""
  1242                              <1> 
  1243 00000955 8B4411              <1> 	mov		ax, WORD [si+17]									; Read num root entries
  1244 00000958 A3[7E0B]            <1> 	mov		WORD [FAT_BPB_RootEntCnt], ax						; ""
  1245                              <1> 
  1246 0000095B 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1247                              <1> 
  1248 0000095E 668B4420            <1> 	mov		eax, DWORD [si+32]									; Read BPB_TotSec32 first
  1249 00000962 663D00000000        <1> 	cmp		eax, 0												; Is EAX zero?
  1250 00000968 7503                <1> 	jne		.writeTotSec										; If not, branch
  1251                              <1> 
  1252 0000096A 8B4413              <1> 	mov		ax, WORD [si+19]									; Read BPB_TotSec16 first
  1253                              <1> 
  1254                              <1> .writeTotSec:
  1255 0000096D 66A3[840B]          <1> 	mov		DWORD [FAT_BPB_TotSec], eax							; ""
  1256                              <1> 
  1257 00000971 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1258                              <1> 
  1259 00000974 8B4416              <1> 	mov		ax, WORD [si+22]									; Read BPB_FATSz16
  1260 00000977 3D0000              <1> 	cmp		ax, 0												; Is it zero?
  1261 0000097A 7507                <1> 	jne		.writeFATSz											; If not, branch.
  1262                              <1> 
  1263 0000097C 668B4424            <1> 	mov		eax, DWORD [si+36]									; Read BPB_FATSz32
  1264                              <1> 
  1265 00000980 E80500              <1> 	call	.readFAT32Specifics									; Read FAT32-specific data
  1266                              <1> 
  1267                              <1> .writeFATSz:
  1268 00000983 66A3[800B]          <1> 	mov		DWORD [FAT_BPB_FATSz], eax							; Write FAT size
  1269                              <1> 
  1270 00000987 C3                  <1> 	ret
  1271                              <1> 
  1272                              <1> ; All FAT32-specific stuff is read here
  1273                              <1> .readFAT32Specifics:
  1274 00000988 8B5C28              <1> 	mov		bx, WORD [si+40]									; Read BPB_ExtFlags
  1275 0000098B 891E[700B]          <1> 	mov		WORD [FAT_BPB_ExtFlags], bx							; Write BPB_ExtFlags
  1276                              <1> 
  1277 0000098F 8B5C2A              <1> 	mov		bx, WORD [si+42]									; Read BPB_FSVer
  1278 00000992 891E[720B]          <1> 	mov		WORD [FAT_BPB_FSVer], bx							; Write BPB_FSVer
  1279                              <1> 
  1280 00000996 668B5C2C            <1> 	mov		ebx, DWORD [si+44]									; Read BPB_RootClus
  1281 0000099A 66891E[740B]        <1> 	mov		DWORD [FAT_BPB_RootClus], ebx						; Write BPB_RootClus
  1282                              <1> 
  1283 0000099F 8B5C30              <1> 	mov		bx, WORD [si+48]									; Read BPB_FSInfo
  1284 000009A2 891E[6E0B]          <1> 	mov		WORD [FAT_BPB_FSInfo], bx							; Write BPB_FSInfo
  1285                              <1> 
  1286                              <1> 
  1287 000009A6 C3                  <1> 	ret
  1288                              <1> 
  1289                              <1> ;========================================================================================
  1290                              <1> ; Calculates the entry location for cluster N in the FAT.
  1291                              <1> ; eax: Cluster number
  1292                              <1> ; eax: Sector number containing the cluster
  1293                              <1> ; ebx: Offset in sector
  1294                              <1> ;========================================================================================
  1295                              <1> FAT_FindClusterInTable:
  1296 000009A7 60                  <1> 	pusha														; Back up regs
  1297                              <1> 
  1298 000009A8 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1299 000009AB 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1300                              <1> 
  1301 000009AE 8A1E[A00B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1302 000009B2 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1303 000009B5 7406                <1> 	je		.FAT32												; If so, jump
  1304                              <1> 
  1305 000009B7 66D1E0              <1> 	shl		eax, 1												; Multiply cluster by 2
  1306 000009BA E90400              <1> 	jmp		.cont												; Skip over shift below
  1307                              <1> 
  1308                              <1> .FAT32:
  1309 000009BD 66C1E002            <1> 	shl		eax, 2												; Multiply cluster by 4
  1310                              <1> 
  1311                              <1> .cont:
  1312                              <1> 	; eax = Offset into FAT table
  1313                              <1> 
  1314 000009C1 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1315 000009C4 8B0E[6C0B]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1316 000009C8 66F7F1              <1> 	div		ecx													; Divide offset by bytes/sector
  1317                              <1> 	; eax = quotient, edx = remainder
  1318                              <1> 
  1319 000009CB 8B1E[7A0B]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; BX = reserved sector count
  1320 000009CF 6601D8              <1> 	add		eax, ebx											; Add to FAT offset (sectors)
  1321                              <1> 
  1322 000009D2 66A3[E709]          <1> 	mov		DWORD [.secNum], eax								; Store sector number
  1323 000009D6 8916[EB09]          <1> 	mov		WORD [.secOff], dx									; Store offset into sector
  1324                              <1> 
  1325                              <1> .done:
  1326 000009DA 61                  <1> 	popa														; Restore regs
  1327                              <1> 
  1328 000009DB 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1329 000009DE 66A1[E709]          <1> 	mov		eax, DWORD [.secNum]								; Get sector number
  1330 000009E2 8B1E[EB09]          <1> 	mov		bx, WORD [.secOff]									; Get offset into sector
  1331                              <1> 
  1332 000009E6 C3                  <1> 	ret
  1333                              <1> 
  1334                              <1> .secNum:
  1335 000009E7 00000000            <1> 	dd		0
  1336                              <1> 
  1337                              <1> .secOff:
  1338 000009EB 0000                <1> 	dw		0
  1339                              <1> 
  1340                              <1> ;========================================================================================
  1341                              <1> ; Converts the cluster number in eax into a sector number.
  1342                              <1> ;========================================================================================
  1343                              <1> FAT_ClusterToSector:
  1344 000009ED 6651                <1> 	push	ecx													; Back up EBX
  1345                              <1> 
  1346 000009EF 6648                <1> 	dec		eax													; Subtract 2 from cluster
  1347 000009F1 6648                <1> 	dec		eax													; ""
  1348                              <1> 
  1349 000009F3 6631C9              <1> 	xor		ecx, ecx											; Clear EBX
  1350 000009F6 8A0E[780B]          <1> 	mov		cl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1351 000009FA 66F7E1              <1> 	mul		ecx													; Multiply by number of sectors per cluster
  1352                              <1> 
  1353 000009FD 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1354 00000A00 8B0E[880B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Root directory sector
  1355 00000A04 6601C8              <1> 	add		eax, ecx											; Add to sector count
  1356                              <1> 
  1357 00000A07 668B0E[900B]        <1> 	mov		ecx, DWORD [FAT_FirstDataSector]					; Get first data sector
  1358 00000A0C 6601C8              <1> 	add		eax, ecx											; Add data sector offset
  1359                              <1> 
  1360 00000A0F 6659                <1> 	pop		ecx													; Restore EBX
  1361                              <1> 
  1362 00000A11 C3                  <1> 	ret
  1363                              <1> 
  1364                              <1> ;========================================================================================
  1365                              <1> ; Reads the sector containing the FAT entry for the specified cluster, then returns the
  1366                              <1> ; FAT read from the sector.
  1367                              <1> ; eax: Cluster
  1368                              <1> ; Sets carry flag if error.
  1369                              <1> ;========================================================================================
  1370                              <1> FAT_ReadFAT:
  1371 00000A12 E892FF              <1> 	call	FAT_FindClusterInTable								; Locate cluster
  1372 00000A15 6653                <1> 	push	ebx													; Push offset into sector to stack
  1373                              <1> 
  1374                              <1> 	; Read sector to memory
  1375 00000A17 E82500              <1> 	call	FAT_ReadSector										; Read sector
  1376 00000A1A 665B                <1> 	pop		ebx													; Pop offset into sector
  1377 00000A1C 721F                <1> 	jc 		SHORT .error										; If error, return
  1378                              <1> 
  1379                              <1> 	; Sector is now read to memory
  1380 00000A1E 8A1E[A00B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1381 00000A22 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1382 00000A25 740D                <1> 	je		.FAT32												; If so, jump
  1383                              <1> 
  1384 00000A27 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1385 00000A2A 678B83[C00B0000]    <1> 	mov		ax, WORD [FAT_ReadBuffer+ebx]						; Read FAT16 entry
  1386 00000A31 E90800              <1> 	jmp		.done												; Skip over read below
  1387                              <1> 
  1388                              <1> .FAT32:
  1389 00000A34 66678B83[C00B0000]  <1> 	mov		eax, DWORD [FAT_ReadBuffer+ebx]						; Read FAT32 entry
  1390                              <1> 
  1391                              <1> .done:
  1392 00000A3C C3                  <1> 	ret
  1393                              <1> 
  1394                              <1> .error:
  1395 00000A3D F9                  <1> 	stc															; Set carry
  1396 00000A3E C3                  <1> 	ret
  1397                              <1> 
  1398                              <1> ;========================================================================================
  1399                              <1> ; Reads a logical sector from the drive.
  1400                              <1> ; eax: Logical sector
  1401                              <1> ; Clears the carry flag if successful, set otherwise.
  1402                              <1> ;========================================================================================
  1403                              <1> FAT_ReadSector:
  1404 00000A3F 660306[9C0B]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1405                              <1> 
  1406 00000A44 668B1E[A40B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1407 00000A49 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1408 00000A4C 7429                <1> 	je		.done												; If they are the same sector, branch
  1409                              <1> 
  1410 00000A4E 66A3[B00B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1411 00000A52 C706[AA0B]0100      <1> 	mov		WORD [FAT_ERTable+0x02], 0x01						; Read one sector
  1412 00000A58 C706[AC0B][C00B]    <1> 	mov		WORD [FAT_ERTable+0x04], FAT_ReadBuffer				; Temporary sector buffer offset (seg 0)
  1413 00000A5E C706[AE0B]0000      <1> 	mov		WORD [FAT_ERTable+0x06], 0x00						; Page 0
  1414                              <1> 
  1415 00000A64 66A3[A40B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Store LBA we're loading
  1416                              <1> 
  1417 00000A68 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1418 00000A69 BE[A80B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1419 00000A6C B442                <1> 	mov 	ah, $42												; Extended Read
  1420 00000A6E 8A16[A10B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1421 00000A72 CD13                <1> 	int 	$13													; Perform read
  1422 00000A74 61                  <1> 	popa														; Pop registers
  1423 00000A75 7202                <1> 	jc 		SHORT .error										; If error, return
  1424                              <1> 
  1425                              <1> .done:
  1426 00000A77 F8                  <1> 	clc															; Clear carry
  1427 00000A78 C3                  <1> 	ret
  1428                              <1> 
  1429                              <1> .error:
  1430 00000A79 F9                  <1> 	stc															; Set carry
  1431 00000A7A C3                  <1> 	ret
  1432                              <1> 
  1433                              <1> ;========================================================================================
  1434                              <1> ; Tries to locate a file with the name pointed to by in esi in the root directory of the
  1435                              <1> ; FAT. If found, returns the first cluster of the file in eax, filesize in ebx, and
  1436                              <1> ; clears carry. If not found, sets carry.
  1437                              <1> ;
  1438                              <1> ; Note that this only searches the short filename.
  1439                              <1> ;========================================================================================
  1440                              <1> FAT_FindFileAtRoot:
  1441 00000A7B 60                  <1> 	pusha														; Push regs
  1442 00000A7C 66A1[740B]          <1> 	mov		eax, DWORD [FAT_BPB_RootClus]						; Read root sector location
  1443 00000A80 E86AFF              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1444 00000A83 E8B9FF              <1> 	call	FAT_ReadSector										; Read sector
  1445                              <1> 
  1446 00000A86 66BF[C00B0000]      <1> 	mov		edi, FAT_ReadBuffer									; FAT read buffer
  1447 00000A8C B91000              <1> 	mov		cx, (512/32)										; Search the first 512/32 entries
  1448                              <1> 
  1449                              <1> .searchLoop:
  1450 00000A8F 678A07              <1> 	mov		al, BYTE [edi]										; Read first byte of string
  1451                              <1> 
  1452 00000A92 3CE5                <1> 	cmp		al, $0E5											; Is directory entry free?
  1453 00000A94 7426                <1> 	je		.fileEntryIgnore									; If so, branch
  1454 00000A96 3C00                <1> 	cmp		al, $00												; Is directory entry free and last one?
  1455 00000A98 7428                <1> 	je		.notFound											; If so, exit loop.
  1456                              <1> 
  1457                              <1> 	; Store pointers
  1458 00000A9A 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1459 00000A9D 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1460 00000AA0 6689F8              <1> 	mov		eax, edi											; Copy read pointer to EAX
  1461 00000AA3 6689F2              <1> 	mov		edx, esi											; Copy filename compare ptr to EDX
  1462                              <1> 
  1463                              <1> 	; Compare filename
  1464 00000AA6 51                  <1> 	push	cx													; Push loop counter
  1465 00000AA7 B90B00              <1> 	mov		cx, $0B												; Filename is 11 bytes
  1466                              <1> 
  1467                              <1> .comparison:
  1468 00000AAA 678A18              <1> 	mov		bl, BYTE [eax]										; Read soruce ptr
  1469 00000AAD 673A1A              <1> 	cmp		bl, BYTE [edx]										; Compare against target
  1470 00000AB0 7509                <1> 	jne		.compareFailed										; If not equal, branch
  1471                              <1> 
  1472 00000AB2 6640                <1> 	inc		eax													; Increment read pointer
  1473 00000AB4 6642                <1> 	inc		edx													; Increment target pointer
  1474                              <1> 
  1475 00000AB6 E2F2                <1> 	loop	.comparison											; Compare 11 bytes
  1476                              <1> 
  1477 00000AB8 59                  <1> 	pop		cx													; Pop loop counter from stack
  1478 00000AB9 EB0A                <1> 	jmp		SHORT .found										; File was found
  1479                              <1> 
  1480                              <1> .compareFailed:
  1481 00000ABB 59                  <1> 	pop		cx													; Pop loop counter
  1482                              <1> 
  1483                              <1> .fileEntryIgnore:
  1484 00000ABC 81C72000            <1> 	add		di, $20												; Read next entry
  1485 00000AC0 E2CD                <1> 	loop	.searchLoop											; Loop through entries
  1486                              <1> 
  1487                              <1> ; Drop down here once loop finishes: file not found.
  1488                              <1> .notFound:
  1489 00000AC2 61                  <1> 	popa														; Pop registers
  1490 00000AC3 F9                  <1> 	stc															; Set carry
  1491 00000AC4 C3                  <1> 	ret
  1492                              <1> 
  1493                              <1> ; We found the file
  1494                              <1> .found:
  1495 00000AC5 678B471A            <1> 	mov		ax, WORD [edi+26]									; Read cluster low word
  1496 00000AC9 A3[E80A]            <1> 	mov		WORD [.clusterOfFile], ax							; ""
  1497 00000ACC 678B4714            <1> 	mov		ax, WORD [edi+20]									; Read cluster high word
  1498 00000AD0 A3[EA0A]            <1> 	mov		WORD [.clusterOfFile+2], ax							; ""
  1499                              <1> 
  1500 00000AD3 66678B471C          <1> 	mov		eax, DWORD [edi+28]									; Read filesize
  1501 00000AD8 66A3[EC0A]          <1> 	mov		DWORD [.sizeOfFile], eax							; ""
  1502                              <1> 
  1503 00000ADC 61                  <1> 	popa														; Pop registers
  1504 00000ADD 66A1[E80A]          <1> 	mov		eax, DWORD [.clusterOfFile]							; Read file's cluster
  1505 00000AE1 668B1E[EC0A]        <1> 	mov		ebx, DWORD [.sizeOfFile]							; Read file's size
  1506 00000AE6 F8                  <1> 	clc															; Clear carry bit
  1507 00000AE7 C3                  <1> 	ret
  1508                              <1> 
  1509                              <1> 	align	4
  1510                              <1> .clusterOfFile:
  1511 00000AE8 00000000            <1> 	dd		0
  1512                              <1> .sizeOfFile:
  1513 00000AEC 00000000            <1> 	dd		0
  1514                              <1> 
  1515                              <1> ;========================================================================================
  1516                              <1> ; Reads the file whose first cluster is in eax to es:di.
  1517                              <1> ;
  1518                              <1> ; Note that this function returns after reading a maximum of 256 chunks.
  1519                              <1> ;========================================================================================
  1520                              <1> FAT_ReadFile:
  1521 00000AF0 60                  <1> 	pusha														; Push all regisers
  1522                              <1> 
  1523 00000AF1 E80800              <1> 	call	FAT_ReadCluster										; Read cluster
  1524 00000AF4 7203                <1> 	jc 		SHORT .error										; If error, return
  1525                              <1> 
  1526                              <1> ;	xor		cx, cx												; Clear CX
  1527                              <1> ;	mov		gs, cx												; Clear GS
  1528                              <1> ;
  1529                              <1> ;.readLoop:
  1530                              <1> ;	call	FAT_ReadFAT											; Read FAT entry for current cluster
  1531                              <1> ;	and		eax, $0FFFFFFF										; Ignore high nybble
  1532                              <1> ;	cmp		eax, $0FFFFFF8										; End of chain marker?
  1533                              <1> ;	jae		.done												; If so, branch (unsigned compare)
  1534                              <1> ;
  1535                              <1> ;	call	FAT_ReadCluster										; Read cluster
  1536                              <1> ;	jc 		SHORT .error										; If error, return
  1537                              <1> ;
  1538                              <1> ;	mov		cx, gs												; Read GS
  1539                              <1> ;	inc		cx													; Increment GS
  1540                              <1> ;	mov		gs, cx												; Move back to GS
  1541                              <1> ;
  1542                              <1> ;	cmp		cl, $0FF											; Is it max? ($FF)
  1543                              <1> ;	je		.error												; If so, we're done
  1544                              <1> ;
  1545                              <1> ;	jmp		.readLoop											; Loop until all sectors of the file are read
  1546                              <1> 
  1547                              <1> .done:
  1548 00000AF6 61                  <1> 	popa														; Pop registers
  1549 00000AF7 F8                  <1> 	clc															; Clear carry
  1550 00000AF8 C3                  <1> 	ret
  1551                              <1> 
  1552                              <1> .error:
  1553 00000AF9 61                  <1> 	popa														; Pop registers
  1554 00000AFA F9                  <1> 	stc															; Set carry
  1555 00000AFB C3                  <1> 	ret
  1556                              <1> 
  1557                              <1> ;========================================================================================
  1558                              <1> ; Reads a logical sector from the drive.
  1559                              <1> ; eax: Logical cluster
  1560                              <1> ; es:di: Memory location (Incremented after read)
  1561                              <1> ; Clears the carry flag if successful, set otherwise.
  1562                              <1> ;========================================================================================
  1563                              <1> FAT_ReadCluster:
  1564 00000AFC 66A3[680B]          <1> 	mov		DWORD [.origCluster], eax							; Store original cluster
  1565 00000B00 E8EAFE              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1566                              <1> 
  1567 00000B03 660306[9C0B]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1568                              <1> 
  1569 00000B08 668B1E[A40B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1570 00000B0D 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1571 00000B10 742E                <1> 	je		.done												; If they are the same sector, branch
  1572 00000B12 66A3[A40B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Save sector we're reading
  1573                              <1> 
  1574 00000B16 31DB                <1> 	xor		bx, bx												; Clear BX
  1575 00000B18 8A1E[780B]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1576 00000B1C C706[AA0B]FF01      <1> 	mov		WORD [FAT_ERTable+0x02], $1FF							; Write sectors/cluster 
  1577 00000B22 66A3[B00B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1578 00000B26 893E[AC0B]          <1> 	mov		WORD [FAT_ERTable+0x04], di							; Offset in segment
  1579 00000B2A 8C06[AE0B]          <1> 	mov		WORD [FAT_ERTable+0x06], es							; Segment
  1580                              <1> 
  1581 00000B2E 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1582 00000B2F BE[A80B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1583 00000B32 B442                <1> 	mov 	ah, $42												; Extended Read		
  1584 00000B34 8A16[A10B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1585 00000B38 CD13                <1> 	int 	$13													; Perform read
  1586 00000B3A 61                  <1> 	popa														; Pop registers
  1587 00000B3B 7209                <1> 	jc 		SHORT .error										; If error, return
  1588                              <1> 
  1589 00000B3D E80C00              <1> 	call	.incrementReadPtr									; Increment read pointer
  1590                              <1> 
  1591                              <1> .done:	
  1592 00000B40 66A1[680B]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1593 00000B44 F8                  <1> 	clc															; Clear carry
  1594 00000B45 C3                  <1> 	ret
  1595                              <1> 
  1596                              <1> .error:
  1597 00000B46 66A1[680B]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1598 00000B4A F9                  <1> 	stc															; Set carry
  1599 00000B4B C3                  <1> 	ret
  1600                              <1> 
  1601                              <1> .incrementReadPtr:
  1602 00000B4C 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1603 00000B4F A1[6C0B]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1604 00000B52 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1605 00000B55 8A1E[780B]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read bytes per sector
  1606                              <1> 
  1607 00000B59 66F7E3              <1> 	mul		ebx													; EAX = value to add to write ptr
  1608 00000B5C 01C7                <1> 	add		di, ax												; Add cluster length to di
  1609 00000B5E 7107                <1> 	jno		.noOverflow											; If overflow bit isn't set, branch
  1610                              <1> 
  1611 00000B60 8CC0                <1> 	mov		ax, es												; Read segment we're writing to
  1612 00000B62 050010              <1> 	add		ax, $1000											; Write in next segment
  1613 00000B65 8EC0                <1> 	mov		es, ax												; Write to segment register
  1614                              <1> 
  1615                              <1> .noOverflow:
  1616 00000B67 C3                  <1> 	ret
  1617                              <1> 
  1618                              <1> 	align	4
  1619                              <1> .origCluster:
  1620 00000B68 00000000            <1> 	dd		0
  1621                              <1> 
  1622                              <1> ;========================================================================================
  1623                              <1> ; Data section
  1624                              <1> ;========================================================================================
  1625                              <1> 	align	4
  1626                              <1> FAT_BPB_BytesPerSec: ; file offset 11
  1627 00000B6C 0000                <1> 	dw		0
  1628                              <1> FAT_BPB_FSInfo: ; file offset 48, FAT32 only
  1629 00000B6E 0000                <1> 	dw		0
  1630                              <1> FAT_BPB_ExtFlags: ; file offset 40, FAT32 only
  1631 00000B70 0000                <1> 	dw		0
  1632                              <1> FAT_BPB_FSVer: ; file offset 42, FAT32 only
  1633 00000B72 0000                <1> 	dw		0
  1634                              <1> 
  1635                              <1> 	align	4
  1636                              <1> FAT_BPB_RootClus: ; file offset 44, FAT32 only
  1637 00000B74 00000000            <1> 	dd		0
  1638                              <1> FAT_BPB_SectorsPerCluster: ; file offset 13
  1639 00000B78 00                  <1> 	db		0
  1640                              <1> 
  1641 00000B79 90                  <1> 	align	2
  1642                              <1> FAT_BPB_ReservedSectors: ; file offset 14
  1643 00000B7A 0000                <1> 	dw		0
  1644                              <1> FAT_BPB_NumFATs: ; file offset 16
  1645 00000B7C 00                  <1> 	db		0
  1646                              <1> 
  1647 00000B7D 90                  <1> 	align	2
  1648                              <1> FAT_BPB_RootEntCnt:	; file offset 17
  1649 00000B7E 0000                <1> 	dw		0
  1650                              <1> 
  1651                              <1> 	align	4
  1652                              <1> FAT_BPB_FATSz: ; file offset 22 if FAT16, 36 if FAT32 and word at 22 is 0
  1653 00000B80 00000000            <1> 	dd		0
  1654                              <1> 
  1655                              <1> ; Works with FAT32
  1656                              <1> ; For the total sector count, try to read BPB_FATSz16 first (19), then the 32-bit at off 32
  1657                              <1> FAT_BPB_TotSec: ; file offset 32 if 19 = 0
  1658 00000B84 00000000            <1> 	dd		0
  1659                              <1> 
  1660                              <1> ; Calculated when identifying FS
  1661                              <1> FAT_RootDirSectors:
  1662 00000B88 0000                <1> 	dw		0
  1663                              <1> 
  1664 00000B8A 90<rept>            <1> 	align	4
  1665                              <1> FAT_DataSectors:
  1666 00000B8C 00000000            <1> 	dd		0
  1667                              <1> FAT_FirstDataSector:
  1668 00000B90 00000000            <1> 	dd		0
  1669                              <1> FAT_FirstClusterLocation:
  1670 00000B94 00000000            <1> 	dd		0
  1671                              <1> FAT_TotalClusters:
  1672 00000B98 00000000            <1> 	dd		0
  1673                              <1> 
  1674                              <1> ; Offset into drive in sectors to the start of the FAT partition
  1675                              <1> FAT_PartitionOffset:
  1676 00000B9C 00000000            <1> 	dd		0
  1677                              <1> FAT_Type:
  1678 00000BA0 00                  <1> 	db		0
  1679                              <1> 
  1680                              <1> ; BIOS drive to read from
  1681                              <1> FAT_Drive:
  1682 00000BA1 00                  <1> 	db		0
  1683                              <1> 
  1684 00000BA2 90<rept>            <1> 	align	4
  1685                              <1> FAT_LastLoadedSector:
  1686 00000BA4 00000000            <1> 	dd		0
  1687                              <1> 
  1688                              <1> 	align	4
  1689                              <1> FAT_ERTable:
  1690 00000BA8 10                  <1> 	db	$10
  1691 00000BA9 00                  <1> 	db	0
  1692 00000BAA 0000                <1> 	dw	0														; Num blocks
  1693 00000BAC 0000                <1> 	dw	0														; Dest
  1694 00000BAE 0000                <1> 	dw	0														; Memory page
  1695 00000BB0 00000000            <1> 	dd	0														; Starting LBA
  1696 00000BB4 00000000            <1> 	dd	0	
  1697                              <1> 
  1698 00000BB8 90<rept>            <1> 	align	$10
  1699                              <1> FAT_ReadBuffer:
  1700                                  
  1701                                  SectorBuf:
  1702 00000BC0 00<rept>                	times	512 db 0

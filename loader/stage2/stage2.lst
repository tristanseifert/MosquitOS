     1                                  	BITS	16
     2                                  	org		$0500
     3                                  
     4                                  ; Kernel will be loaded to segment $0A80, or $00A800 physical
     5                                  kern_loc:				EQU $0A80
     6                                  kern_loc_phys:			EQU kern_loc<<4
     7                                  kern_start:				EQU 6
     8                                  kern_len:				EQU 32									; Length in sectors
     9                                  
    10                                  SVGA_Mode:				EQU $117
    11                                  
    12                                  ; Location to store various BIOS info at
    13                                  Kern_Info_Struct:		EQU $0160								; $001600 phys (len = $400 max)
    14                                  Kern_Info_StructPhys:	EQU (Kern_Info_Struct<<4)
    15                                  VESA_SupportedModes:	EQU	$01A0								; $001A00 phys (len = $200)
    16                                  VESA_ModeInfos:			EQU	$01C0								; $001C00 phys (len = $100)
    17                                  
    18                                  BIOS_MemMapSeg:			EQU	$0300								; $003000 phys (len = $800 max)
    19                                  
    20                                  ; Physical protected mode addresses
    21                                  MMU_PageDir:			EQU $004000
    22                                  MMU_PageTable1:			EQU $005000
    23                                  MMU_PageTable2:			EQU $006000
    24                                  MMU_PageTable3:			EQU $007000
    25                                  MMU_PageTable4:			EQU $008000
    26                                  MMU_PageTable5:			EQU $009000
    27                                  
    28                                  ;	+$00 uint32_t munchieValue; // Should be "KERN"
    29                                  ;	+$04 uint16_t supportBits;
    30                                  ;	+$06 uint16_t high16Mem; // 64K blocks above 16M
    31                                  ;	+$08 uint16_t low16Mem; // 1k blocks below 16M
    32                                  ;	+$0A uint32_t memMap; // 32-bit ptr to list
    33                                  ;	+$0E uint16_t numMemMapEnt; // Number of entries in above map
    34                                  ;	+$10 uint8_t vesaSupport;
    35                                  ;	+$11 uint8_t bootDrive;
    36                                  ;	+$12 uint32_t vesaMap;
    37                                  
    38                                  stage2_start:
    39 00000000 B80080                  	mov		ax, $8000											; AX = stack segment value (Stack to go at $80000)
    40 00000003 8ED0                    	mov 	ss, ax
    41 00000005 BC0010                  	mov 	sp, 4096											; Set up SP
    42                                  
    43 00000008 8CC8                    	mov 	ax, cs												; Set data segment to where we're loaded
    44 0000000A 8ED8                    	mov 	ds, ax
    45                                  
    46 0000000C 8816[A507]              	mov		BYTE [BootDevice], dl								; Save boot device number
    47 00000010 8816[C10B]              	mov		BYTE [FAT_Drive], dl								; Set FAT read drive
    48                                  
    49 00000014 66C70600164B45524E      	mov		DWORD [Kern_Info_StructPhys], "KERN"				; Set magic value for kern struct
    50                                  
    51 0000001D A0[A507]                	mov		al, [BootDevice]									; Set boot drive
    52 00000020 A21116                  	mov		BYTE [Kern_Info_StructPhys+$11], al					; ""
    53                                  
    54                                  	; Set up video
    55 00000023 B400                    	mov		ah, $00												; Change video mode
    56 00000025 B003                    	mov		al, $03												; 80x25 text mode
    57 00000027 CD10                    	int		$10													; Call video BIOS
    58                                  
    59 00000029 BE[AC05]                	mov 	si, str_stage2loaded								; Put string position into SI
    60 0000002C 31D2                    	xor		dx, dx												; Cursor position
    61 0000002E BF2F00                  	mov		di, $2F												; Set colour
    62 00000031 E8D203                  	call 	print_string										; Call string printing routine
    63                                  
    64                                  	; Call VESA BIOS routines to get supported video modes
    65 00000034 B8A001                  	mov		ax, VESA_SupportedModes								; Memory location of supported mode struct
    66 00000037 8EC0                    	mov		es, ax												; ""
    67 00000039 31FF                    	xor		di, di												; Offset 0 in segment
    68                                  
    69 0000003B 2666C70556424532        	mov		[es:di], DWORD "VBE2"								; Tell BIOS we want 512 bytes of data
    70                                  
    71 00000043 B8004F                  	mov		ax, $4F00											; VESA BIOS routines â€” get supported modes
    72 00000046 CD10                    	int		$10													; Perform lookup
    73                                  
    74 00000048 B8C001                  	mov		ax, VESA_ModeInfos									; Buffer
    75 0000004B 8EC0                    	mov		es, ax
    76 0000004D 31FF                    	xor		di, di												; Offset 0 into buffer
    77 0000004F B8014F                  	mov		ax, $4F01											; Get VESA mode info function
    78 00000052 B91701                  	mov		cx, SVGA_Mode										; Mode to get info for
    79 00000055 CD10                    	int		$10
    80                                  
    81                                  
    82 00000057 84E4                    	test	ah, ah												; Is AH not zero (i.e. error)
    83 00000059 7400                    	je		.vesaDone											; If so, VESA is unsupported
    84                                  
    85                                  .vesaDone:
    86                                  	; Call BIOS to get memory information
    87 0000005B 31C9                    	xor 	cx, cx
    88 0000005D 31D2                    	xor 	dx, dx
    89 0000005F B801E8                  	mov 	ax, $0E801
    90 00000062 CD15                    	int 	$15													; Request upper memory size
    91 00000064 7250                    	jc 		error_memoryDetect
    92 00000066 80FC86                  	cmp 	ah, $86												; Unsupported function
    93 00000069 744B                    	je		error_memoryDetect
    94 0000006B 80FC80                  	cmp		ah, $80												; Invalid command
    95 0000006E 7446                    	je		error_memoryDetect
    96 00000070 E304                    	jcxz 	.useax												; Was the CX result invalid?
    97                                   
    98 00000072 89C8                    	mov		ax, cx												; Number of continuous 1K blocks (1M-16M)
    99 00000074 89D3                    	mov		bx, dx												; Number of continuous 64K block above 16M
   100                                  
   101                                  .useax:
   102 00000076 31FF                    	xor		di, di												; Clear DI
   103 00000078 891E[A807]              	mov		WORD [MemBlocksAbove16M], bx						; Store amount of memory available
   104 0000007C 891E0616                	mov		WORD [Kern_Info_StructPhys+$06], bx					; Highmem
   105 00000080 A3[AA07]                	mov		WORD [MemBlocksBelow16M], ax						; ""
   106 00000083 A30816                  	mov		WORD [Kern_Info_StructPhys+$08], ax					; Lowmem
   107                                  
   108 00000086 E85803                  	call	display_memsize										; Display the memory size
   109                                  
   110                                  	; Fetch memory map
   111 00000089 B80003                  	mov 	ax, BIOS_MemMapSeg									; Write mem map to $01800 in physical space
   112 0000008C 8EC0                    	mov 	es, ax
   113 0000008E 31FF                    	xor		di, di												; Start of segment
   114                                  
   115 00000090 E81C04                  	call	fetch_mem_map										; Fetch a memory map
   116 00000093 7221                    	jc 		SHORT error_memoryDetect							; Branch if error
   117                                  
   118 00000095 892E0E16                	mov		WORD [Kern_Info_StructPhys+$0E], bp					; ""
   119 00000099 66C7060A1600300000      	mov		DWORD [Kern_Info_StructPhys+$0A], (BIOS_MemMapSeg<<4); Physical location of table
   120                                  
   121                                  	; Initialise FAT library
   122 000000A2 E8AB07                  	call	FAT_Init
   123                                  
   124                                  	; Check which partitions are bootable from MBR partition map
   125 000000A5 E88802                  	call	find_bootable_partitions
   126 000000A8 C606[B607]00            	mov		BYTE [HDD_Selected], 0								; Clear HDD selection
   127                                  
   128                                  	; Set up the partition chooser UI
   129 000000AD E80301                  	call	render_partition_chooser
   130                                  
   131                                  	; Process keypresses, and loads kernel from FS if ENTER is pressed
   132 000000B0 E8F901                  	call	chooser_loop
   133 000000B3 E90800                  	jmp		boot
   134                                  
   135                                  ;========================================================================================
   136                                  ; Memory detection error handler
   137                                  ;========================================================================================
   138                                  error_memoryDetect:
   139 000000B6 BE[C705]                	mov 	si, str_errorDetectMem								; Put string position into SI
   140 000000B9 E84403                  	call 	print_error											; Call string printing routine
   141 000000BC EBFE                    	jmp		$
   142                                  
   143                                  ;========================================================================================
   144                                  ; Code to boot the kernel
   145                                  ;========================================================================================
   146                                  boot:
   147                                  	; Hide cursor
   148 000000BE 31D2                    	xor		dx, dx												; Clear dx
   149 000000C0 F7D2                    	not		dx													; dx = $FFFF
   150 000000C2 B402                    	mov 	ah, $02												; Set cursor position
   151 000000C4 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   152 000000C6 CD10                    	int		$10													; Set cursor
   153                                  
   154                                  	; Go into SVGA mode specified, linear framebuffer, clear memory
   155 000000C8 BB1741                  	mov		bx, ($4000 | SVGA_Mode)								; SVGA mode
   156 000000CB B8024F                  	mov		ax, $4F02											; SVGA routine calls
   157 000000CE CD10                    	int		$10													; Call video BIOS
   158                                  
   159                                  	; Set up GDT
   160 000000D0 FA                      	cli															; Disable ints
   161 000000D1 0F0116[4808]            	lgdt	[gdt_table]											; Set up GDTR
   162                                  
   163                                  	; Enable protected mode
   164 000000D6 0F20C0                  	mov		eax, cr0											; Get control reg
   165 000000D9 0C01                    	or		al, 00000001b										; Set PE bit
   166 000000DB 0F22C0                  	mov		cr0, eax											; Write control reg
   167                                  
   168                                  	; Set up selectors
   169 000000DE B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   170 000000E1 8ED8                    	mov		ds, ax												; Set data selector
   171                                  
   172 000000E3 B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   173 000000E6 8EC0                    	mov		es, ax												; Update other selectors to point to data segment
   174 000000E8 8EE0                    	mov		fs, ax
   175 000000EA 8EE8                    	mov		gs, ax
   176 000000EC 8ED0                    	mov		ss, ax
   177                                  
   178                                  	; The kernel is loaded to $00003000 phys (segmented address 0300h:0000h)
   179 000000EE 66                      	db		$66													; 32-bit prefix
   180 000000EF EA                      	db		$0EA												; Far jump opcode
   181 000000F0 [F6000000]              	dd		copy_kernel											; Jump to kernel copying routine
   182 000000F4 0800                    	dw		$08													; Selector for CODE32_DESCRIPTOR
   183                                  
   184                                  	; Protected mode code runs as 32-bits
   185                                  	BITS	32
   186                                  copy_kernel:
   187 000000F6 BC00004000              	mov		esp, $400000										; Stackzors at $400000
   188                                  
   189 000000FB B800A80000              	mov		eax, kern_loc_phys									; Physical kernel location
   190 00000100 BB00001000              	mov		ebx, $00100000										; Destination memory address
   191 00000105 B900400000              	mov		ecx, $4000											; Number of long-words to copy (64KB)
   192                                  
   193 0000010A 90<rept>                	align	4													; DWORD align
   194                                  .copy:
   195 0000010C 8B10                    	mov		edx, DWORD [eax]									; Read a DWORD from lowmem
   196 0000010E 8913                    	mov		DWORD [ebx], edx									; Write DWORD to himem
   197                                  
   198 00000110 0504000000              	add		eax, $04											; Increment read ptr
   199 00000115 81C304000000            	add		ebx, $04											; Increment write ptr
   200                                  
   201 0000011B E2EF                    	loop	.copy												; Loop and copy everything
   202                                  
   203                                  	; Here, we build a page directory and table to map $C0000000 to $00100000.
   204 0000011D 31C0                    	xor		eax, eax
   205 0000011F BB00400000              	mov		ebx, MMU_PageDir
   206 00000124 B900100000              	mov		ecx, $1000
   207                                  
   208                                  .clrTablesLoop:
   209 00000129 8903                    	mov		DWORD [ebx], eax
   210 0000012B 81C304000000            	add		ebx, $04
   211 00000131 E2F6                    	loop	.clrTablesLoop
   212                                  
   213                                  
   214                                  	; Since we only need to map 4M for right now, concern ourselves only with entry 0x300 and 0x000
   215                                  	; Also, map 0x00000000 to 0x003FFFFF
   216 00000133 C70500400000035000-     	mov		DWORD [MMU_PageDir+0x000], (MMU_PageTable1 | $3)
   217 0000013C 00                 
   218                                  
   219 0000013D C705004C0000036000-     	mov		DWORD [MMU_PageDir+0xC00], (MMU_PageTable2 | $3)
   220 00000146 00                 
   221 00000147 C705044C0000037000-     	mov		DWORD [MMU_PageDir+0xC04], (MMU_PageTable3 | $3)
   222 00000150 00                 
   223 00000151 C705084C0000038000-     	mov		DWORD [MMU_PageDir+0xC08], (MMU_PageTable4 | $3)
   224 0000015A 00                 
   225 0000015B C7050C4C0000039000-     	mov		DWORD [MMU_PageDir+0xC0C], (MMU_PageTable5 | $3)
   226 00000164 00                 
   227                                  
   228                                  
   229                                  	; Run a loop 1024 times to fill the first page table
   230 00000165 B900040000              	mov		ecx, $400
   231 0000016A 31DB                    	xor		ebx, ebx											; Page table offset
   232 0000016C B807000000              	mov		eax, DWORD $00000007									; Physical address start
   233                                  
   234                                  .fillPageTable1:
   235 00000171 89049D00500000          	mov		DWORD [MMU_PageTable1+ebx*4], eax					; Write physical location
   236                                  
   237 00000178 43                      	inc		ebx													; Go to next entry in page table
   238 00000179 0500100000              	add		eax, $1000											; Increment physical address
   239 0000017E E2F1                    	loop	.fillPageTable1
   240                                  
   241                                  
   242                                  	; Run a loop 8192 times to fill the second page table
   243 00000180 B900100000              	mov		ecx, $1000
   244 00000185 31DB                    	xor		ebx, ebx											; Page table offset
   245 00000187 B807001000              	mov		eax, DWORD $00100007								; Physical address start
   246                                  
   247                                  .fillPageTable2:
   248 0000018C 89049D00600000          	mov		DWORD [MMU_PageTable2+ebx*4], eax					; Write physical location
   249                                  
   250 00000193 43                      	inc		ebx													; Go to next entry in page table
   251 00000194 0500100000              	add		eax, $1000											; Increment physical address
   252 00000199 E2F1                    	loop	.fillPageTable2
   253                                  
   254                                  
   255                                  	; Set paging directory in CR3
   256 0000019B B800400000              	mov		eax, MMU_PageDir
   257 000001A0 0F22D8                  	mov		cr3, eax
   258                                  
   259                                  	; Enable paging in CR0
   260 000001A3 0F20C0                  	mov		eax, cr0
   261 000001A6 0D00000080              	or		eax, $80000000
   262 000001AB 0F22C0                  	mov		cr0, eax
   263                                  
   264                                  	; Jump into kernel
   265 000001AE E9(000000C0)            	jmp		$0C0000000
   266                                  
   267                                  	; Rest of bootloader runs in real mode, so 16-bit code
   268                                  	BITS	16
   269                                  ;========================================================================================
   270                                  ; Renders the partition chooser
   271                                  ;========================================================================================
   272                                  render_partition_chooser:
   273 000001B3 BE[7506]                	mov 	si, str_select_partition							; Put string position into SI
   274 000001B6 BA0105                  	mov		dx, $0501											; Cursor position
   275 000001B9 BF0700                  	mov		di, $07												; Set colour
   276 000001BC E84702                  	call 	print_string										; Call string printing routine
   277                                  
   278 000001BF C706[A607]0407          	mov		WORD [LastCursorPosition], 0x0704					; Read last cursor position
   279                                  
   280 000001C5 66BA[AE070000]          	mov		edx, HDD_BootablePartitions							; EDX contains bootable partition ptr
   281 000001CB B90400                  	mov		cx, $04												; Loop 4x
   282                                  
   283                                  .disp_loop:
   284 000001CE 678A02                  	mov		al, BYTE [edx]										; Read bootability
   285 000001D1 2480                    	and		al, $80												; Get high bit only
   286 000001D3 3C80                    	cmp		al, $80												; Is it $80?
   287 000001D5 7505                    	jne		.not_bootable										; If not, it's not a bootable drive
   288                                  
   289 000001D7 E81300                  	call	.render_boot										; Render bootable drive label
   290                                  
   291 000001DA EB03                    	jmp		SHORT .next											; Skip over non-bootable code
   292                                  
   293                                  .not_bootable:
   294 000001DC E87900                  	call	.render_noboot										; Render non-bootable drive label
   295                                  
   296                                  .next:
   297 000001DF 6642                    	inc		edx													; Go to next item
   298 000001E1 E2EB                    	loop	.disp_loop											; Loop over all 4 partitions
   299                                  
   300 000001E3 BA010C                  	mov		dx, $0C01
   301 000001E6 BE[0807]                	mov		si, str_err_clear_err								; Clear error
   302 000001E9 E81A02                  	call	print_string										; Display
   303                                  
   304 000001EC C3                      	ret
   305                                  
   306                                  ;========================================================================================
   307                                  ; Renders an entry for a bootable drive
   308                                  ;========================================================================================
   309                                  .render_boot:
   310 000001ED B004                    	mov		al, $04												; Max drive num to al
   311 000001EF 28C8                    	sub		al, cl												; Subtract loop counter
   312 000001F1 A2[5402]                	mov		BYTE [.index], al									; Write index
   313 000001F4 0430                    	add		al, $30												; ASCII numbers
   314                                  
   315 000001F6 66C706[E707]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   316 000001FE 2C                 
   317 000001FF A2[EB07]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   318 00000202 C706[EC07]3A20          	mov		WORD [Temp_StrBuf+5], ": "							; Colon, space
   319                                  
   320 00000208 60                      	pusha														; Push registers
   321 00000209 66BA[EE070000]          	mov		edx, Temp_StrBuf+7									; String buffer write place
   322 0000020F 66BB[B7070000]          	mov		ebx, HDD_PartitionNames								; Partition names
   323 00000215 B90C00                  	mov		cx, $0C												; $0C characters
   324                                  
   325                                  .copyNameLoop:
   326 00000218 678A03                  	mov		al, BYTE [ebx]										; Copy a character
   327 0000021B 678802                  	mov		BYTE [edx], al										; Write to temp buffer
   328 0000021E 6643                    	inc		ebx													; Increment read pointer
   329 00000220 6642                    	inc		edx													; Increment write pointer
   330 00000222 E2F4                    	loop	.copyNameLoop
   331                                  
   332 00000224 67C742FF0A00            	mov		WORD [edx-1], 0x000A								; Insert newline
   333                                  
   334 0000022A 6631C0                  	xor		eax, eax											; Clear EAX
   335 0000022D 66BA[B2070000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type matrix
   336 00000233 0216[5402]              	add		dl, BYTE [.index]
   337 00000237 678A02                  	mov		al, BYTE [edx]										; Read FAT type to AL
   338                                  
   339 0000023A 8A1E[B607]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   340 0000023E 80E303                  	and		bl, $3												; Get low 2 bits only
   341 00000241 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   342 00000243 7503                    	jne		.no_highlight										; If not, branch.
   343                                  
   344 00000245 BF7000                  	mov		di, $070											; Black text on white background
   345                                  
   346                                  .no_highlight:
   347 00000248 8B16[A607]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   348 0000024C BE[E707]                	mov		si, Temp_StrBuf										; Temporary string buffer
   349 0000024F E8B401                  	call 	print_string										; Call string printing routine
   350 00000252 61                      	popa														; Pop registers
   351                                  
   352 00000253 C3                      	ret
   353                                  
   354                                  .index:
   355 00000254 00                      	db	0
   356                                  
   357                                  ;========================================================================================
   358                                  ; Renders an entry for a non-bootable drive.
   359                                  ;========================================================================================
   360 00000255 90<rept>                	align 4
   361                                  
   362                                  .render_noboot:
   363 00000258 B004                    	mov		al, $04												; Max drive num to al
   364 0000025A 28C8                    	sub		al, cl												; Subtract loop counter
   365 0000025C 0430                    	add		al, $30												; ASCII numbers
   366                                  
   367 0000025E 66C706[E707]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   368 00000266 2C                 
   369 00000267 A2[EB07]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   370 0000026A 66C706[EC07]3A204E-     	mov		DWORD [Temp_StrBuf+5], ": No"						; "Not Bootable"
   371 00000272 6F                 
   372 00000273 66C706[F007]742042-     	mov		DWORD [Temp_StrBuf+9], "t Bo"
   373 0000027B 6F                 
   374 0000027C 66C706[F407]6F7461-     	mov		DWORD [Temp_StrBuf+13], "otab"
   375 00000284 62                 
   376 00000285 C706[F807]6C65          	mov		WORD [Temp_StrBuf+17], "le"
   377 0000028B C706[FA07]0A00          	mov		WORD [Temp_StrBuf+19], 0x000A						; Newline, terminator
   378                                  
   379 00000291 60                      	pusha														; Push registers
   380                                  
   381 00000292 8A1E[B607]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   382 00000296 80E303                  	and		bl, $3												; Get low 2 bits only
   383 00000299 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   384 0000029B 7503                    	jne		.no_highlight2										; If not, branch.
   385                                  
   386 0000029D BF7000                  	mov		di, $070											; Black text on white background
   387                                  
   388                                  .no_highlight2:
   389 000002A0 8B16[A607]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   390 000002A4 BE[E707]                	mov		si, Temp_StrBuf										; Temporary string buffer
   391 000002A7 E85C01                  	call 	print_string										; Call string printing routine
   392 000002AA 61                      	popa														; Pop registers
   393                                  
   394 000002AB C3                      	ret
   395                                  
   396                                  ;========================================================================================
   397                                  ; Handle keypresses for chooser
   398                                  ;========================================================================================
   399                                  chooser_loop:
   400 000002AC E91500                  	jmp		partition_chooser_enter
   401                                  
   402 000002AF 30E4                    	xor		ah, ah												; Wait for keystroke
   403 000002B1 CD16                    	int		$16													; Call into BIOS
   404                                  
   405 000002B3 80FC50                  	cmp		ah, $50												; Down pressed?
   406 000002B6 7459                    	je		partition_chooser_dn
   407                                  
   408 000002B8 80FC48                  	cmp		ah, $48												; Up pressed?
   409 000002BB 7463                    	je		partition_chooser_up
   410                                  
   411 000002BD 80FC1C                  	cmp		ah, $1C												; Enter pressed?
   412 000002C0 7402                    	je		partition_chooser_enter
   413                                  
   414 000002C2 EBE8                    	jmp		chooser_loop
   415                                  
   416                                  partition_chooser_enter:
   417 000002C4 31DB                    	xor		bx, bx												; Clear BX
   418 000002C6 8A1E[B607]              	mov		bl, BYTE [HDD_Selected]								; Get selection
   419                                  
   420 000002CA 8A87[AE07]              	mov		al, BYTE [HDD_BootablePartitions+bx]				; Check bootability status
   421 000002CE 2480                    	and		al, $80												; Get high bit only
   422 000002D0 3C80                    	cmp		al, $80
   423 000002D2 7527                    	jne		.noBootErr											; If not bootable, branch
   424                                  
   425                                  
   426 000002D4 BE[1C08]                	mov		si, kernel_filename									; Filename to find
   427 000002D7 E8C107                  	call	FAT_FindFileAtRoot									; Find file
   428 000002DA 722A                    	jc		.fileNotFound										; Carry set = KERNEL.BIN not found
   429                                  
   430 000002DC 66A3[1808]              	mov		DWORD [kernel_cluster], eax							; Store cluster
   431                                  
   432 000002E0 31C0                    	xor		ax, ax												; Segment 0
   433 000002E2 8EC0                    	mov		es, ax												; Write segment											
   434 000002E4 BF00A8                  	mov		di, kern_loc_phys									; Offset into segment
   435                                  
   436 000002E7 66A1[1808]              	mov		eax, DWORD [kernel_cluster]							; Kernel's cluster location
   437 000002EB E82208                  	call	FAT_ReadFile										; Read file
   438                                  
   439 000002EE BE[5A07]                	mov 	si, str_kernel_loaded_ok							; Put string position into SI
   440 000002F1 BA010C                  	mov		dx, $0C01											; Cursor position
   441 000002F4 BF0200                  	mov		di, $02												; Set colour
   442 000002F7 E80C01                  	call 	print_string										; Call string printing routine
   443                                  
   444 000002FA C3                      	ret
   445                                  
   446                                  .noBootErr:
   447 000002FB BA010C                  	mov		dx, $0C01
   448 000002FE BE[AA06]                	mov		si, str_err_not_bootable							; Not bootable error
   449 00000301 E8FC00                  	call	print_error											; Display
   450 00000304 EBA6                    	jmp		chooser_loop
   451                                  
   452                                  .fileNotFound:
   453 00000306 BA010C                  	mov		dx, $0C01
   454 00000309 BE[D406]                	mov		si, str_err_kern_not_found							; Not found error
   455 0000030C E8F100                  	call	print_error											; Display
   456 0000030F EB9B                    	jmp		chooser_loop
   457                                  
   458                                  partition_chooser_dn:
   459 00000311 A0[B607]                	mov		al, BYTE [HDD_Selected]								; Read selection
   460 00000314 FEC8                    	dec		al													; Move cursor up
   461 00000316 2403                    	and		al, $03												; Get low 2 bits only
   462 00000318 A2[B607]                	mov		BYTE [HDD_Selected], al								; Restore
   463                                  
   464 0000031B E895FE                  	call	render_partition_chooser							; Update display
   465 0000031E EB8C                    	jmp		chooser_loop
   466                                  
   467                                  partition_chooser_up:
   468 00000320 A0[B607]                	mov		al, BYTE [HDD_Selected]								; Read selection
   469 00000323 FEC0                    	inc		al													; Move cursor down
   470 00000325 2403                    	and		al, $03												; Get low 2 bits only
   471 00000327 A2[B607]                	mov		BYTE [HDD_Selected], al								; Restore
   472                                  
   473 0000032A E886FE                  	call	render_partition_chooser							; Update display
   474 0000032D E97CFF                  	jmp		chooser_loop
   475                                  
   476                                  ;========================================================================================
   477                                  ; Finds all partitions that are bootable.
   478                                  ;========================================================================================
   479                                  find_bootable_partitions:
   480 00000330 B90400                  	mov		cx, $4												; MBR contains 4 partition maps
   481                                  
   482 00000333 B8C007                  	mov		ax, $07C0											; Bootloader at 0x7C00
   483 00000336 8EC0                    	mov		es, ax												; Set ES to the bootloader's place in memory
   484 00000338 BFBE01                  	mov		di, $1BE											; Start of partition map
   485                                  
   486 0000033B 8CD8                    	mov		ax, ds												; Fetch data segment
   487 0000033D 8EE8                    	mov		gs, ax												; Set GS to data segment
   488                                  
   489 0000033F 66BE[AE070000]          	mov		esi, HDD_BootablePartitions							; ESI contains bootable partition ptr
   490 00000345 66BA[B7070000]          	mov		edx, HDD_PartitionNames								; Partition name ptr
   491                                  
   492                                  .loop:
   493 0000034B 268A05                  	mov		al, BYTE [es:di]									; Read bootable flag
   494 0000034E 2480                    	and		al, $80												; Get high bit only
   495 00000350 3C80                    	cmp		al, $80												; Is it $80?
   496 00000352 754B                    	jne		.not_bootable										; If not, it's not a bootable drive
   497                                  
   498 00000354 678806                  	mov		BYTE [esi], al										; Write bootability flag
   499                                  
   500 00000357 880E[B607]              	mov		BYTE [HDD_Selected], cl								; Write index
   501                                  
   502                                  	; Try to read the LBA of the partition
   503 0000035B 26668B4508              	mov		eax, DWORD [es:di+8]								; Read partition LBA
   504 00000360 663D00000000            	cmp		eax, $00											; Is it zero?
   505 00000366 7437                    	je		.no_valid_lba										; If so, fuck off
   506                                  
   507 00000368 66A3[1008]              	mov		DWORD [ExtendedRead_Table+0x08], eax				; Write LBA
   508 0000036C C706[0A08]0100          	mov		WORD [ExtendedRead_Table+0x02], 0x01				; Read one sector
   509 00000372 C706[0C08][E00B]        	mov		WORD [ExtendedRead_Table+0x04], SectorBuf			; Temporary sector buffer offset (seg 0)
   510                                  
   511 00000378 66A3[BC0B]              	mov		DWORD [FAT_PartitionOffset], eax					; Write offset into FAT
   512                                  
   513 0000037C 60                      	pusha														; Push registers (BIOS may clobber them)
   514 0000037D BE[0808]                	mov 	si, ExtendedRead_Table								; address of "disk address packet"
   515 00000380 B442                    	mov 	ah, $42												; Extended Read
   516 00000382 8A16[A507]              	mov		dl, BYTE [BootDevice]								; Device number
   517 00000386 CD13                    	int 	$13
   518 00000388 61                      	popa														; Pop registers
   519 00000389 7214                    	jc 		SHORT .no_valid_lba									; If error, fuck off
   520                                  
   521 0000038B E82100                  	call	.typeDetermine										; Determine type and label loc
   522                                  
   523 0000038E 51                      	push	cx													; Back up original loop counter
   524                                  
   525 0000038F B90B00                  	mov		cx, $0B												; Copy 0xB bytes
   526                                  .copy_str_loop:
   527 00000392 678A18                  	mov		bl, BYTE [eax]										; Copy from source
   528 00000395 67881A                  	mov		BYTE [edx], bl										; Write to target buffer
   529 00000398 6640                    	inc		eax													; Increment read pointer
   530 0000039A 6642                    	inc		edx													; Increment write pointer
   531 0000039C E2F4                    	loop	.copy_str_loop										; Copy all bytes.
   532                                  
   533 0000039E 59                      	pop		cx													; Restore original loop counter.
   534                                  
   535                                  .no_valid_lba:
   536                                  
   537                                  .not_bootable:
   538 0000039F 81C71000                	add		di, $10												; Go to next entry in bootsector
   539 000003A3 6646                    	inc		esi													; Write next bootability flag
   540 000003A5 6681C20C000000          	add		edx, $0C											; Each entry of partition names is 0x0C in length
   541 000003AC E29D                    	loop	.loop												; Loop through all partitions
   542                                  
   543                                  .done:
   544 000003AE C3                      	ret
   545                                  
   546                                  ; Determines FAT type and stores pointer to read volume label in eax
   547                                  .typeDetermine:
   548 000003AF 6656                    	push	esi													; Push old ESI
   549 000003B1 BE[E00B]                	mov		si, SectorBuf										; Sector buffer
   550 000003B4 E8B304                  	call	FAT_DetermineType									; Determine type of FS
   551 000003B7 665E                    	pop		esi													; Pop ESI
   552                                  
   553 000003B9 6652                    	push	edx													; Back up EDX
   554 000003BB B304                    	mov		bl, $04												; Max drive num to al
   555 000003BD 28CB                    	sub		bl, cl												; Subtract loop counter
   556                                  
   557 000003BF 66BA[B2070000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type ptr
   558 000003C5 28DA                    	sub		dl, bl												; Subtract index
   559 000003C7 678802                  	mov		BYTE [edx], al										; Write FAT size
   560 000003CA 665A                    	pop		edx													; Restore EDX
   561                                  
   562 000003CC 3C20                    	cmp		al, $20												; Is it a FAT32 volume?
   563 000003CE 7509                    	jne		.fat16_label										; If so, branch
   564                                  
   565 000003D0 66B8[270C0000]          	mov		eax, SectorBuf+$47									; FAT32 has volume label at 0x47
   566                                  
   567 000003D6 E90600                  	jmp		.copy												; Copy label
   568                                  
   569                                  	; Extract volume label from sector buffer
   570                                  .fat16_label:
   571 000003D9 66B8[0B0C0000]          	mov		eax, SectorBuf+$2B									; FAT16 has volume label at 0x2B
   572                                  
   573                                  .copy:
   574 000003DF C3                      	ret
   575                                  
   576                                  .index:
   577 000003E0 00                      	db		0
   578                                  
   579                                  ;========================================================================================
   580                                  ; Displays the memory size on the screen 
   581                                  ;========================================================================================
   582                                  display_memsize:
   583 000003E1 BE[1F06]                	mov 	si, str_available_lomem								; Put string position into SI
   584 000003E4 BA0002                  	mov		dx, $0200
   585 000003E7 E81C00                  	call 	print_string										; Call string printing routine
   586 000003EA A1[AA07]                	mov		ax, WORD [MemBlocksBelow16M]						; Get total of memory blocks to EDX
   587 000003ED E88100                  	call	hex_to_ascii
   588                                  
   589 000003F0 BE[4A06]                	mov 	si, str_available_himem								; Put string position into SI
   590 000003F3 BA0003                  	mov		dx, $0300
   591 000003F6 E80D00                  	call 	print_string										; Call string printing routine
   592 000003F9 A1[A807]                	mov		ax, WORD [MemBlocksAbove16M]						; Get total of memory blocks to EDX
   593 000003FC E87200                  	call	hex_to_ascii
   594                                  
   595 000003FF C3                      	ret
   596                                  
   597                                  ;========================================================================================
   598                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h with the styling
   599                                  ; required for an error string.
   600                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   601                                  ;========================================================================================
   602                                  print_error:
   603 00000400 BF4F00                  	mov		di, $04F											; White text on red background
   604 00000403 E90000                  	jmp 	print_string										; Call string printing routine
   605                                  
   606                                  ;========================================================================================
   607                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h.
   608                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   609                                  ;========================================================================================
   610                                  print_string:
   611 00000406 52                      	push	dx													; Push column
   612                                  
   613 00000407 85FF                    	test	di, di												; Check if DI is set
   614 00000409 7406                    	jz		.useDefaultColour									; If so, branch
   615                                  
   616 0000040B 89F8                    	mov		ax, di												; Set colour
   617 0000040D 88C3                    	mov		bl, al												; Get low byte only
   618 0000040F EB02                    	jmp		SHORT .setCursor
   619                                  
   620                                  .useDefaultColour:
   621 00000411 B307                    	mov		bl, $007											; Light gray text on black background
   622                                  
   623                                  .setCursor:
   624 00000413 B402                    	mov 	ah, $02												; Set cursor position
   625 00000415 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   626 00000417 CD10                    	int		$10													; Set cursor
   627                                  
   628                                  .repeat:
   629 00000419 AC                      	lodsb														; Get character from string
   630 0000041A 3C00                    	cmp 	al, 0
   631 0000041C 7417                    	je		.done												; If char is zero, end of string
   632                                  	
   633 0000041E 3C0A                    	cmp 	al, $0A												; Process newline
   634 00000420 741B                    	je		.newline
   635                                  
   636 00000422 B90100                  	mov		cx, $01												; Write one ASCII character
   637 00000425 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   638 00000427 B409                    	mov 	ah, $09												; Write character
   639 00000429 CD10                    	int		$10													; Print character
   640                                  
   641 0000042B B402                    	mov 	ah, $02												; Set cursor position
   642 0000042D 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   643 0000042F FEC2                    	inc		dl													; Increment column
   644 00000431 CD10                    	int		$10													; Set cursor
   645                                  
   646 00000433 EBE4                    	jmp		.repeat
   647                                  
   648                                  .done:
   649 00000435 8916[A607]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   650 00000439 5A                      	pop		dx													; Pop position
   651 0000043A 31FF                    	xor		di, di												; Clear colour
   652 0000043C C3                      	ret
   653                                  
   654                                  .newline:
   655 0000043D 5A                      	pop		dx													; Get original column
   656 0000043E FEC6                    	inc		dh													; Increment row
   657 00000440 52                      	push	dx													; Push it back to stack
   658 00000441 EBD6                    	jmp		.repeat
   659                                  
   660                                  ;========================================================================================
   661                                  ; Prints the character in al to the screen at the current cursor position, using the
   662                                  ; colour in di.
   663                                  ;========================================================================================
   664                                  putc:
   665 00000443 85FF                    	test	di, di												; Check if DI is set
   666 00000445 7406                    	jz		.useDefaultColour									; If so, branch
   667                                  
   668 00000447 89F8                    	mov		ax, di												; Set colour
   669 00000449 88C3                    	mov		bl, al												; Get low byte only
   670 0000044B EB02                    	jmp		SHORT .setCursor
   671                                  
   672                                  .useDefaultColour:
   673 0000044D B307                    	mov		bl, $007											; Light gray text on black background
   674                                  
   675                                  .setCursor:
   676 0000044F 8B16[A607]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   677 00000453 B402                    	mov 	ah, $02												; Set cursor position
   678 00000455 B700                    	mov		bh, $0												; Video page 0
   679 00000457 CD10                    	int		$10													; Set cursor
   680                                  
   681 00000459 B90100                  	mov		cx, $01												; Write one ASCII character
   682 0000045C B700                    	mov		bh, $0												; Video page 0
   683 0000045E B409                    	mov 	ah, $09												; Write character
   684 00000460 CD10                    	int		$10													; Print character
   685                                  
   686 00000462 FEC2                    	inc		dl													; Increment column
   687                                  
   688 00000464 B402                    	mov 	ah, $02												; Set cursor position
   689 00000466 B700                    	mov		bh, $0												; Video page 0
   690 00000468 CD10                    	int		$10													; Set cursor
   691                                  
   692 0000046A 8916[A607]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   693 0000046E 31FF                    	xor		di, di												; Clear colour
   694 00000470 C3                      	ret
   695                                  
   696                                  ;========================================================================================
   697                                  ; Prints the value in eax to the screen.
   698                                  ;========================================================================================
   699                                  hex_to_ascii:
   700 00000471 31C9                    	xor 	cx, cx
   701                                  
   702 00000473 88E1                    	mov 	cl, ah												; Move high byte of ax to cl
   703 00000475 E81000                  	call 	.nibble_high										; Print low nibble to ASCII
   704 00000478 88E1                    	mov 	cl, ah
   705 0000047A E81100                  	call 	.nibble_low
   706 0000047D 88C1                    	mov 	cl, al
   707 0000047F E80600                  	call 	.nibble_high
   708 00000482 88C1                    	mov 	cl, al
   709 00000484 E80700                  	call 	.nibble_low
   710 00000487 C3                      	ret
   711                                  
   712                                  .nibble_high:
   713 00000488 C0E904                  	shr 	cl, $04
   714 0000048B E90600                  	jmp 	.convert_check
   715                                  
   716                                  .nibble_low:
   717 0000048E 80E10F                  	and 	cl, $0F
   718 00000491 E90000                  	jmp 	.convert_check
   719                                  
   720                                  .convert_check:
   721 00000494 80F90A                  	cmp 	cl, $0A
   722 00000497 7D0B                    	jge 	.letter
   723 00000499 80C130                  	add 	cl, $30
   724 0000049C 50                      	push 	ax
   725 0000049D 88C8                    	mov 	al, cl
   726 0000049F E8A1FF                  	call 	putc
   727 000004A2 58                      	pop 	ax
   728 000004A3 C3                      	ret
   729                                  
   730                                  .letter:
   731 000004A4 80C137                  	add 	cl, $37
   732 000004A7 50                      	push	ax
   733 000004A8 88C8                    	mov 	al, cl
   734 000004AA E896FF                  	call	putc
   735 000004AD 58                      	pop 	ax
   736 000004AE C3                      	ret
   737                                  
   738                                  ;========================================================================================
   739                                  ; Uses BIOS INT $15, EAX $E820 function to get the memory map of the system
   740                                  ; input: 	es:di = destination buffer for 24 byte entries
   741                                  ; output: 	bp = entry count, trashes all registers except esi
   742                                  ;========================================================================================
   743                                  fetch_mem_map:
   744 000004AF 6631DB                  	xor		ebx, ebx											; Clear EBX
   745 000004B2 31ED                    	xor		bp, bp												; Use BP as an entry count
   746 000004B4 66BA50414D53            	mov		edx, $0534D4150										; Place "SMAP" into edx (magic value)
   747 000004BA 66B820E80000            	mov		eax, $0E820											; Function call
   748                                  
   749 000004C0 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   750 000004C9 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   751 000004CF CD15                    	int		$15
   752                                  
   753 000004D1 7257                    	jc		SHORT .error										; If carry set, the function is unsupported
   754                                  
   755 000004D3 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   756 000004D9 6639D0                  	cmp		eax, edx											; On success, EAX = "SMAP"
   757 000004DC 754C                    	jne		SHORT .error
   758                                  
   759 000004DE 6685DB                  	test	ebx, ebx											; ebx = 0 implies list is only 1 entry long (worthless)
   760 000004E1 7447                    	je		SHORT .error
   761                                  
   762 000004E3 EB1F                    	jmp		SHORT .startLoop									; Jump into the loop
   763                                  
   764                                  .getEntryLoop:
   765 000004E5 66B820E80000            	mov		eax, $0E820											; Reset command (EAX, ECX are trashed)
   766 000004EB 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   767 000004F4 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   768 000004FA CD15                    	int		$15
   769                                  
   770 000004FC 722A                    	jc		SHORT .done											; If carry set, we are done
   771 000004FE 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   772                                  
   773                                  .startLoop:
   774 00000504 E31D                    	jcxz	.skipEntry											; Skip any 0 length entries
   775                                  
   776 00000506 80F914                  	cmp		cl, 20												; Did we get 24-byte ACPI 3.x data?
   777 00000509 7607                    	jbe		SHORT .notext
   778                                  
   779 0000050B 26F6451401              	test	BYTE [es:di+20], 1									; If so, is the "ignore this data" bit clear?
   780 00000510 7411                    	je		SHORT .skipEntry
   781                                  
   782                                  .notext:
   783 00000512 26668B4D08              	mov		ecx, [es:di+8]										; get lower dword of memory region length
   784 00000517 26660B4D0C              	or		ecx, [es:di+12]										; Check if zero (OR with upper dword)
   785 0000051C 7405                    	jz		.skipEntry											; If length qword is 0, skip entry
   786                                  
   787 0000051E 45                      	inc		bp													; We got a good entry, increment count, go to next entry
   788                                  
   789 0000051F 81C71800                	add		di, 24
   790                                  
   791                                  .skipEntry:
   792 00000523 6685DB                  	test	ebx, ebx											; If EBX = 0, then the BIOS has given us all entries
   793 00000526 75BD                    	jne		SHORT .getEntryLoop
   794                                  
   795                                  .done:
   796 00000528 F8                      	clc															; There is "jc" on end of list to this point, so the carry must be cleared
   797 00000529 C3                      	ret
   798                                  
   799                                  .error:
   800 0000052A F9                      	stc															; Set carry if this BIOS sucks ass and doesn't support this
   801 0000052B C3                      	ret
   802                                  
   803                                  ;========================================================================================
   804                                  ; Writes a register dump to the VGA hardware
   805                                  ;========================================================================================
   806                                  VGA_MISC_WRITE		EQU	$3C2
   807                                  VGA_SEQ_INDEX		EQU	$3C4
   808                                  VGA_SEQ_DATA		EQU	$3C5
   809                                  VGA_CRTC_INDEX		EQU	$3D4
   810                                  VGA_CRTC_DATA		EQU	$3D5
   811                                  VGA_INSTAT_READ		EQU	$3DA
   812                                  
   813                                  NUM_SEQ_REGS		EQU	5
   814                                  NUM_CRTC_REGS		EQU	25
   815                                  
   816                                  write_regs:
   817 0000052C 56                      	push 	si
   818 0000052D 52                      	push 	dx
   819 0000052E 51                      	push 	cx
   820 0000052F 50                      	push 	ax
   821 00000530 FC                      	cld
   822                                  
   823                                  ; write MISC register
   824 00000531 BAC203                  	mov 	dx, VGA_MISC_WRITE
   825 00000534 AC                      	lodsb
   826 00000535 EE                      	out 	dx, al
   827                                  
   828                                  ; write SEQuencer registers
   829 00000536 B90500                  	mov 	cx, NUM_SEQ_REGS
   830 00000539 30E4                    	xor 	ah, ah
   831                                  
   832                                  write_seq:
   833 0000053B BAC403                  	mov 	dx, VGA_SEQ_INDEX
   834 0000053E 88E0                    	mov 	al, ah
   835 00000540 EE                      	out 	dx, al
   836                                  
   837 00000541 BAC503                  	mov 	dx, VGA_SEQ_DATA
   838 00000544 AC                      	lodsb
   839 00000545 EE                      	out 	dx, al
   840                                  
   841 00000546 FEC4                    	inc 	ah
   842 00000548 E2F1                    	loop 	write_seq
   843                                  
   844                                  ; write CRTC registers
   845                                  ; Unlock CRTC registers: enable writes to CRTC regs 0-7
   846 0000054A BAD403                  	mov 	dx, VGA_CRTC_INDEX
   847 0000054D B011                    	mov 	al, 17
   848 0000054F EE                      	out 	dx, al
   849                                  
   850 00000550 BAD503                  	mov 	dx, VGA_CRTC_DATA
   851 00000553 EC                      	in		al, dx
   852 00000554 247F                    	and 	al, $7F
   853 00000556 EE                      	out 	dx, al
   854                                  
   855                                  ; Unlock CRTC registers: enable access to vertical retrace regs
   856 00000557 BAD403                  	mov 	dx, VGA_CRTC_INDEX
   857 0000055A B003                    	mov 	al, 3
   858 0000055C EE                      	out 	dx, al
   859                                  
   860 0000055D BAD503                  	mov 	dx ,VGA_CRTC_DATA
   861 00000560 EC                      	in		al, dx
   862 00000561 0C80                    	or		al, $80
   863 00000563 EE                      	out		dx, al
   864                                  
   865                                  ; make sure CRTC registers remain unlocked
   866 00000564 8A4411                  	mov		al,[si + 17]
   867 00000567 247F                    	and 	al, $7F
   868 00000569 884411                  	mov 	[si + 17],al
   869                                  
   870 0000056C 8A4403                  	mov 	al,[si + 3]
   871 0000056F 0C80                    	or		al, $80
   872 00000571 884403                  	mov 	[si + 3], al
   873                                  
   874                                  ; now, finally, write them
   875 00000574 B91900                  	mov 	cx, NUM_CRTC_REGS
   876 00000577 B400                    	mov 	ah, 0
   877                                  
   878                                  write_crtc:
   879 00000579 BAD403                  	mov 	dx, VGA_CRTC_INDEX
   880 0000057C 88E0                    	mov 	al, ah
   881 0000057E EE                      	out 	dx, al
   882                                  
   883 0000057F BAD503                  	mov 	dx, VGA_CRTC_DATA
   884 00000582 AC                      	lodsb
   885 00000583 EE                      	out 	dx, al
   886                                  
   887 00000584 FEC4                    	inc 	ah
   888 00000586 E2F1                    	loop write_crtc
   889                                  
   890 00000588 58                      	pop 	ax
   891 00000589 59                      	pop 	cx
   892 0000058A 5A                      	pop 	dx
   893 0000058B 5E                      	pop 	si
   894 0000058C C3                      	ret
   895                                  
   896                                  ;	align	32
   897                                  ;fat_loader_entry:
   898                                  ;	incbin		"./loader_c.bin"
   899                                  
   900                                  ;========================================================================================
   901                                  ; DATA SECTION
   902                                  ;========================================================================================
   903                                  regs_90x60:
   904                                  ; MISC
   905 0000058D E7                      	db	0E7h
   906                                  ; SEQuencer
   907 0000058E 0301030002              	db	03h, 01h, 03h, 00h, 02h
   908                                  ; CRTC
   909 00000593 6B595A82608D0B3E        	db	6Bh, 59h,  5Ah, 82h, 60h,  8Dh, 0Bh,  3Eh,
   910 0000059B 0047060700000000        	db	00h, 47h,  06h, 07h, 00h,  00h, 00h,  00h,
   911 000005A3 EA0CDF2D08E805A3        	db	0EAh, 0Ch, 0DFh, 2Dh, 08h, 0E8h, 05h, 0A3h,
   912 000005AB FF                      	db 	0FFh
   913                                  ; GC (no)
   914                                  ; AC (no)
   915                                  
   916                                  str_stage2loaded:
   917 000005AC 537461676520322042-     	db 	'Stage 2 Bootloader (boot2)', 0
   918 000005B5 6F6F746C6F61646572-
   919 000005BE 2028626F6F74322900 
   920                                  
   921                                  str_errorDetectMem:
   922 000005C7 4572726F7220646574-     	db 	"Error detecting available memory, cannot continue", 0
   923 000005D0 656374696E67206176-
   924 000005D9 61696C61626C65206D-
   925 000005E2 656D6F72792C206361-
   926 000005EB 6E6E6F7420636F6E74-
   927 000005F4 696E756500         
   928                                  
   929                                  str_floppyError:
   930 000005F9 466C6F707079204572-     	db 	"Floppy Error, press any key to retry", $0A, 0
   931 00000602 726F722C2070726573-
   932 0000060B 7320616E79206B6579-
   933 00000614 20746F207265747279-
   934 0000061D 0A00               
   935                                  
   936                                  str_available_lomem:
   937 0000061F 436F6E74696E756F75-     	db 	"Continuous 01K blocks below 0x01000000: 0x", 0
   938 00000628 732030314B20626C6F-
   939 00000631 636B732062656C6F77-
   940 0000063A 203078303130303030-
   941 00000643 30303A20307800     
   942                                  
   943                                  str_available_himem:
   944 0000064A 436F6E74696E756F75-     	db 	"Continuous 64K blocks above 0x01000000: 0x", 0
   945 00000653 732036344B20626C6F-
   946 0000065C 636B732061626F7665-
   947 00000665 203078303130303030-
   948 0000066E 30303A20307800     
   949                                  
   950                                  str_select_partition:
   951 00000675 557365207468652063-     	db 	"Use the cursor to select the partition to boot from.", 0
   952 0000067E 7572736F7220746F20-
   953 00000687 73656C656374207468-
   954 00000690 652070617274697469-
   955 00000699 6F6E20746F20626F6F-
   956 000006A2 742066726F6D2E00   
   957                                  
   958                                  str_err_not_bootable:
   959 000006AA 546869732070617274-     	db 	"This partition is not marked as bootable!", 0
   960 000006B3 6974696F6E20697320-
   961 000006BC 6E6F74206D61726B65-
   962 000006C5 6420617320626F6F74-
   963 000006CE 61626C652100       
   964                                  
   965                                  str_err_kern_not_found:
   966 000006D4 436F756C64206E6F74-     	db	"Could not find KERNEL.BIN at the root of the drive!", 0
   967 000006DD 2066696E64204B4552-
   968 000006E6 4E454C2E42494E2061-
   969 000006EF 742074686520726F6F-
   970 000006F8 74206F662074686520-
   971 00000701 64726976652100     
   972                                  
   973                                  str_err_clear_err:
   974 00000708 20<rept>                	times	0x40 db 0x20
   975 00000748 00                      	db	0
   976                                  
   977                                  
   978                                  str_kernel_loading:
   979 00000749 4C6F6164696E67206B-     	db 	"Loading kernel: ", 0
   980 00000752 65726E656C3A2000   
   981                                  
   982                                  str_kernel_loaded_ok:
   983 0000075A 4B65726E656C206C6F-     	db 	"Kernel loaded. Transferring control now...", 0
   984 00000763 616465642E20547261-
   985 0000076C 6E7366657272696E67-
   986 00000775 20636F6E74726F6C20-
   987 0000077E 6E6F772E2E2E00     
   988                                  
   989                                  str_err_loadkernel:
   990 00000785 436F756C64206E6F74-     	db 	"Could not load kernel: Fuck you", 0
   991 0000078E 206C6F6164206B6572-
   992 00000797 6E656C3A204675636B-
   993 000007A0 20796F7500         
   994                                  
   995                                  BootDevice:
   996 000007A5 00                      	db	0
   997                                  
   998                                  LastCursorPosition:
   999 000007A6 0000                    	dw	0
  1000                                  
  1001                                  MemBlocksAbove16M:
  1002 000007A8 0000                    	dw	0
  1003                                  
  1004                                  MemBlocksBelow16M:
  1005 000007AA 0000                    	dw	0
  1006                                  
  1007                                  MemMap_NumEntries:
  1008 000007AC 0000                    	dw	0
  1009                                  
  1010                                  HDD_BootablePartitions:
  1011 000007AE 00000000                	dd	0
  1012                                  
  1013                                  HDD_BootablePartitionsFATType:
  1014 000007B2 00000000                	dd	0
  1015                                  
  1016                                  HDD_Selected:
  1017 000007B6 00                      	db	0
  1018                                  
  1019                                  HDD_PartitionNames:
  1020 000007B7 00<rept>                	times	(0xB+1)*4 db 0
  1021                                  
  1022                                  Temp_StrBuf:
  1023 000007E7 00<rept>                	times	0x20 db 0
  1024                                  
  1025 00000807 90                      	align 2
  1026                                  ExtendedRead_Table:
  1027 00000808 10                      	db	$10
  1028 00000809 00                      	db	0
  1029 0000080A 0000                    	dw	0														; Num blocks
  1030 0000080C 0000                    	dw	0														; Dest
  1031 0000080E 0000                    	dw	0														; Memory page
  1032 00000810 00000000                	dd	0														; Starting LBA
  1033 00000814 00000000                	dd	0	
  1034                                  
  1035                                  kernel_cluster:
  1036 00000818 00000000                	dd	0
  1037                                  
  1038                                  kernel_filename:
  1039 0000081C 4B45524E454C202042-     	db	"KERNEL  BIN", 0
  1040 00000825 494E00             
  1041                                  
  1042                                  ;========================================================================================
  1043                                  ; Global Descriptor Table
  1044                                  ;========================================================================================
  1045 00000828 90<rept>                	align	$10
  1046                                  
  1047                                  gdt_start:
  1048 00000830 0000000000000000        	dd	$00, $00												; Null Descriptor
  1049                                  
  1050                                  	; Code segment
  1051 00000838 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
  1052 0000083A 0000                    	dw	$0000													; Base 0:15 = $0000
  1053 0000083C 00                      	db	$00														; Base 16:23 = $00
  1054 0000083D 9A                      	db	$9A														; Access byte: Present, ring 0, Exec, grow up, R/W
  1055 0000083E CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
  1056 0000083F 00                      	db	$00														; Base 24:31 = $00
  1057                                  
  1058                                  	; Data segment
  1059 00000840 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
  1060 00000842 0000                    	dw	$0000													; Base 0:15 = $0000
  1061 00000844 00                      	db	$00														; Base 16:23 = $00
  1062 00000845 92                      	db	$92														; Access byte: Present, ring 0, Not exec, grow up, R/W
  1063 00000846 CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
  1064 00000847 00                      	db	$00														; Base 24:31 = $00	
  1065                                  
  1066                                  gdt_table:
  1067 00000848 1700                    	dw	(gdt_table-gdt_start)-1									; Length
  1068 0000084A [30080000]              	dd	gdt_start												; Physical address to GDT	
  1069                                  
  1070 0000084E 90<rept>                	align 4														; DWORD align
  1071                                  	%include	"./fat.asm"
  1072                              <1> ;========================================================================================
  1073                              <1> ; FAT Filesystem Library v 0.1
  1074                              <1> ; By Tristan Seifert
  1075                              <1> ;
  1076                              <1> ; All sector values returned by functions are "logical," i.e. they are relative to the
  1077                              <1> ; first sector of the filesystem.
  1078                              <1> ;
  1079                              <1> ; In addition, this library does not offer full support for FAT12 due to the uncommonality
  1080                              <1> ; of it on media besides floppy disks.
  1081                              <1> ;========================================================================================
  1082                              <1> ; Equates
  1083                              <1> ;========================================================================================
  1084                              <1> 
  1085                              <1> ;========================================================================================
  1086                              <1> ; Initialises the FAT filesystem library
  1087                              <1> ;========================================================================================
  1088                              <1> FAT_Init:
  1089 00000850 B90001              <1> 	mov		cx, (1024/4)										; Clear 2 sectors worth
  1090 00000853 66BA[E00B0000]      <1> 	mov		edx, FAT_ReadBuffer									; Pointer to buffer
  1091 00000859 6631C0              <1> 	xor		eax, eax											; Clear value ($00000000)
  1092                              <1> 
  1093                              <1> .clearLoop:
  1094 0000085C 66678902            <1> 	mov		DWORD [edx], eax									; Clear a DWORD
  1095 00000860 6681C204000000      <1> 	add		edx, $04											; Increment pointer
  1096 00000867 E2F3                <1> 	loop	.clearLoop											; Loop
  1097                              <1> 
  1098                              <1> .done:
  1099 00000869 C3                  <1> 	ret
  1100                              <1>  
  1101                              <1> ;========================================================================================
  1102                              <1> ; Determines the type of FAT, give that the first logical sector of the partition is
  1103                              <1> ; pointed to by SI, and returns the FAT bit size in AL.
  1104                              <1> ;
  1105                              <1> ; This is how Microsoft recommends we determine FAT type:
  1106                              <1> ;
  1107                              <1> ; RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytesPerSec - 1)) / BPB_BytesPerSec
  1108                              <1> ; DataSectors = Total Sectors - (BPB_ReservedSectors + (BPB_NumFATs * FATSz) + RootDirSectors)
  1109                              <1> ; Count of clusters = DataSectors/BPB_SectorsPerCluster 
  1110                              <1> ;
  1111                              <1> ; FAT12: Total clusters < 4085
  1112                              <1> ; FAT16: Total clusters > 4085 && < 65525
  1113                              <1> ; FAT32: Total clusters > 65525
  1114                              <1> ;========================================================================================
  1115                              <1> FAT_DetermineType:
  1116 0000086A 60                  <1> 	pusha														; Push registers
  1117                              <1> 
  1118 0000086B E8EF00              <1> 	call	FAT_ReadBPB											; 
  1119                              <1> 
  1120                              <1> 	; Calculate RootDirSectors
  1121 0000086E 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1122 00000871 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1123 00000874 8B1E[9E0B]          <1> 	mov		bx,	WORD [FAT_BPB_RootEntCnt]						; Read root entries 
  1124 00000878 66C1E305            <1> 	shl		ebx, 5												; Each root entry is 32 bytes
  1125                              <1> 
  1126 0000087C A1[8C0B]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1127 0000087F 48                  <1> 	dec		ax													; Subtract one
  1128 00000880 6601D8              <1> 	add		eax, ebx											; Add root entry length to sector length
  1129                              <1> 
  1130 00000883 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1131 00000886 8B0E[8C0B]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1132 0000088A F7F1                <1> 	div		cx													; Divide by sector length (result = ax)
  1133 0000088C A3[A80B]            <1> 	mov		WORD [FAT_RootDirSectors], ax						; Store result in memory
  1134                              <1> 
  1135                              <1> 	; Calculate number of data sectors
  1136 0000088F 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1137 00000892 A0[9C0B]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1138                              <1> 
  1139 00000895 668B0E[A00B]        <1> 	mov		ecx, DWORD [FAT_BPB_FATSz]							; Read FAT size
  1140 0000089A 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in eax
  1141                              <1> 
  1142 0000089D 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1143 000008A0 8B0E[9A0B]          <1> 	mov		cx, WORD [FAT_BPB_ReservedSectors]					; Read number of reserved sectors
  1144                              <1> 
  1145 000008A4 6601C8              <1> 	add		eax, ecx											; Add count of reserved sectors to FAT size
  1146 000008A7 668B0E[A80B]        <1> 	mov		ecx, DWORD [FAT_RootDirSectors]						; Read RootDirSectors
  1147 000008AC 6601C8              <1> 	add		eax, ecx											; Add root directory sectors
  1148                              <1> 
  1149 000008AF 6691                <1> 	xchg	eax, ecx											; Subtract all of the above from total sectors
  1150                              <1> 
  1151 000008B1 66A1[A40B]          <1> 	mov		eax, DWORD [FAT_BPB_TotSec]							; Read total sector count
  1152 000008B5 6629C8              <1> 	sub		eax, ecx											; Subtract from total sector count
  1153                              <1> 
  1154 000008B8 66A3[AC0B]          <1> 	mov		DWORD [FAT_DataSectors], eax						; Store to memory
  1155                              <1> 
  1156                              <1> 	; Calculate cluster count
  1157 000008BC 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1158 000008BF 8A1E[980B]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1159 000008C3 66A1[AC0B]          <1> 	mov		eax, DWORD [FAT_DataSectors]						; Read number of data sectors
  1160 000008C7 66F7F3              <1> 	div		ebx													; Divide by sectors/cluster value 
  1161                              <1> 
  1162 000008CA 66A3[B80B]          <1> 	mov		DWORD [FAT_TotalClusters], eax						; Store result in EAX
  1163                              <1> 
  1164                              <1> 	; Now, do some comparisons!
  1165 000008CE 663DF50F0000        <1> 	cmp		eax, 4085											; Is the FS FAT12?
  1166 000008D4 7F07                <1> 	jg		.notFAT12											; If not, branch
  1167                              <1> 
  1168 000008D6 C606[C00B]0C        <1> 	mov		BYTE [FAT_Type], 12									; FAT12
  1169 000008DB EB17                <1> 	jmp		SHORT .done											; Return
  1170                              <1> 
  1171                              <1> .notFAT12:
  1172 000008DD 663DF5FF0000        <1> 	cmp		eax, 65525											; Is the FS FAT16?
  1173 000008E3 7F0A                <1> 	jg		.notFAT16											; If not, branch
  1174                              <1> 
  1175 000008E5 E84C00              <1> 	call	FAT16_Calculate_RootDirSec							; Calculate location of root directory
  1176                              <1> 
  1177 000008E8 C606[C00B]10        <1> 	mov		BYTE [FAT_Type], 16									; FAT16
  1178 000008ED EB05                <1> 	jmp		SHORT .done											; Return
  1179                              <1> 
  1180                              <1> .notFAT16:
  1181                              <1> 	; Okay, if we get down here, it HAS to be FAT32 or a corrupt FS
  1182 000008EF C606[C00B]20        <1> 	mov		BYTE [FAT_Type], 32									; FAT32
  1183                              <1> 
  1184                              <1> .done:
  1185 000008F4 E80500              <1> 	call	FAT_Calculate_Misc									; Calculate miscellaneous stuff
  1186 000008F7 61                  <1> 	popa														; Restore registers
  1187                              <1> 
  1188 000008F8 A0[C00B]            <1> 	mov		al, BYTE [FAT_Type]									; Store FAT type in AL
  1189                              <1> 
  1190 000008FB C3                  <1> 	ret
  1191                              <1> 
  1192                              <1> ;========================================================================================
  1193                              <1> ; Calculates miscellaneous values that the FAT driver uses later
  1194                              <1> ;========================================================================================
  1195                              <1> FAT_Calculate_Misc:
  1196 000008FC 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1197 000008FF 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1198 00000902 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1199                              <1> 
  1200 00000905 8B0E[A80B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1201 00000909 8B1E[9A0B]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1202                              <1> 
  1203 0000090D 6601CB              <1> 	add		ebx, ecx											; Add to root dir sectors reserved sectors
  1204                              <1> 
  1205 00000910 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1206 00000913 8A0E[9C0B]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1207 00000917 66A1[A00B]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1208 0000091B 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1209                              <1> 
  1210 0000091E 6601D8              <1> 	add		eax, ebx											; Add FAT sectors to root dir and reserved count
  1211                              <1> 
  1212 00000921 66A3[B00B]          <1> 	mov		DWORD [FAT_FirstDataSector], eax					; Store first data sector
  1213                              <1> 
  1214 00000925 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1215 00000928 8B0E[A80B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1216 0000092C 6629C8              <1> 	sub		eax, ecx											; Subtract ecx
  1217 0000092F 66A3[B40B]          <1> 	mov		DWORD [FAT_FirstClusterLocation], eax				; Write shaften
  1218 00000933 C3                  <1> 	ret
  1219                              <1> 
  1220                              <1> ;========================================================================================
  1221                              <1> ; Calculates the sector for the root directory for FAT12 and FAT16.
  1222                              <1> ;========================================================================================
  1223                              <1> FAT16_Calculate_RootDirSec:
  1224 00000934 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1225 00000937 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1226 0000093A 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1227                              <1> 
  1228 0000093D 8B1E[9A0B]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1229                              <1> 
  1230 00000941 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1231 00000944 A0[9C0B]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1232                              <1> 
  1233 00000947 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1234 0000094A 8A0E[9C0B]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1235 0000094E 66A1[A00B]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1236 00000952 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1237                              <1> 
  1238 00000955 6601D8              <1> 	add		eax, ebx											; Add reserved sector count
  1239                              <1> 
  1240 00000958 66A3[940B]          <1> 	mov		DWORD [FAT_BPB_RootClus], eax						; Write location of root cluster
  1241                              <1> 
  1242                              <1> .done:
  1243 0000095C C3                  <1> 	ret
  1244                              <1> 
  1245                              <1> ;========================================================================================
  1246                              <1> ; Reads the BPB from the FAT 1st sector in SI.
  1247                              <1> ;========================================================================================
  1248                              <1> FAT_ReadBPB:
  1249 0000095D 8B440B              <1> 	mov		ax, WORD [si+11]									; Read Bytes/sector
  1250 00000960 A3[8C0B]            <1> 	mov		WORD [FAT_BPB_BytesPerSec], ax						; ""
  1251                              <1> 
  1252 00000963 8A440D              <1> 	mov		al, BYTE [si+13]									; Read sectors/cluster
  1253 00000966 A2[980B]            <1> 	mov		BYTE [FAT_BPB_SectorsPerCluster], al				; ""
  1254                              <1> 
  1255 00000969 8B440E              <1> 	mov		ax, WORD [si+14]									; Read reserved sectors
  1256 0000096C A3[9A0B]            <1> 	mov		WORD [FAT_BPB_ReservedSectors], ax					; ""
  1257                              <1> 
  1258 0000096F 8A4410              <1> 	mov		al, BYTE [si+16]									; Read number of FATs
  1259 00000972 A2[9C0B]            <1> 	mov		BYTE [FAT_BPB_NumFATs], al							; ""
  1260                              <1> 
  1261 00000975 8B4411              <1> 	mov		ax, WORD [si+17]									; Read num root entries
  1262 00000978 A3[9E0B]            <1> 	mov		WORD [FAT_BPB_RootEntCnt], ax						; ""
  1263                              <1> 
  1264 0000097B 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1265                              <1> 
  1266 0000097E 668B4420            <1> 	mov		eax, DWORD [si+32]									; Read BPB_TotSec32 first
  1267 00000982 663D00000000        <1> 	cmp		eax, 0												; Is EAX zero?
  1268 00000988 7503                <1> 	jne		.writeTotSec										; If not, branch
  1269                              <1> 
  1270 0000098A 8B4413              <1> 	mov		ax, WORD [si+19]									; Read BPB_TotSec16 first
  1271                              <1> 
  1272                              <1> .writeTotSec:
  1273 0000098D 66A3[A40B]          <1> 	mov		DWORD [FAT_BPB_TotSec], eax							; ""
  1274                              <1> 
  1275 00000991 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1276                              <1> 
  1277 00000994 8B4416              <1> 	mov		ax, WORD [si+22]									; Read BPB_FATSz16
  1278 00000997 3D0000              <1> 	cmp		ax, 0												; Is it zero?
  1279 0000099A 7507                <1> 	jne		.writeFATSz											; If not, branch.
  1280                              <1> 
  1281 0000099C 668B4424            <1> 	mov		eax, DWORD [si+36]									; Read BPB_FATSz32
  1282                              <1> 
  1283 000009A0 E80500              <1> 	call	.readFAT32Specifics									; Read FAT32-specific data
  1284                              <1> 
  1285                              <1> .writeFATSz:
  1286 000009A3 66A3[A00B]          <1> 	mov		DWORD [FAT_BPB_FATSz], eax							; Write FAT size
  1287                              <1> 
  1288 000009A7 C3                  <1> 	ret
  1289                              <1> 
  1290                              <1> ; All FAT32-specific stuff is read here
  1291                              <1> .readFAT32Specifics:
  1292 000009A8 8B5C28              <1> 	mov		bx, WORD [si+40]									; Read BPB_ExtFlags
  1293 000009AB 891E[900B]          <1> 	mov		WORD [FAT_BPB_ExtFlags], bx							; Write BPB_ExtFlags
  1294                              <1> 
  1295 000009AF 8B5C2A              <1> 	mov		bx, WORD [si+42]									; Read BPB_FSVer
  1296 000009B2 891E[920B]          <1> 	mov		WORD [FAT_BPB_FSVer], bx							; Write BPB_FSVer
  1297                              <1> 
  1298 000009B6 668B5C2C            <1> 	mov		ebx, DWORD [si+44]									; Read BPB_RootClus
  1299 000009BA 66891E[940B]        <1> 	mov		DWORD [FAT_BPB_RootClus], ebx						; Write BPB_RootClus
  1300                              <1> 
  1301 000009BF 8B5C30              <1> 	mov		bx, WORD [si+48]									; Read BPB_FSInfo
  1302 000009C2 891E[8E0B]          <1> 	mov		WORD [FAT_BPB_FSInfo], bx							; Write BPB_FSInfo
  1303                              <1> 
  1304                              <1> 
  1305 000009C6 C3                  <1> 	ret
  1306                              <1> 
  1307                              <1> ;========================================================================================
  1308                              <1> ; Calculates the entry location for cluster N in the FAT.
  1309                              <1> ; eax: Cluster number
  1310                              <1> ; eax: Sector number containing the cluster
  1311                              <1> ; ebx: Offset in sector
  1312                              <1> ;========================================================================================
  1313                              <1> FAT_FindClusterInTable:
  1314 000009C7 60                  <1> 	pusha														; Back up regs
  1315                              <1> 
  1316 000009C8 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1317 000009CB 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1318                              <1> 
  1319 000009CE 8A1E[C00B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1320 000009D2 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1321 000009D5 7406                <1> 	je		.FAT32												; If so, jump
  1322                              <1> 
  1323 000009D7 66D1E0              <1> 	shl		eax, 1												; Multiply cluster by 2
  1324 000009DA E90400              <1> 	jmp		.cont												; Skip over shift below
  1325                              <1> 
  1326                              <1> .FAT32:
  1327 000009DD 66C1E002            <1> 	shl		eax, 2												; Multiply cluster by 4
  1328                              <1> 
  1329                              <1> .cont:
  1330                              <1> 	; eax = Offset into FAT table
  1331                              <1> 
  1332 000009E1 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1333 000009E4 8B0E[8C0B]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1334 000009E8 66F7F1              <1> 	div		ecx													; Divide offset by bytes/sector
  1335                              <1> 	; eax = quotient, edx = remainder
  1336                              <1> 
  1337 000009EB 8B1E[9A0B]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; BX = reserved sector count
  1338 000009EF 6601D8              <1> 	add		eax, ebx											; Add to FAT offset (sectors)
  1339                              <1> 
  1340 000009F2 66A3[070A]          <1> 	mov		DWORD [.secNum], eax								; Store sector number
  1341 000009F6 8916[0B0A]          <1> 	mov		WORD [.secOff], dx									; Store offset into sector
  1342                              <1> 
  1343                              <1> .done:
  1344 000009FA 61                  <1> 	popa														; Restore regs
  1345                              <1> 
  1346 000009FB 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1347 000009FE 66A1[070A]          <1> 	mov		eax, DWORD [.secNum]								; Get sector number
  1348 00000A02 8B1E[0B0A]          <1> 	mov		bx, WORD [.secOff]									; Get offset into sector
  1349                              <1> 
  1350 00000A06 C3                  <1> 	ret
  1351                              <1> 
  1352                              <1> .secNum:
  1353 00000A07 00000000            <1> 	dd		0
  1354                              <1> 
  1355                              <1> .secOff:
  1356 00000A0B 0000                <1> 	dw		0
  1357                              <1> 
  1358                              <1> ;========================================================================================
  1359                              <1> ; Converts the cluster number in eax into a sector number.
  1360                              <1> ;========================================================================================
  1361                              <1> FAT_ClusterToSector:
  1362 00000A0D 6651                <1> 	push	ecx													; Back up EBX
  1363                              <1> 
  1364 00000A0F 6648                <1> 	dec		eax													; Subtract 2 from cluster
  1365 00000A11 6648                <1> 	dec		eax													; ""
  1366                              <1> 
  1367 00000A13 6631C9              <1> 	xor		ecx, ecx											; Clear EBX
  1368 00000A16 8A0E[980B]          <1> 	mov		cl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1369 00000A1A 66F7E1              <1> 	mul		ecx													; Multiply by number of sectors per cluster
  1370                              <1> 
  1371 00000A1D 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1372 00000A20 8B0E[A80B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Root directory sector
  1373 00000A24 6601C8              <1> 	add		eax, ecx											; Add to sector count
  1374                              <1> 
  1375 00000A27 668B0E[B00B]        <1> 	mov		ecx, DWORD [FAT_FirstDataSector]					; Get first data sector
  1376 00000A2C 6601C8              <1> 	add		eax, ecx											; Add data sector offset
  1377                              <1> 
  1378 00000A2F 6659                <1> 	pop		ecx													; Restore EBX
  1379                              <1> 
  1380 00000A31 C3                  <1> 	ret
  1381                              <1> 
  1382                              <1> ;========================================================================================
  1383                              <1> ; Reads the sector containing the FAT entry for the specified cluster, then returns the
  1384                              <1> ; FAT read from the sector.
  1385                              <1> ; eax: Cluster
  1386                              <1> ; Sets carry flag if error.
  1387                              <1> ;========================================================================================
  1388                              <1> FAT_ReadFAT:
  1389 00000A32 E892FF              <1> 	call	FAT_FindClusterInTable								; Locate cluster
  1390 00000A35 6653                <1> 	push	ebx													; Push offset into sector to stack
  1391                              <1> 
  1392                              <1> 	; Read sector to memory
  1393 00000A37 E82500              <1> 	call	FAT_ReadSector										; Read sector
  1394 00000A3A 665B                <1> 	pop		ebx													; Pop offset into sector
  1395 00000A3C 721F                <1> 	jc 		SHORT .error										; If error, return
  1396                              <1> 
  1397                              <1> 	; Sector is now read to memory
  1398 00000A3E 8A1E[C00B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1399 00000A42 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1400 00000A45 740D                <1> 	je		.FAT32												; If so, jump
  1401                              <1> 
  1402 00000A47 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1403 00000A4A 678B83[E00B0000]    <1> 	mov		ax, WORD [FAT_ReadBuffer+ebx]						; Read FAT16 entry
  1404 00000A51 E90800              <1> 	jmp		.done												; Skip over read below
  1405                              <1> 
  1406                              <1> .FAT32:
  1407 00000A54 66678B83[E00B0000]  <1> 	mov		eax, DWORD [FAT_ReadBuffer+ebx]						; Read FAT32 entry
  1408                              <1> 
  1409                              <1> .done:
  1410 00000A5C C3                  <1> 	ret
  1411                              <1> 
  1412                              <1> .error:
  1413 00000A5D F9                  <1> 	stc															; Set carry
  1414 00000A5E C3                  <1> 	ret
  1415                              <1> 
  1416                              <1> ;========================================================================================
  1417                              <1> ; Reads a logical sector from the drive.
  1418                              <1> ; eax: Logical sector
  1419                              <1> ; Clears the carry flag if successful, set otherwise.
  1420                              <1> ;========================================================================================
  1421                              <1> FAT_ReadSector:
  1422 00000A5F 660306[BC0B]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1423                              <1> 
  1424 00000A64 668B1E[C40B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1425 00000A69 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1426 00000A6C 7429                <1> 	je		.done												; If they are the same sector, branch
  1427                              <1> 
  1428 00000A6E 66A3[D00B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1429 00000A72 C706[CA0B]0100      <1> 	mov		WORD [FAT_ERTable+0x02], 0x01						; Read one sector
  1430 00000A78 C706[CC0B][E00B]    <1> 	mov		WORD [FAT_ERTable+0x04], FAT_ReadBuffer				; Temporary sector buffer offset (seg 0)
  1431 00000A7E C706[CE0B]0000      <1> 	mov		WORD [FAT_ERTable+0x06], 0x00						; Page 0
  1432                              <1> 
  1433 00000A84 66A3[C40B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Store LBA we're loading
  1434                              <1> 
  1435 00000A88 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1436 00000A89 BE[C80B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1437 00000A8C B442                <1> 	mov 	ah, $42												; Extended Read
  1438 00000A8E 8A16[C10B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1439 00000A92 CD13                <1> 	int 	$13													; Perform read
  1440 00000A94 61                  <1> 	popa														; Pop registers
  1441 00000A95 7202                <1> 	jc 		SHORT .error										; If error, return
  1442                              <1> 
  1443                              <1> .done:
  1444 00000A97 F8                  <1> 	clc															; Clear carry
  1445 00000A98 C3                  <1> 	ret
  1446                              <1> 
  1447                              <1> .error:
  1448 00000A99 F9                  <1> 	stc															; Set carry
  1449 00000A9A C3                  <1> 	ret
  1450                              <1> 
  1451                              <1> ;========================================================================================
  1452                              <1> ; Tries to locate a file with the name pointed to by in esi in the root directory of the
  1453                              <1> ; FAT. If found, returns the first cluster of the file in eax, filesize in ebx, and
  1454                              <1> ; clears carry. If not found, sets carry.
  1455                              <1> ;
  1456                              <1> ; Note that this only searches the short filename.
  1457                              <1> ;========================================================================================
  1458                              <1> FAT_FindFileAtRoot:
  1459 00000A9B 60                  <1> 	pusha														; Push regs
  1460 00000A9C 66A1[940B]          <1> 	mov		eax, DWORD [FAT_BPB_RootClus]						; Read root sector location
  1461 00000AA0 E86AFF              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1462 00000AA3 E8B9FF              <1> 	call	FAT_ReadSector										; Read sector
  1463                              <1> 
  1464 00000AA6 66BF[E00B0000]      <1> 	mov		edi, FAT_ReadBuffer									; FAT read buffer
  1465 00000AAC B91000              <1> 	mov		cx, (512/32)										; Search the first 512/32 entries
  1466                              <1> 
  1467                              <1> .searchLoop:
  1468 00000AAF 678A07              <1> 	mov		al, BYTE [edi]										; Read first byte of string
  1469                              <1> 
  1470 00000AB2 3CE5                <1> 	cmp		al, $0E5											; Is directory entry free?
  1471 00000AB4 7426                <1> 	je		.fileEntryIgnore									; If so, branch
  1472 00000AB6 3C00                <1> 	cmp		al, $00												; Is directory entry free and last one?
  1473 00000AB8 7428                <1> 	je		.notFound											; If so, exit loop.
  1474                              <1> 
  1475                              <1> 	; Store pointers
  1476 00000ABA 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1477 00000ABD 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1478 00000AC0 6689F8              <1> 	mov		eax, edi											; Copy read pointer to EAX
  1479 00000AC3 6689F2              <1> 	mov		edx, esi											; Copy filename compare ptr to EDX
  1480                              <1> 
  1481                              <1> 	; Compare filename
  1482 00000AC6 51                  <1> 	push	cx													; Push loop counter
  1483 00000AC7 B90B00              <1> 	mov		cx, $0B												; Filename is 11 bytes
  1484                              <1> 
  1485                              <1> .comparison:
  1486 00000ACA 678A18              <1> 	mov		bl, BYTE [eax]										; Read soruce ptr
  1487 00000ACD 673A1A              <1> 	cmp		bl, BYTE [edx]										; Compare against target
  1488 00000AD0 7509                <1> 	jne		.compareFailed										; If not equal, branch
  1489                              <1> 
  1490 00000AD2 6640                <1> 	inc		eax													; Increment read pointer
  1491 00000AD4 6642                <1> 	inc		edx													; Increment target pointer
  1492                              <1> 
  1493 00000AD6 E2F2                <1> 	loop	.comparison											; Compare 11 bytes
  1494                              <1> 
  1495 00000AD8 59                  <1> 	pop		cx													; Pop loop counter from stack
  1496 00000AD9 EB0A                <1> 	jmp		SHORT .found										; File was found
  1497                              <1> 
  1498                              <1> .compareFailed:
  1499 00000ADB 59                  <1> 	pop		cx													; Pop loop counter
  1500                              <1> 
  1501                              <1> .fileEntryIgnore:
  1502 00000ADC 81C72000            <1> 	add		di, $20												; Read next entry
  1503 00000AE0 E2CD                <1> 	loop	.searchLoop											; Loop through entries
  1504                              <1> 
  1505                              <1> ; Drop down here once loop finishes: file not found.
  1506                              <1> .notFound:
  1507 00000AE2 61                  <1> 	popa														; Pop registers
  1508 00000AE3 F9                  <1> 	stc															; Set carry
  1509 00000AE4 C3                  <1> 	ret
  1510                              <1> 
  1511                              <1> ; We found the file
  1512                              <1> .found:
  1513 00000AE5 678B471A            <1> 	mov		ax, WORD [edi+26]									; Read cluster low word
  1514 00000AE9 A3[080B]            <1> 	mov		WORD [.clusterOfFile], ax							; ""
  1515 00000AEC 678B4714            <1> 	mov		ax, WORD [edi+20]									; Read cluster high word
  1516 00000AF0 A3[0A0B]            <1> 	mov		WORD [.clusterOfFile+2], ax							; ""
  1517                              <1> 
  1518 00000AF3 66678B471C          <1> 	mov		eax, DWORD [edi+28]									; Read filesize
  1519 00000AF8 66A3[0C0B]          <1> 	mov		DWORD [.sizeOfFile], eax							; ""
  1520                              <1> 
  1521 00000AFC 61                  <1> 	popa														; Pop registers
  1522 00000AFD 66A1[080B]          <1> 	mov		eax, DWORD [.clusterOfFile]							; Read file's cluster
  1523 00000B01 668B1E[0C0B]        <1> 	mov		ebx, DWORD [.sizeOfFile]							; Read file's size
  1524 00000B06 F8                  <1> 	clc															; Clear carry bit
  1525 00000B07 C3                  <1> 	ret
  1526                              <1> 
  1527                              <1> 	align	4
  1528                              <1> .clusterOfFile:
  1529 00000B08 00000000            <1> 	dd		0
  1530                              <1> .sizeOfFile:
  1531 00000B0C 00000000            <1> 	dd		0
  1532                              <1> 
  1533                              <1> ;========================================================================================
  1534                              <1> ; Reads the file whose first cluster is in eax to es:di.
  1535                              <1> ;
  1536                              <1> ; Note that this function returns after reading a maximum of 256 chunks.
  1537                              <1> ;========================================================================================
  1538                              <1> FAT_ReadFile:
  1539 00000B10 60                  <1> 	pusha														; Push all regisers
  1540                              <1> 
  1541 00000B11 E80800              <1> 	call	FAT_ReadCluster										; Read cluster
  1542 00000B14 7203                <1> 	jc 		SHORT .error										; If error, return
  1543                              <1> 
  1544                              <1> ;	xor		cx, cx												; Clear CX
  1545                              <1> ;	mov		gs, cx												; Clear GS
  1546                              <1> ;
  1547                              <1> ;.readLoop:
  1548                              <1> ;	call	FAT_ReadFAT											; Read FAT entry for current cluster
  1549                              <1> ;	and		eax, $0FFFFFFF										; Ignore high nybble
  1550                              <1> ;	cmp		eax, $0FFFFFF8										; End of chain marker?
  1551                              <1> ;	jae		.done												; If so, branch (unsigned compare)
  1552                              <1> ;
  1553                              <1> ;	call	FAT_ReadCluster										; Read cluster
  1554                              <1> ;	jc 		SHORT .error										; If error, return
  1555                              <1> ;
  1556                              <1> ;	mov		cx, gs												; Read GS
  1557                              <1> ;	inc		cx													; Increment GS
  1558                              <1> ;	mov		gs, cx												; Move back to GS
  1559                              <1> ;
  1560                              <1> ;	cmp		cl, $0FF											; Is it max? ($FF)
  1561                              <1> ;	je		.error												; If so, we're done
  1562                              <1> ;
  1563                              <1> ;	jmp		.readLoop											; Loop until all sectors of the file are read
  1564                              <1> 
  1565                              <1> .done:
  1566 00000B16 61                  <1> 	popa														; Pop registers
  1567 00000B17 F8                  <1> 	clc															; Clear carry
  1568 00000B18 C3                  <1> 	ret
  1569                              <1> 
  1570                              <1> .error:
  1571 00000B19 61                  <1> 	popa														; Pop registers
  1572 00000B1A F9                  <1> 	stc															; Set carry
  1573 00000B1B C3                  <1> 	ret
  1574                              <1> 
  1575                              <1> ;========================================================================================
  1576                              <1> ; Reads a logical sector from the drive.
  1577                              <1> ; eax: Logical cluster
  1578                              <1> ; es:di: Memory location (Incremented after read)
  1579                              <1> ; Clears the carry flag if successful, set otherwise.
  1580                              <1> ;========================================================================================
  1581                              <1> FAT_ReadCluster:
  1582 00000B1C 66A3[880B]          <1> 	mov		DWORD [.origCluster], eax							; Store original cluster
  1583 00000B20 E8EAFE              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1584                              <1> 
  1585 00000B23 660306[BC0B]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1586                              <1> 
  1587 00000B28 668B1E[C40B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1588 00000B2D 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1589 00000B30 742E                <1> 	je		.done												; If they are the same sector, branch
  1590 00000B32 66A3[C40B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Save sector we're reading
  1591                              <1> 
  1592 00000B36 31DB                <1> 	xor		bx, bx												; Clear BX
  1593 00000B38 8A1E[980B]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1594 00000B3C C706[CA0B]FF01      <1> 	mov		WORD [FAT_ERTable+0x02], $1FF							; Write sectors/cluster 
  1595 00000B42 66A3[D00B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1596 00000B46 893E[CC0B]          <1> 	mov		WORD [FAT_ERTable+0x04], di							; Offset in segment
  1597 00000B4A 8C06[CE0B]          <1> 	mov		WORD [FAT_ERTable+0x06], es							; Segment
  1598                              <1> 
  1599 00000B4E 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1600 00000B4F BE[C80B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1601 00000B52 B442                <1> 	mov 	ah, $42												; Extended Read		
  1602 00000B54 8A16[C10B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1603 00000B58 CD13                <1> 	int 	$13													; Perform read
  1604 00000B5A 61                  <1> 	popa														; Pop registers
  1605 00000B5B 7209                <1> 	jc 		SHORT .error										; If error, return
  1606                              <1> 
  1607 00000B5D E80C00              <1> 	call	.incrementReadPtr									; Increment read pointer
  1608                              <1> 
  1609                              <1> .done:	
  1610 00000B60 66A1[880B]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1611 00000B64 F8                  <1> 	clc															; Clear carry
  1612 00000B65 C3                  <1> 	ret
  1613                              <1> 
  1614                              <1> .error:
  1615 00000B66 66A1[880B]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1616 00000B6A F9                  <1> 	stc															; Set carry
  1617 00000B6B C3                  <1> 	ret
  1618                              <1> 
  1619                              <1> .incrementReadPtr:
  1620 00000B6C 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1621 00000B6F A1[8C0B]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1622 00000B72 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1623 00000B75 8A1E[980B]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read bytes per sector
  1624                              <1> 
  1625 00000B79 66F7E3              <1> 	mul		ebx													; EAX = value to add to write ptr
  1626 00000B7C 01C7                <1> 	add		di, ax												; Add cluster length to di
  1627 00000B7E 7107                <1> 	jno		.noOverflow											; If overflow bit isn't set, branch
  1628                              <1> 
  1629 00000B80 8CC0                <1> 	mov		ax, es												; Read segment we're writing to
  1630 00000B82 050010              <1> 	add		ax, $1000											; Write in next segment
  1631 00000B85 8EC0                <1> 	mov		es, ax												; Write to segment register
  1632                              <1> 
  1633                              <1> .noOverflow:
  1634 00000B87 C3                  <1> 	ret
  1635                              <1> 
  1636                              <1> 	align	4
  1637                              <1> .origCluster:
  1638 00000B88 00000000            <1> 	dd		0
  1639                              <1> 
  1640                              <1> ;========================================================================================
  1641                              <1> ; Data section
  1642                              <1> ;========================================================================================
  1643                              <1> 	align	4
  1644                              <1> FAT_BPB_BytesPerSec: ; file offset 11
  1645 00000B8C 0000                <1> 	dw		0
  1646                              <1> FAT_BPB_FSInfo: ; file offset 48, FAT32 only
  1647 00000B8E 0000                <1> 	dw		0
  1648                              <1> FAT_BPB_ExtFlags: ; file offset 40, FAT32 only
  1649 00000B90 0000                <1> 	dw		0
  1650                              <1> FAT_BPB_FSVer: ; file offset 42, FAT32 only
  1651 00000B92 0000                <1> 	dw		0
  1652                              <1> 
  1653                              <1> 	align	4
  1654                              <1> FAT_BPB_RootClus: ; file offset 44, FAT32 only
  1655 00000B94 00000000            <1> 	dd		0
  1656                              <1> FAT_BPB_SectorsPerCluster: ; file offset 13
  1657 00000B98 00                  <1> 	db		0
  1658                              <1> 
  1659 00000B99 90                  <1> 	align	2
  1660                              <1> FAT_BPB_ReservedSectors: ; file offset 14
  1661 00000B9A 0000                <1> 	dw		0
  1662                              <1> FAT_BPB_NumFATs: ; file offset 16
  1663 00000B9C 00                  <1> 	db		0
  1664                              <1> 
  1665 00000B9D 90                  <1> 	align	2
  1666                              <1> FAT_BPB_RootEntCnt:	; file offset 17
  1667 00000B9E 0000                <1> 	dw		0
  1668                              <1> 
  1669                              <1> 	align	4
  1670                              <1> FAT_BPB_FATSz: ; file offset 22 if FAT16, 36 if FAT32 and word at 22 is 0
  1671 00000BA0 00000000            <1> 	dd		0
  1672                              <1> 
  1673                              <1> ; Works with FAT32
  1674                              <1> ; For the total sector count, try to read BPB_FATSz16 first (19), then the 32-bit at off 32
  1675                              <1> FAT_BPB_TotSec: ; file offset 32 if 19 = 0
  1676 00000BA4 00000000            <1> 	dd		0
  1677                              <1> 
  1678                              <1> ; Calculated when identifying FS
  1679                              <1> FAT_RootDirSectors:
  1680 00000BA8 0000                <1> 	dw		0
  1681                              <1> 
  1682 00000BAA 90<rept>            <1> 	align	4
  1683                              <1> FAT_DataSectors:
  1684 00000BAC 00000000            <1> 	dd		0
  1685                              <1> FAT_FirstDataSector:
  1686 00000BB0 00000000            <1> 	dd		0
  1687                              <1> FAT_FirstClusterLocation:
  1688 00000BB4 00000000            <1> 	dd		0
  1689                              <1> FAT_TotalClusters:
  1690 00000BB8 00000000            <1> 	dd		0
  1691                              <1> 
  1692                              <1> ; Offset into drive in sectors to the start of the FAT partition
  1693                              <1> FAT_PartitionOffset:
  1694 00000BBC 00000000            <1> 	dd		0
  1695                              <1> FAT_Type:
  1696 00000BC0 00                  <1> 	db		0
  1697                              <1> 
  1698                              <1> ; BIOS drive to read from
  1699                              <1> FAT_Drive:
  1700 00000BC1 00                  <1> 	db		0
  1701                              <1> 
  1702 00000BC2 90<rept>            <1> 	align	4
  1703                              <1> FAT_LastLoadedSector:
  1704 00000BC4 00000000            <1> 	dd		0
  1705                              <1> 
  1706                              <1> 	align	4
  1707                              <1> FAT_ERTable:
  1708 00000BC8 10                  <1> 	db	$10
  1709 00000BC9 00                  <1> 	db	0
  1710 00000BCA 0000                <1> 	dw	0														; Num blocks
  1711 00000BCC 0000                <1> 	dw	0														; Dest
  1712 00000BCE 0000                <1> 	dw	0														; Memory page
  1713 00000BD0 00000000            <1> 	dd	0														; Starting LBA
  1714 00000BD4 00000000            <1> 	dd	0	
  1715                              <1> 
  1716 00000BD8 90<rept>            <1> 	align	$10
  1717                              <1> FAT_ReadBuffer:
  1718                                  
  1719                                  SectorBuf:
  1720 00000BE0 00<rept>                	times	512 db 0

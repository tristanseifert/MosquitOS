     1                                  	BITS	16
     2                                  	org		$0500
     3                                  
     4                                  ; Kernel will be loaded to segment $0A80, or $00A800 physical
     5                                  kern_loc:				EQU $0A80
     6                                  kern_loc_phys:			EQU kern_loc<<4
     7                                  kern_start:				EQU 6
     8                                  kern_len:				EQU 32									; Length in sectors
     9                                  
    10                                  SVGA_Mode:				EQU $118
    11                                  
    12                                  ; Location to store various BIOS info at
    13                                  Kern_Info_Struct:		EQU $0160								; $001600 phys (len = $400 max)
    14                                  Kern_Info_StructPhys:	EQU (Kern_Info_Struct<<4)
    15                                  VESA_SupportedModes:	EQU	$01A0								; $001A00 phys (len = $200)
    16                                  VESA_ModeInfos:			EQU	$01C0								; $001C00 phys (len = $100)
    17                                  
    18                                  BIOS_MemMapSeg:			EQU	$0300								; $003000 phys (len = $800 max)
    19                                  
    20                                  ; Physical protected mode addresses
    21                                  MMU_PageDir:			EQU $004000
    22                                  MMU_PageTable1:			EQU $005000
    23                                  MMU_PageTable2:			EQU $006000
    24                                  MMU_PageTable3:			EQU $007000
    25                                  MMU_PageTable4:			EQU $008000
    26                                  MMU_PageTable5:			EQU $009000
    27                                  
    28                                  ;	+$00 uint32_t munchieValue; // Should be "KERN"
    29                                  ;	+$04 uint16_t supportBits;
    30                                  ;	+$06 uint16_t high16Mem; // 64K blocks above 16M
    31                                  ;	+$08 uint16_t low16Mem; // 1k blocks below 16M
    32                                  ;	+$0A uint32_t memMap; // 32-bit ptr to list
    33                                  ;	+$0E uint16_t numMemMapEnt; // Number of entries in above map
    34                                  ;	+$10 uint8_t vesaSupport;
    35                                  ;	+$11 uint8_t bootDrive;
    36                                  ;	+$12 uint32_t vesaMap;
    37                                  
    38                                  stage2_start:
    39 00000000 B80080                  	mov		ax, $8000											; AX = stack segment value (Stack to go at $80000)
    40 00000003 8ED0                    	mov 	ss, ax
    41 00000005 BC0010                  	mov 	sp, 4096											; Set up SP
    42                                  
    43 00000008 8CC8                    	mov 	ax, cs												; Set data segment to where we're loaded
    44 0000000A 8ED8                    	mov 	ds, ax
    45                                  
    46 0000000C 8816[8D07]              	mov		BYTE [BootDevice], dl								; Save boot device number
    47 00000010 8816[A10B]              	mov		BYTE [FAT_Drive], dl								; Set FAT read drive
    48                                  
    49 00000014 66C70600164B45524E      	mov		DWORD [Kern_Info_StructPhys], "KERN"				; Set magic value for kern struct
    50                                  
    51 0000001D A0[8D07]                	mov		al, [BootDevice]									; Set boot drive
    52 00000020 A21116                  	mov		BYTE [Kern_Info_StructPhys+$11], al					; ""
    53                                  
    54                                  	; Set up video
    55 00000023 B400                    	mov		ah, $00												; Change video mode
    56 00000025 B003                    	mov		al, $03												; 80x25 text mode
    57 00000027 CD10                    	int		$10													; Call video BIOS
    58                                  
    59 00000029 BE[A405]                	mov 	si, str_stage2loaded								; Put string position into SI
    60 0000002C 31D2                    	xor		dx, dx												; Cursor position
    61 0000002E BF2F00                  	mov		di, $2F												; Set colour
    62 00000031 E8CA03                  	call 	print_string										; Call string printing routine
    63                                  
    64                                  	; Call VESA BIOS routines to get supported video modes
    65 00000034 B8A001                  	mov		ax, VESA_SupportedModes								; Memory location of supported mode struct
    66 00000037 8EC0                    	mov		es, ax												; ""
    67 00000039 31FF                    	xor		di, di												; Offset 0 in segment
    68                                  
    69 0000003B 2666C70556424532        	mov		[es:di], DWORD "VBE2"								; Tell BIOS we want 512 bytes of data
    70                                  
    71 00000043 B8004F                  	mov		ax, $4F00											; VESA BIOS routines â€” get supported modes
    72 00000046 CD10                    	int		$10													; Perform lookup
    73                                  
    74 00000048 B8C001                  	mov		ax, VESA_ModeInfos									; Buffer
    75 0000004B 8EC0                    	mov		es, ax
    76 0000004D 31FF                    	xor		di, di												; Offset 0 into buffer
    77 0000004F B8014F                  	mov		ax, $4F01											; Get VESA mode info function
    78 00000052 B91801                  	mov		cx, SVGA_Mode										; Mode to get info for
    79 00000055 CD10                    	int		$10
    80                                  
    81                                  
    82 00000057 84E4                    	test	ah, ah												; Is AH not zero (i.e. error)
    83 00000059 7400                    	je		.vesaDone											; If so, VESA is unsupported
    84                                  
    85                                  .vesaDone:
    86                                  	; Call BIOS to get memory information
    87 0000005B 31C9                    	xor 	cx, cx
    88 0000005D 31D2                    	xor 	dx, dx
    89 0000005F B801E8                  	mov 	ax, $0E801
    90 00000062 CD15                    	int 	$15													; Request upper memory size
    91 00000064 E304                    	jcxz 	.useax												; Was the CX result invalid?
    92                                   
    93 00000066 89C8                    	mov		ax, cx												; Number of continuous 1K blocks (1M-16M)
    94 00000068 89D3                    	mov		bx, dx												; Number of continuous 64K block above 16M
    95                                  
    96                                  .useax:
    97 0000006A 31FF                    	xor		di, di												; Clear DI
    98 0000006C 891E[9007]              	mov		WORD [MemBlocksAbove16M], bx						; Store amount of memory available
    99 00000070 891E0616                	mov		WORD [Kern_Info_StructPhys+$06], bx					; Highmem
   100 00000074 A3[9207]                	mov		WORD [MemBlocksBelow16M], ax						; ""
   101 00000077 A30816                  	mov		WORD [Kern_Info_StructPhys+$08], ax					; Lowmem
   102                                  
   103 0000007A E85C03                  	call	display_memsize										; Display the memory size
   104                                  
   105                                  	; Fetch memory map
   106 0000007D B80003                  	mov 	ax, BIOS_MemMapSeg									; Write mem map to $01800 in physical space
   107 00000080 8EC0                    	mov 	es, ax
   108 00000082 31FF                    	xor		di, di												; Start of segment
   109                                  
   110 00000084 E82004                  	call	fetch_mem_map										; Fetch a memory map
   111 00000087 7221                    	jc 		SHORT error_memoryDetect							; Branch if error
   112                                  
   113                                  error_memoryDetectRet:
   114 00000089 892E0E16                	mov		WORD [Kern_Info_StructPhys+$0E], bp					; ""
   115 0000008D 66C7060A1600300000      	mov		DWORD [Kern_Info_StructPhys+$0A], (BIOS_MemMapSeg<<4); Physical location of table
   116                                  
   117                                  	; Initialise FAT library
   118 00000096 E89707                  	call	FAT_Init
   119                                  
   120                                  	; Check which partitions are bootable from MBR partition map
   121 00000099 E88C02                  	call	find_bootable_partitions
   122 0000009C C606[9E07]00            	mov		BYTE [HDD_Selected], 0								; Clear HDD selection
   123                                  
   124                                  	; Set up the partition chooser UI
   125 000000A1 E80701                  	call	render_partition_chooser
   126                                  
   127                                  	; Process keypresses, and loads kernel from FS if ENTER is pressed
   128 000000A4 E8FD01                  	call	chooser_loop
   129 000000A7 E90B00                  	jmp		boot
   130                                  
   131                                  ;========================================================================================
   132                                  ; Memory detection error handler
   133                                  ;========================================================================================
   134                                  error_memoryDetect:
   135 000000AA BA010E                  	mov		dx, $0E01
   136 000000AD BE[BF05]                	mov 	si, str_errorDetectMem								; Put string position into SI
   137 000000B0 E84503                  	call 	print_error											; Call string printing routine
   138 000000B3 EBD4                    	jmp		error_memoryDetectRet								; Return to above meeper
   139                                  
   140                                  ;========================================================================================
   141                                  ; Code to boot the kernel
   142                                  ;========================================================================================
   143                                  boot:
   144                                  	; Hide cursor
   145 000000B5 31D2                    	xor		dx, dx												; Clear dx
   146 000000B7 F7D2                    	not		dx													; dx = $FFFF
   147 000000B9 B402                    	mov 	ah, $02												; Set cursor position
   148 000000BB 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   149 000000BD CD10                    	int		$10													; Set cursor
   150                                  
   151                                  	; Go into SVGA mode specified, linear framebuffer, clear memory
   152 000000BF BB1841                  	mov		bx, ($4000 | SVGA_Mode)								; SVGA mode
   153 000000C2 B8024F                  	mov		ax, $4F02											; SVGA routine calls
   154 000000C5 CD10                    	int		$10													; Call video BIOS
   155                                  
   156                                  	; Set up GDT
   157 000000C7 FA                      	cli															; Disable ints
   158 000000C8 0F0116[2808]            	lgdt	[gdt_table]											; Set up GDTR
   159                                  
   160                                  	; Enable protected mode
   161 000000CD 0F20C0                  	mov		eax, cr0											; Get control reg
   162 000000D0 0C01                    	or		al, 00000001b										; Set PE bit
   163 000000D2 0F22C0                  	mov		cr0, eax											; Write control reg
   164                                  
   165                                  	; Set up selectors
   166 000000D5 B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   167 000000D8 8ED8                    	mov		ds, ax												; Set data selector
   168                                  
   169 000000DA B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   170 000000DD 8EC0                    	mov		es, ax												; Update other selectors to point to data segment
   171 000000DF 8EE0                    	mov		fs, ax
   172 000000E1 8EE8                    	mov		gs, ax
   173 000000E3 8ED0                    	mov		ss, ax
   174                                  
   175                                  	; The kernel is loaded to $00003000 phys (segmented address 0300h:0000h)
   176 000000E5 66                      	db		$66													; 32-bit prefix
   177 000000E6 EA                      	db		$0EA												; Far jump opcode
   178 000000E7 [ED000000]              	dd		copy_kernel											; Jump to kernel copying routine
   179 000000EB 0800                    	dw		$08													; Selector for CODE32_DESCRIPTOR
   180                                  
   181                                  	; Protected mode code runs as 32-bits
   182                                  	BITS	32
   183                                  copy_kernel:
   184 000000ED BC00004000              	mov		esp, $400000										; Stackzors at $400000
   185                                  
   186 000000F2 B800A80000              	mov		eax, kern_loc_phys									; Physical kernel location
   187 000000F7 BB00001000              	mov		ebx, $00100000										; Destination memory address
   188 000000FC B900400000              	mov		ecx, $4000											; Number of long-words to copy (64KB)
   189                                  
   190 00000101 90<rept>                	align	4													; DWORD align
   191                                  .copy:
   192 00000104 8B10                    	mov		edx, DWORD [eax]									; Read a DWORD from lowmem
   193 00000106 8913                    	mov		DWORD [ebx], edx									; Write DWORD to himem
   194                                  
   195 00000108 0504000000              	add		eax, $04											; Increment read ptr
   196 0000010D 81C304000000            	add		ebx, $04											; Increment write ptr
   197                                  
   198 00000113 E2EF                    	loop	.copy												; Loop and copy everything
   199                                  
   200                                  	; Here, we build a page directory and table to map $C0000000 to $00100000.
   201 00000115 31C0                    	xor		eax, eax
   202 00000117 BB00400000              	mov		ebx, MMU_PageDir
   203 0000011C B900100000              	mov		ecx, $1000
   204                                  
   205                                  .clrTablesLoop:
   206 00000121 8903                    	mov		DWORD [ebx], eax
   207 00000123 81C304000000            	add		ebx, $04
   208 00000129 E2F6                    	loop	.clrTablesLoop
   209                                  
   210                                  
   211                                  	; Since we only need to map 4M for right now, concern ourselves only with entry 0x300 and 0x000
   212                                  	; Also, map 0x00000000 to 0x003FFFFF
   213 0000012B C70500400000035000-     	mov		DWORD [MMU_PageDir+0x000], (MMU_PageTable1 | $3)
   214 00000134 00                 
   215                                  
   216 00000135 C705004C0000036000-     	mov		DWORD [MMU_PageDir+0xC00], (MMU_PageTable2 | $3)
   217 0000013E 00                 
   218 0000013F C705044C0000037000-     	mov		DWORD [MMU_PageDir+0xC04], (MMU_PageTable3 | $3)
   219 00000148 00                 
   220 00000149 C705084C0000038000-     	mov		DWORD [MMU_PageDir+0xC08], (MMU_PageTable4 | $3)
   221 00000152 00                 
   222 00000153 C7050C4C0000039000-     	mov		DWORD [MMU_PageDir+0xC0C], (MMU_PageTable5 | $3)
   223 0000015C 00                 
   224                                  
   225                                  	; Run a loop 1024 times to fill the first page table
   226 0000015D B900040000              	mov		ecx, $400
   227 00000162 31DB                    	xor		ebx, ebx											; Page table offset
   228 00000164 B807000000              	mov		eax, DWORD $00000007									; Physical address start
   229                                  
   230                                  .fillPageTable1:
   231 00000169 89049D00500000          	mov		DWORD [MMU_PageTable1+ebx*4], eax					; Write physical location
   232                                  
   233 00000170 43                      	inc		ebx													; Go to next entry in page table
   234 00000171 0500100000              	add		eax, $1000											; Increment physical address
   235 00000176 E2F1                    	loop	.fillPageTable1
   236                                  
   237                                  
   238                                  	; Run a loop 8192 times to fill the second page table
   239 00000178 B900100000              	mov		ecx, $1000
   240 0000017D 31DB                    	xor		ebx, ebx											; Page table offset
   241 0000017F B807001000              	mov		eax, DWORD $00100007								; Physical address start
   242                                  
   243                                  .fillPageTable2:
   244 00000184 89049D00600000          	mov		DWORD [MMU_PageTable2+ebx*4], eax					; Write physical location
   245                                  
   246 0000018B 43                      	inc		ebx													; Go to next entry in page table
   247 0000018C 0500100000              	add		eax, $1000											; Increment physical address
   248 00000191 E2F1                    	loop	.fillPageTable2
   249                                  
   250                                  
   251                                  	; Set paging directory in CR3
   252 00000193 B800400000              	mov		eax, MMU_PageDir
   253 00000198 0F22D8                  	mov		cr3, eax
   254                                  
   255                                  	; Enable paging in CR0
   256 0000019B 0F20C0                  	mov		eax, cr0
   257 0000019E 0D00000080              	or		eax, $80000000
   258 000001A3 0F22C0                  	mov		cr0, eax
   259                                  
   260                                  	; Jump into kernel
   261 000001A6 E9(000000C0)            	jmp		$0C0000000
   262                                  
   263                                  	; Rest of bootloader runs in real mode, so 16-bit code
   264                                  	BITS	16
   265                                  ;========================================================================================
   266                                  ; Renders the partition chooser
   267                                  ;========================================================================================
   268                                  render_partition_chooser:
   269 000001AB BE[5D06]                	mov 	si, str_select_partition							; Put string position into SI
   270 000001AE BA0105                  	mov		dx, $0501											; Cursor position
   271 000001B1 BF0700                  	mov		di, $07												; Set colour
   272 000001B4 E84702                  	call 	print_string										; Call string printing routine
   273                                  
   274 000001B7 C706[8E07]0407          	mov		WORD [LastCursorPosition], 0x0704					; Read last cursor position
   275                                  
   276 000001BD 66BA[96070000]          	mov		edx, HDD_BootablePartitions							; EDX contains bootable partition ptr
   277 000001C3 B90400                  	mov		cx, $04												; Loop 4x
   278                                  
   279                                  .disp_loop:
   280 000001C6 678A02                  	mov		al, BYTE [edx]										; Read bootability
   281 000001C9 2480                    	and		al, $80												; Get high bit only
   282 000001CB 3C80                    	cmp		al, $80												; Is it $80?
   283 000001CD 7505                    	jne		.not_bootable										; If not, it's not a bootable drive
   284                                  
   285 000001CF E81300                  	call	.render_boot										; Render bootable drive label
   286                                  
   287 000001D2 EB03                    	jmp		SHORT .next											; Skip over non-bootable code
   288                                  
   289                                  .not_bootable:
   290 000001D4 E87900                  	call	.render_noboot										; Render non-bootable drive label
   291                                  
   292                                  .next:
   293 000001D7 6642                    	inc		edx													; Go to next item
   294 000001D9 E2EB                    	loop	.disp_loop											; Loop over all 4 partitions
   295                                  
   296 000001DB BA010C                  	mov		dx, $0C01
   297 000001DE BE[F006]                	mov		si, str_err_clear_err								; Clear error
   298 000001E1 E81A02                  	call	print_string										; Display
   299                                  
   300 000001E4 C3                      	ret
   301                                  
   302                                  ;========================================================================================
   303                                  ; Renders an entry for a bootable drive
   304                                  ;========================================================================================
   305                                  .render_boot:
   306 000001E5 B004                    	mov		al, $04												; Max drive num to al
   307 000001E7 28C8                    	sub		al, cl												; Subtract loop counter
   308 000001E9 A2[4C02]                	mov		BYTE [.index], al									; Write index
   309 000001EC 0430                    	add		al, $30												; ASCII numbers
   310                                  
   311 000001EE 66C706[CF07]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   312 000001F6 2C                 
   313 000001F7 A2[D307]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   314 000001FA C706[D407]3A20          	mov		WORD [Temp_StrBuf+5], ": "							; Colon, space
   315                                  
   316 00000200 60                      	pusha														; Push registers
   317 00000201 66BA[D6070000]          	mov		edx, Temp_StrBuf+7									; String buffer write place
   318 00000207 66BB[9F070000]          	mov		ebx, HDD_PartitionNames								; Partition names
   319 0000020D B90C00                  	mov		cx, $0C												; $0C characters
   320                                  
   321                                  .copyNameLoop:
   322 00000210 678A03                  	mov		al, BYTE [ebx]										; Copy a character
   323 00000213 678802                  	mov		BYTE [edx], al										; Write to temp buffer
   324 00000216 6643                    	inc		ebx													; Increment read pointer
   325 00000218 6642                    	inc		edx													; Increment write pointer
   326 0000021A E2F4                    	loop	.copyNameLoop
   327                                  
   328 0000021C 67C742FF0A00            	mov		WORD [edx-1], 0x000A								; Insert newline
   329                                  
   330 00000222 6631C0                  	xor		eax, eax											; Clear EAX
   331 00000225 66BA[9A070000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type matrix
   332 0000022B 0216[4C02]              	add		dl, BYTE [.index]
   333 0000022F 678A02                  	mov		al, BYTE [edx]										; Read FAT type to AL
   334                                  
   335 00000232 8A1E[9E07]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   336 00000236 80E303                  	and		bl, $3												; Get low 2 bits only
   337 00000239 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   338 0000023B 7503                    	jne		.no_highlight										; If not, branch.
   339                                  
   340 0000023D BF7000                  	mov		di, $070											; Black text on white background
   341                                  
   342                                  .no_highlight:
   343 00000240 8B16[8E07]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   344 00000244 BE[CF07]                	mov		si, Temp_StrBuf										; Temporary string buffer
   345 00000247 E8B401                  	call 	print_string										; Call string printing routine
   346 0000024A 61                      	popa														; Pop registers
   347                                  
   348 0000024B C3                      	ret
   349                                  
   350                                  .index:
   351 0000024C 00                      	db	0
   352                                  
   353                                  ;========================================================================================
   354                                  ; Renders an entry for a non-bootable drive.
   355                                  ;========================================================================================
   356 0000024D 90<rept>                	align 4
   357                                  
   358                                  .render_noboot:
   359 00000250 B004                    	mov		al, $04												; Max drive num to al
   360 00000252 28C8                    	sub		al, cl												; Subtract loop counter
   361 00000254 0430                    	add		al, $30												; ASCII numbers
   362                                  
   363 00000256 66C706[CF07]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   364 0000025E 2C                 
   365 0000025F A2[D307]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   366 00000262 66C706[D407]3A204E-     	mov		DWORD [Temp_StrBuf+5], ": No"						; "Not Bootable"
   367 0000026A 6F                 
   368 0000026B 66C706[D807]742042-     	mov		DWORD [Temp_StrBuf+9], "t Bo"
   369 00000273 6F                 
   370 00000274 66C706[DC07]6F7461-     	mov		DWORD [Temp_StrBuf+13], "otab"
   371 0000027C 62                 
   372 0000027D C706[E007]6C65          	mov		WORD [Temp_StrBuf+17], "le"
   373 00000283 C706[E207]0A00          	mov		WORD [Temp_StrBuf+19], 0x000A						; Newline, terminator
   374                                  
   375 00000289 60                      	pusha														; Push registers
   376                                  
   377 0000028A 8A1E[9E07]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   378 0000028E 80E303                  	and		bl, $3												; Get low 2 bits only
   379 00000291 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   380 00000293 7503                    	jne		.no_highlight2										; If not, branch.
   381                                  
   382 00000295 BF7000                  	mov		di, $070											; Black text on white background
   383                                  
   384                                  .no_highlight2:
   385 00000298 8B16[8E07]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   386 0000029C BE[CF07]                	mov		si, Temp_StrBuf										; Temporary string buffer
   387 0000029F E85C01                  	call 	print_string										; Call string printing routine
   388 000002A2 61                      	popa														; Pop registers
   389                                  
   390 000002A3 C3                      	ret
   391                                  
   392                                  ;========================================================================================
   393                                  ; Handle keypresses for chooser
   394                                  ;========================================================================================
   395                                  chooser_loop:
   396 000002A4 E91500                  	jmp		partition_chooser_enter
   397                                  
   398 000002A7 30E4                    	xor		ah, ah												; Wait for keystroke
   399 000002A9 CD16                    	int		$16													; Call into BIOS
   400                                  
   401 000002AB 80FC50                  	cmp		ah, $50												; Down pressed?
   402 000002AE 7459                    	je		partition_chooser_dn
   403                                  
   404 000002B0 80FC48                  	cmp		ah, $48												; Up pressed?
   405 000002B3 7463                    	je		partition_chooser_up
   406                                  
   407 000002B5 80FC1C                  	cmp		ah, $1C												; Enter pressed?
   408 000002B8 7402                    	je		partition_chooser_enter
   409                                  
   410 000002BA EBE8                    	jmp		chooser_loop
   411                                  
   412                                  partition_chooser_enter:
   413 000002BC 31DB                    	xor		bx, bx												; Clear BX
   414 000002BE 8A1E[9E07]              	mov		bl, BYTE [HDD_Selected]								; Get selection
   415                                  
   416 000002C2 8A87[9607]              	mov		al, BYTE [HDD_BootablePartitions+bx]				; Check bootability status
   417 000002C6 2480                    	and		al, $80												; Get high bit only
   418 000002C8 3C80                    	cmp		al, $80
   419 000002CA 7527                    	jne		.noBootErr											; If not bootable, branch
   420                                  
   421                                  
   422 000002CC BE[0408]                	mov		si, kernel_filename									; Filename to find
   423 000002CF E8A907                  	call	FAT_FindFileAtRoot									; Find file
   424 000002D2 722A                    	jc		.fileNotFound										; Carry set = KERNEL.BIN not found
   425                                  
   426 000002D4 66A3[0008]              	mov		DWORD [kernel_cluster], eax							; Store cluster
   427                                  
   428 000002D8 31C0                    	xor		ax, ax												; Segment 0
   429 000002DA 8EC0                    	mov		es, ax												; Write segment											
   430 000002DC BF00A8                  	mov		di, kern_loc_phys									; Offset into segment
   431                                  
   432 000002DF 66A1[0008]              	mov		eax, DWORD [kernel_cluster]							; Kernel's cluster location
   433 000002E3 E80A08                  	call	FAT_ReadFile										; Read file
   434                                  
   435 000002E6 BE[4207]                	mov 	si, str_kernel_loaded_ok							; Put string position into SI
   436 000002E9 BA010C                  	mov		dx, $0C01											; Cursor position
   437 000002EC BF0200                  	mov		di, $02												; Set colour
   438 000002EF E80C01                  	call 	print_string										; Call string printing routine
   439                                  
   440 000002F2 C3                      	ret
   441                                  
   442                                  .noBootErr:
   443 000002F3 BA010C                  	mov		dx, $0C01
   444 000002F6 BE[9206]                	mov		si, str_err_not_bootable							; Not bootable error
   445 000002F9 E8FC00                  	call	print_error											; Display
   446 000002FC EBA6                    	jmp		chooser_loop
   447                                  
   448                                  .fileNotFound:
   449 000002FE BA010C                  	mov		dx, $0C01
   450 00000301 BE[BC06]                	mov		si, str_err_kern_not_found							; Not found error
   451 00000304 E8F100                  	call	print_error											; Display
   452 00000307 EB9B                    	jmp		chooser_loop
   453                                  
   454                                  partition_chooser_dn:
   455 00000309 A0[9E07]                	mov		al, BYTE [HDD_Selected]								; Read selection
   456 0000030C FEC8                    	dec		al													; Move cursor up
   457 0000030E 2403                    	and		al, $03												; Get low 2 bits only
   458 00000310 A2[9E07]                	mov		BYTE [HDD_Selected], al								; Restore
   459                                  
   460 00000313 E895FE                  	call	render_partition_chooser							; Update display
   461 00000316 EB8C                    	jmp		chooser_loop
   462                                  
   463                                  partition_chooser_up:
   464 00000318 A0[9E07]                	mov		al, BYTE [HDD_Selected]								; Read selection
   465 0000031B FEC0                    	inc		al													; Move cursor down
   466 0000031D 2403                    	and		al, $03												; Get low 2 bits only
   467 0000031F A2[9E07]                	mov		BYTE [HDD_Selected], al								; Restore
   468                                  
   469 00000322 E886FE                  	call	render_partition_chooser							; Update display
   470 00000325 E97CFF                  	jmp		chooser_loop
   471                                  
   472                                  ;========================================================================================
   473                                  ; Finds all partitions that are bootable.
   474                                  ;========================================================================================
   475                                  find_bootable_partitions:
   476 00000328 B90400                  	mov		cx, $4												; MBR contains 4 partition maps
   477                                  
   478 0000032B B8C007                  	mov		ax, $07C0											; Bootloader at 0x7C00
   479 0000032E 8EC0                    	mov		es, ax												; Set ES to the bootloader's place in memory
   480 00000330 BFBE01                  	mov		di, $1BE											; Start of partition map
   481                                  
   482 00000333 8CD8                    	mov		ax, ds												; Fetch data segment
   483 00000335 8EE8                    	mov		gs, ax												; Set GS to data segment
   484                                  
   485 00000337 66BE[96070000]          	mov		esi, HDD_BootablePartitions							; ESI contains bootable partition ptr
   486 0000033D 66BA[9F070000]          	mov		edx, HDD_PartitionNames								; Partition name ptr
   487                                  
   488                                  .loop:
   489 00000343 268A05                  	mov		al, BYTE [es:di]									; Read bootable flag
   490 00000346 2480                    	and		al, $80												; Get high bit only
   491 00000348 3C80                    	cmp		al, $80												; Is it $80?
   492 0000034A 754B                    	jne		.not_bootable										; If not, it's not a bootable drive
   493                                  
   494 0000034C 678806                  	mov		BYTE [esi], al										; Write bootability flag
   495                                  
   496 0000034F 880E[9E07]              	mov		BYTE [HDD_Selected], cl								; Write index
   497                                  
   498                                  	; Try to read the LBA of the partition
   499 00000353 26668B4508              	mov		eax, DWORD [es:di+8]								; Read partition LBA
   500 00000358 663D00000000            	cmp		eax, $00											; Is it zero?
   501 0000035E 7437                    	je		.no_valid_lba										; If so, fuck off
   502                                  
   503 00000360 66A3[F807]              	mov		DWORD [ExtendedRead_Table+0x08], eax				; Write LBA
   504 00000364 C706[F207]0100          	mov		WORD [ExtendedRead_Table+0x02], 0x01				; Read one sector
   505 0000036A C706[F407][C00B]        	mov		WORD [ExtendedRead_Table+0x04], SectorBuf			; Temporary sector buffer offset (seg 0)
   506                                  
   507 00000370 66A3[9C0B]              	mov		DWORD [FAT_PartitionOffset], eax					; Write offset into FAT
   508                                  
   509 00000374 60                      	pusha														; Push registers (BIOS may clobber them)
   510 00000375 BE[F007]                	mov 	si, ExtendedRead_Table								; address of "disk address packet"
   511 00000378 B442                    	mov 	ah, $42												; Extended Read
   512 0000037A 8A16[8D07]              	mov		dl, BYTE [BootDevice]								; Device number
   513 0000037E CD13                    	int 	$13
   514 00000380 61                      	popa														; Pop registers
   515 00000381 7214                    	jc 		SHORT .no_valid_lba									; If error, fuck off
   516                                  
   517 00000383 E82100                  	call	.typeDetermine										; Determine type and label loc
   518                                  
   519 00000386 51                      	push	cx													; Back up original loop counter
   520                                  
   521 00000387 B90B00                  	mov		cx, $0B												; Copy 0xB bytes
   522                                  .copy_str_loop:
   523 0000038A 678A18                  	mov		bl, BYTE [eax]										; Copy from source
   524 0000038D 67881A                  	mov		BYTE [edx], bl										; Write to target buffer
   525 00000390 6640                    	inc		eax													; Increment read pointer
   526 00000392 6642                    	inc		edx													; Increment write pointer
   527 00000394 E2F4                    	loop	.copy_str_loop										; Copy all bytes.
   528                                  
   529 00000396 59                      	pop		cx													; Restore original loop counter.
   530                                  
   531                                  .no_valid_lba:
   532                                  
   533                                  .not_bootable:
   534 00000397 81C71000                	add		di, $10												; Go to next entry in bootsector
   535 0000039B 6646                    	inc		esi													; Write next bootability flag
   536 0000039D 6681C20C000000          	add		edx, $0C											; Each entry of partition names is 0x0C in length
   537 000003A4 E29D                    	loop	.loop												; Loop through all partitions
   538                                  
   539                                  .done:
   540 000003A6 C3                      	ret
   541                                  
   542                                  ; Determines FAT type and stores pointer to read volume label in eax
   543                                  .typeDetermine:
   544 000003A7 6656                    	push	esi													; Push old ESI
   545 000003A9 BE[C00B]                	mov		si, SectorBuf										; Sector buffer
   546 000003AC E89B04                  	call	FAT_DetermineType									; Determine type of FS
   547 000003AF 665E                    	pop		esi													; Pop ESI
   548                                  
   549 000003B1 6652                    	push	edx													; Back up EDX
   550 000003B3 B304                    	mov		bl, $04												; Max drive num to al
   551 000003B5 28CB                    	sub		bl, cl												; Subtract loop counter
   552                                  
   553 000003B7 66BA[9A070000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type ptr
   554 000003BD 28DA                    	sub		dl, bl												; Subtract index
   555 000003BF 678802                  	mov		BYTE [edx], al										; Write FAT size
   556 000003C2 665A                    	pop		edx													; Restore EDX
   557                                  
   558 000003C4 3C20                    	cmp		al, $20												; Is it a FAT32 volume?
   559 000003C6 7509                    	jne		.fat16_label										; If so, branch
   560                                  
   561 000003C8 66B8[070C0000]          	mov		eax, SectorBuf+$47									; FAT32 has volume label at 0x47
   562                                  
   563 000003CE E90600                  	jmp		.copy												; Copy label
   564                                  
   565                                  	; Extract volume label from sector buffer
   566                                  .fat16_label:
   567 000003D1 66B8[EB0B0000]          	mov		eax, SectorBuf+$2B									; FAT16 has volume label at 0x2B
   568                                  
   569                                  .copy:
   570 000003D7 C3                      	ret
   571                                  
   572                                  .index:
   573 000003D8 00                      	db		0
   574                                  
   575                                  ;========================================================================================
   576                                  ; Displays the memory size on the screen 
   577                                  ;========================================================================================
   578                                  display_memsize:
   579 000003D9 BE[0706]                	mov 	si, str_available_lomem								; Put string position into SI
   580 000003DC BA0002                  	mov		dx, $0200
   581 000003DF E81C00                  	call 	print_string										; Call string printing routine
   582 000003E2 A1[9207]                	mov		ax, WORD [MemBlocksBelow16M]						; Get total of memory blocks to EDX
   583 000003E5 E88100                  	call	hex_to_ascii
   584                                  
   585 000003E8 BE[3206]                	mov 	si, str_available_himem								; Put string position into SI
   586 000003EB BA0003                  	mov		dx, $0300
   587 000003EE E80D00                  	call 	print_string										; Call string printing routine
   588 000003F1 A1[9007]                	mov		ax, WORD [MemBlocksAbove16M]						; Get total of memory blocks to EDX
   589 000003F4 E87200                  	call	hex_to_ascii
   590                                  
   591 000003F7 C3                      	ret
   592                                  
   593                                  ;========================================================================================
   594                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h with the styling
   595                                  ; required for an error string.
   596                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   597                                  ;========================================================================================
   598                                  print_error:
   599 000003F8 BF4F00                  	mov		di, $04F											; White text on red background
   600 000003FB E90000                  	jmp 	print_string										; Call string printing routine
   601                                  
   602                                  ;========================================================================================
   603                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h.
   604                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   605                                  ;========================================================================================
   606                                  print_string:
   607 000003FE 52                      	push	dx													; Push column
   608                                  
   609 000003FF 85FF                    	test	di, di												; Check if DI is set
   610 00000401 7406                    	jz		.useDefaultColour									; If so, branch
   611                                  
   612 00000403 89F8                    	mov		ax, di												; Set colour
   613 00000405 88C3                    	mov		bl, al												; Get low byte only
   614 00000407 EB02                    	jmp		SHORT .setCursor
   615                                  
   616                                  .useDefaultColour:
   617 00000409 B307                    	mov		bl, $007											; Light gray text on black background
   618                                  
   619                                  .setCursor:
   620 0000040B B402                    	mov 	ah, $02												; Set cursor position
   621 0000040D 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   622 0000040F CD10                    	int		$10													; Set cursor
   623                                  
   624                                  .repeat:
   625 00000411 AC                      	lodsb														; Get character from string
   626 00000412 3C00                    	cmp 	al, 0
   627 00000414 7417                    	je		.done												; If char is zero, end of string
   628                                  	
   629 00000416 3C0A                    	cmp 	al, $0A												; Process newline
   630 00000418 741B                    	je		.newline
   631                                  
   632 0000041A B90100                  	mov		cx, $01												; Write one ASCII character
   633 0000041D 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   634 0000041F B409                    	mov 	ah, $09												; Write character
   635 00000421 CD10                    	int		$10													; Print character
   636                                  
   637 00000423 B402                    	mov 	ah, $02												; Set cursor position
   638 00000425 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   639 00000427 FEC2                    	inc		dl													; Increment column
   640 00000429 CD10                    	int		$10													; Set cursor
   641                                  
   642 0000042B EBE4                    	jmp		.repeat
   643                                  
   644                                  .done:
   645 0000042D 8916[8E07]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   646 00000431 5A                      	pop		dx													; Pop position
   647 00000432 31FF                    	xor		di, di												; Clear colour
   648 00000434 C3                      	ret
   649                                  
   650                                  .newline:
   651 00000435 5A                      	pop		dx													; Get original column
   652 00000436 FEC6                    	inc		dh													; Increment row
   653 00000438 52                      	push	dx													; Push it back to stack
   654 00000439 EBD6                    	jmp		.repeat
   655                                  
   656                                  ;========================================================================================
   657                                  ; Prints the character in al to the screen at the current cursor position, using the
   658                                  ; colour in di.
   659                                  ;========================================================================================
   660                                  putc:
   661 0000043B 85FF                    	test	di, di												; Check if DI is set
   662 0000043D 7406                    	jz		.useDefaultColour									; If so, branch
   663                                  
   664 0000043F 89F8                    	mov		ax, di												; Set colour
   665 00000441 88C3                    	mov		bl, al												; Get low byte only
   666 00000443 EB02                    	jmp		SHORT .setCursor
   667                                  
   668                                  .useDefaultColour:
   669 00000445 B307                    	mov		bl, $007											; Light gray text on black background
   670                                  
   671                                  .setCursor:
   672 00000447 8B16[8E07]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   673 0000044B B402                    	mov 	ah, $02												; Set cursor position
   674 0000044D B700                    	mov		bh, $0												; Video page 0
   675 0000044F CD10                    	int		$10													; Set cursor
   676                                  
   677 00000451 B90100                  	mov		cx, $01												; Write one ASCII character
   678 00000454 B700                    	mov		bh, $0												; Video page 0
   679 00000456 B409                    	mov 	ah, $09												; Write character
   680 00000458 CD10                    	int		$10													; Print character
   681                                  
   682 0000045A FEC2                    	inc		dl													; Increment column
   683                                  
   684 0000045C B402                    	mov 	ah, $02												; Set cursor position
   685 0000045E B700                    	mov		bh, $0												; Video page 0
   686 00000460 CD10                    	int		$10													; Set cursor
   687                                  
   688 00000462 8916[8E07]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   689 00000466 31FF                    	xor		di, di												; Clear colour
   690 00000468 C3                      	ret
   691                                  
   692                                  ;========================================================================================
   693                                  ; Prints the value in eax to the screen.
   694                                  ;========================================================================================
   695                                  hex_to_ascii:
   696 00000469 31C9                    	xor 	cx, cx
   697                                  
   698 0000046B 88E1                    	mov 	cl, ah												; Move high byte of ax to cl
   699 0000046D E81000                  	call 	.nibble_high										; Print low nibble to ASCII
   700 00000470 88E1                    	mov 	cl, ah
   701 00000472 E81100                  	call 	.nibble_low
   702 00000475 88C1                    	mov 	cl, al
   703 00000477 E80600                  	call 	.nibble_high
   704 0000047A 88C1                    	mov 	cl, al
   705 0000047C E80700                  	call 	.nibble_low
   706 0000047F C3                      	ret
   707                                  
   708                                  .nibble_high:
   709 00000480 C0E904                  	shr 	cl, $04
   710 00000483 E90600                  	jmp 	.convert_check
   711                                  
   712                                  .nibble_low:
   713 00000486 80E10F                  	and 	cl, $0F
   714 00000489 E90000                  	jmp 	.convert_check
   715                                  
   716                                  .convert_check:
   717 0000048C 80F90A                  	cmp 	cl, $0A
   718 0000048F 7D0B                    	jge 	.letter
   719 00000491 80C130                  	add 	cl, $30
   720 00000494 50                      	push 	ax
   721 00000495 88C8                    	mov 	al, cl
   722 00000497 E8A1FF                  	call 	putc
   723 0000049A 58                      	pop 	ax
   724 0000049B C3                      	ret
   725                                  
   726                                  .letter:
   727 0000049C 80C137                  	add 	cl, $37
   728 0000049F 50                      	push	ax
   729 000004A0 88C8                    	mov 	al, cl
   730 000004A2 E896FF                  	call	putc
   731 000004A5 58                      	pop 	ax
   732 000004A6 C3                      	ret
   733                                  
   734                                  ;========================================================================================
   735                                  ; Uses BIOS INT $15, EAX $E820 function to get the memory map of the system
   736                                  ; input: 	es:di = destination buffer for 24 byte entries
   737                                  ; output: 	bp = entry count, trashes all registers except esi
   738                                  ;========================================================================================
   739                                  fetch_mem_map:
   740 000004A7 6631DB                  	xor		ebx, ebx											; Clear EBX
   741 000004AA 31ED                    	xor		bp, bp												; Use BP as an entry count
   742 000004AC 66BA50414D53            	mov		edx, $0534D4150										; Place "SMAP" into edx (magic value)
   743 000004B2 66B820E80000            	mov		eax, $0E820											; Function call
   744                                  
   745 000004B8 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   746 000004C1 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   747 000004C7 CD15                    	int		$15
   748                                  
   749 000004C9 7257                    	jc		SHORT .error										; If carry set, the function is unsupported
   750                                  
   751 000004CB 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   752 000004D1 6639D0                  	cmp		eax, edx											; On success, EAX = "SMAP"
   753 000004D4 754C                    	jne		SHORT .error
   754                                  
   755 000004D6 6685DB                  	test	ebx, ebx											; ebx = 0 implies list is only 1 entry long (worthless)
   756 000004D9 7447                    	je		SHORT .error
   757                                  
   758 000004DB EB1F                    	jmp		SHORT .startLoop									; Jump into the loop
   759                                  
   760                                  .getEntryLoop:
   761 000004DD 66B820E80000            	mov		eax, $0E820											; Reset command (EAX, ECX are trashed)
   762 000004E3 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   763 000004EC 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   764 000004F2 CD15                    	int		$15
   765                                  
   766 000004F4 722A                    	jc		SHORT .done											; If carry set, we are done
   767 000004F6 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   768                                  
   769                                  .startLoop:
   770 000004FC E31D                    	jcxz	.skipEntry											; Skip any 0 length entries
   771                                  
   772 000004FE 80F914                  	cmp		cl, 20												; Did we get 24-byte ACPI 3.x data?
   773 00000501 7607                    	jbe		SHORT .notext
   774                                  
   775 00000503 26F6451401              	test	BYTE [es:di+20], 1									; If so, is the "ignore this data" bit clear?
   776 00000508 7411                    	je		SHORT .skipEntry
   777                                  
   778                                  .notext:
   779 0000050A 26668B4D08              	mov		ecx, [es:di+8]										; get lower dword of memory region length
   780 0000050F 26660B4D0C              	or		ecx, [es:di+12]										; Check if zero (OR with upper dword)
   781 00000514 7405                    	jz		.skipEntry											; If length qword is 0, skip entry
   782                                  
   783 00000516 45                      	inc		bp													; We got a good entry, increment count, go to next entry
   784                                  
   785 00000517 81C71800                	add		di, 24
   786                                  
   787                                  .skipEntry:
   788 0000051B 6685DB                  	test	ebx, ebx											; If EBX = 0, then the BIOS has given us all entries
   789 0000051E 75BD                    	jne		SHORT .getEntryLoop
   790                                  
   791                                  .done:
   792 00000520 F8                      	clc															; There is "jc" on end of list to this point, so the carry must be cleared
   793 00000521 C3                      	ret
   794                                  
   795                                  .error:
   796 00000522 F9                      	stc															; Set carry if this BIOS sucks ass and doesn't support this
   797 00000523 C3                      	ret
   798                                  
   799                                  ;========================================================================================
   800                                  ; Writes a register dump to the VGA hardware
   801                                  ;========================================================================================
   802                                  VGA_MISC_WRITE		EQU	$3C2
   803                                  VGA_SEQ_INDEX		EQU	$3C4
   804                                  VGA_SEQ_DATA		EQU	$3C5
   805                                  VGA_CRTC_INDEX		EQU	$3D4
   806                                  VGA_CRTC_DATA		EQU	$3D5
   807                                  VGA_INSTAT_READ		EQU	$3DA
   808                                  
   809                                  NUM_SEQ_REGS		EQU	5
   810                                  NUM_CRTC_REGS		EQU	25
   811                                  
   812                                  write_regs:
   813 00000524 56                      	push 	si
   814 00000525 52                      	push 	dx
   815 00000526 51                      	push 	cx
   816 00000527 50                      	push 	ax
   817 00000528 FC                      	cld
   818                                  
   819                                  ; write MISC register
   820 00000529 BAC203                  	mov 	dx, VGA_MISC_WRITE
   821 0000052C AC                      	lodsb
   822 0000052D EE                      	out 	dx, al
   823                                  
   824                                  ; write SEQuencer registers
   825 0000052E B90500                  	mov 	cx, NUM_SEQ_REGS
   826 00000531 30E4                    	xor 	ah, ah
   827                                  
   828                                  write_seq:
   829 00000533 BAC403                  	mov 	dx, VGA_SEQ_INDEX
   830 00000536 88E0                    	mov 	al, ah
   831 00000538 EE                      	out 	dx, al
   832                                  
   833 00000539 BAC503                  	mov 	dx, VGA_SEQ_DATA
   834 0000053C AC                      	lodsb
   835 0000053D EE                      	out 	dx, al
   836                                  
   837 0000053E FEC4                    	inc 	ah
   838 00000540 E2F1                    	loop 	write_seq
   839                                  
   840                                  ; write CRTC registers
   841                                  ; Unlock CRTC registers: enable writes to CRTC regs 0-7
   842 00000542 BAD403                  	mov 	dx, VGA_CRTC_INDEX
   843 00000545 B011                    	mov 	al, 17
   844 00000547 EE                      	out 	dx, al
   845                                  
   846 00000548 BAD503                  	mov 	dx, VGA_CRTC_DATA
   847 0000054B EC                      	in		al, dx
   848 0000054C 247F                    	and 	al, $7F
   849 0000054E EE                      	out 	dx, al
   850                                  
   851                                  ; Unlock CRTC registers: enable access to vertical retrace regs
   852 0000054F BAD403                  	mov 	dx, VGA_CRTC_INDEX
   853 00000552 B003                    	mov 	al, 3
   854 00000554 EE                      	out 	dx, al
   855                                  
   856 00000555 BAD503                  	mov 	dx ,VGA_CRTC_DATA
   857 00000558 EC                      	in		al, dx
   858 00000559 0C80                    	or		al, $80
   859 0000055B EE                      	out		dx, al
   860                                  
   861                                  ; make sure CRTC registers remain unlocked
   862 0000055C 8A4411                  	mov		al,[si + 17]
   863 0000055F 247F                    	and 	al, $7F
   864 00000561 884411                  	mov 	[si + 17],al
   865                                  
   866 00000564 8A4403                  	mov 	al,[si + 3]
   867 00000567 0C80                    	or		al, $80
   868 00000569 884403                  	mov 	[si + 3], al
   869                                  
   870                                  ; now, finally, write them
   871 0000056C B91900                  	mov 	cx, NUM_CRTC_REGS
   872 0000056F B400                    	mov 	ah, 0
   873                                  
   874                                  write_crtc:
   875 00000571 BAD403                  	mov 	dx, VGA_CRTC_INDEX
   876 00000574 88E0                    	mov 	al, ah
   877 00000576 EE                      	out 	dx, al
   878                                  
   879 00000577 BAD503                  	mov 	dx, VGA_CRTC_DATA
   880 0000057A AC                      	lodsb
   881 0000057B EE                      	out 	dx, al
   882                                  
   883 0000057C FEC4                    	inc 	ah
   884 0000057E E2F1                    	loop write_crtc
   885                                  
   886 00000580 58                      	pop 	ax
   887 00000581 59                      	pop 	cx
   888 00000582 5A                      	pop 	dx
   889 00000583 5E                      	pop 	si
   890 00000584 C3                      	ret
   891                                  
   892                                  ;	align	32
   893                                  ;fat_loader_entry:
   894                                  ;	incbin		"./loader_c.bin"
   895                                  
   896                                  ;========================================================================================
   897                                  ; DATA SECTION
   898                                  ;========================================================================================
   899                                  regs_90x60:
   900                                  ; MISC
   901 00000585 E7                      	db	0E7h
   902                                  ; SEQuencer
   903 00000586 0301030002              	db	03h, 01h, 03h, 00h, 02h
   904                                  ; CRTC
   905 0000058B 6B595A82608D0B3E        	db	6Bh, 59h,  5Ah, 82h, 60h,  8Dh, 0Bh,  3Eh,
   906 00000593 0047060700000000        	db	00h, 47h,  06h, 07h, 00h,  00h, 00h,  00h,
   907 0000059B EA0CDF2D08E805A3        	db	0EAh, 0Ch, 0DFh, 2Dh, 08h, 0E8h, 05h, 0A3h,
   908 000005A3 FF                      	db 	0FFh
   909                                  ; GC (no)
   910                                  ; AC (no)
   911                                  
   912                                  str_stage2loaded:
   913 000005A4 537461676520322042-     	db 	'Stage 2 Bootloader (boot2)', 0
   914 000005AD 6F6F746C6F61646572-
   915 000005B6 2028626F6F74322900 
   916                                  
   917                                  str_errorDetectMem:
   918 000005BF 4572726F7220726574-     	db 	"Error retrieving BIOS memory map!", 0
   919 000005C8 72696576696E672042-
   920 000005D1 494F53206D656D6F72-
   921 000005DA 79206D61702100     
   922                                  
   923                                  str_floppyError:
   924 000005E1 466C6F707079204572-     	db 	"Floppy Error, press any key to retry", $0A, 0
   925 000005EA 726F722C2070726573-
   926 000005F3 7320616E79206B6579-
   927 000005FC 20746F207265747279-
   928 00000605 0A00               
   929                                  
   930                                  str_available_lomem:
   931 00000607 436F6E74696E756F75-     	db 	"Continuous 01K blocks below 0x01000000: 0x", 0
   932 00000610 732030314B20626C6F-
   933 00000619 636B732062656C6F77-
   934 00000622 203078303130303030-
   935 0000062B 30303A20307800     
   936                                  
   937                                  str_available_himem:
   938 00000632 436F6E74696E756F75-     	db 	"Continuous 64K blocks above 0x01000000: 0x", 0
   939 0000063B 732036344B20626C6F-
   940 00000644 636B732061626F7665-
   941 0000064D 203078303130303030-
   942 00000656 30303A20307800     
   943                                  
   944                                  str_select_partition:
   945 0000065D 557365207468652063-     	db 	"Use the cursor to select the partition to boot from.", 0
   946 00000666 7572736F7220746F20-
   947 0000066F 73656C656374207468-
   948 00000678 652070617274697469-
   949 00000681 6F6E20746F20626F6F-
   950 0000068A 742066726F6D2E00   
   951                                  
   952                                  str_err_not_bootable:
   953 00000692 546869732070617274-     	db 	"This partition is not marked as bootable!", 0
   954 0000069B 6974696F6E20697320-
   955 000006A4 6E6F74206D61726B65-
   956 000006AD 6420617320626F6F74-
   957 000006B6 61626C652100       
   958                                  
   959                                  str_err_kern_not_found:
   960 000006BC 436F756C64206E6F74-     	db	"Could not find KERNEL.BIN at the root of the drive!", 0
   961 000006C5 2066696E64204B4552-
   962 000006CE 4E454C2E42494E2061-
   963 000006D7 742074686520726F6F-
   964 000006E0 74206F662074686520-
   965 000006E9 64726976652100     
   966                                  
   967                                  str_err_clear_err:
   968 000006F0 20<rept>                	times	0x40 db 0x20
   969 00000730 00                      	db	0
   970                                  
   971                                  
   972                                  str_kernel_loading:
   973 00000731 4C6F6164696E67206B-     	db 	"Loading kernel: ", 0
   974 0000073A 65726E656C3A2000   
   975                                  
   976                                  str_kernel_loaded_ok:
   977 00000742 4B65726E656C206C6F-     	db 	"Kernel loaded. Transferring control now...", 0
   978 0000074B 616465642E20547261-
   979 00000754 6E7366657272696E67-
   980 0000075D 20636F6E74726F6C20-
   981 00000766 6E6F772E2E2E00     
   982                                  
   983                                  str_err_loadkernel:
   984 0000076D 436F756C64206E6F74-     	db 	"Could not load kernel: Fuck you", 0
   985 00000776 206C6F6164206B6572-
   986 0000077F 6E656C3A204675636B-
   987 00000788 20796F7500         
   988                                  
   989                                  BootDevice:
   990 0000078D 00                      	db	0
   991                                  
   992                                  LastCursorPosition:
   993 0000078E 0000                    	dw	0
   994                                  
   995                                  MemBlocksAbove16M:
   996 00000790 0000                    	dw	0
   997                                  
   998                                  MemBlocksBelow16M:
   999 00000792 0000                    	dw	0
  1000                                  
  1001                                  MemMap_NumEntries:
  1002 00000794 0000                    	dw	0
  1003                                  
  1004                                  HDD_BootablePartitions:
  1005 00000796 00000000                	dd	0
  1006                                  
  1007                                  HDD_BootablePartitionsFATType:
  1008 0000079A 00000000                	dd	0
  1009                                  
  1010                                  HDD_Selected:
  1011 0000079E 00                      	db	0
  1012                                  
  1013                                  HDD_PartitionNames:
  1014 0000079F 00<rept>                	times	(0xB+1)*4 db 0
  1015                                  
  1016                                  Temp_StrBuf:
  1017 000007CF 00<rept>                	times	0x20 db 0
  1018                                  
  1019 000007EF 90                      	align 2
  1020                                  ExtendedRead_Table:
  1021 000007F0 10                      	db	$10
  1022 000007F1 00                      	db	0
  1023 000007F2 0000                    	dw	0														; Num blocks
  1024 000007F4 0000                    	dw	0														; Dest
  1025 000007F6 0000                    	dw	0														; Memory page
  1026 000007F8 00000000                	dd	0														; Starting LBA
  1027 000007FC 00000000                	dd	0	
  1028                                  
  1029                                  kernel_cluster:
  1030 00000800 00000000                	dd	0
  1031                                  
  1032                                  kernel_filename:
  1033 00000804 4B45524E454C202042-     	db	"KERNEL  BIN", 0
  1034 0000080D 494E00             
  1035                                  
  1036                                  ;========================================================================================
  1037                                  ; Global Descriptor Table
  1038                                  ;========================================================================================
  1039                                  	align	$10
  1040                                  
  1041                                  gdt_start:
  1042 00000810 0000000000000000        	dd	$00, $00												; Null Descriptor
  1043                                  
  1044                                  	; Code segment
  1045 00000818 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
  1046 0000081A 0000                    	dw	$0000													; Base 0:15 = $0000
  1047 0000081C 00                      	db	$00														; Base 16:23 = $00
  1048 0000081D 9A                      	db	$9A														; Access byte: Present, ring 0, Exec, grow up, R/W
  1049 0000081E CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
  1050 0000081F 00                      	db	$00														; Base 24:31 = $00
  1051                                  
  1052                                  	; Data segment
  1053 00000820 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
  1054 00000822 0000                    	dw	$0000													; Base 0:15 = $0000
  1055 00000824 00                      	db	$00														; Base 16:23 = $00
  1056 00000825 92                      	db	$92														; Access byte: Present, ring 0, Not exec, grow up, R/W
  1057 00000826 CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
  1058 00000827 00                      	db	$00														; Base 24:31 = $00	
  1059                                  
  1060                                  gdt_table:
  1061 00000828 1700                    	dw	(gdt_table-gdt_start)-1									; Length
  1062 0000082A [10080000]              	dd	gdt_start												; Physical address to GDT	
  1063                                  
  1064 0000082E 90<rept>                	align 4														; DWORD align
  1065                                  	%include	"./fat.asm"
  1066                              <1> ;========================================================================================
  1067                              <1> ; FAT Filesystem Library v 0.1
  1068                              <1> ; By Tristan Seifert
  1069                              <1> ;
  1070                              <1> ; All sector values returned by functions are "logical," i.e. they are relative to the
  1071                              <1> ; first sector of the filesystem.
  1072                              <1> ;
  1073                              <1> ; In addition, this library does not offer full support for FAT12 due to the uncommonality
  1074                              <1> ; of it on media besides floppy disks.
  1075                              <1> ;========================================================================================
  1076                              <1> ; Equates
  1077                              <1> ;========================================================================================
  1078                              <1> 
  1079                              <1> ;========================================================================================
  1080                              <1> ; Initialises the FAT filesystem library
  1081                              <1> ;========================================================================================
  1082                              <1> FAT_Init:
  1083 00000830 B90001              <1> 	mov		cx, (1024/4)										; Clear 2 sectors worth
  1084 00000833 66BA[C00B0000]      <1> 	mov		edx, FAT_ReadBuffer									; Pointer to buffer
  1085 00000839 6631C0              <1> 	xor		eax, eax											; Clear value ($00000000)
  1086                              <1> 
  1087                              <1> .clearLoop:
  1088 0000083C 66678902            <1> 	mov		DWORD [edx], eax									; Clear a DWORD
  1089 00000840 6681C204000000      <1> 	add		edx, $04											; Increment pointer
  1090 00000847 E2F3                <1> 	loop	.clearLoop											; Loop
  1091                              <1> 
  1092                              <1> .done:
  1093 00000849 C3                  <1> 	ret
  1094                              <1>  
  1095                              <1> ;========================================================================================
  1096                              <1> ; Determines the type of FAT, give that the first logical sector of the partition is
  1097                              <1> ; pointed to by SI, and returns the FAT bit size in AL.
  1098                              <1> ;
  1099                              <1> ; This is how Microsoft recommends we determine FAT type:
  1100                              <1> ;
  1101                              <1> ; RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytesPerSec - 1)) / BPB_BytesPerSec
  1102                              <1> ; DataSectors = Total Sectors - (BPB_ReservedSectors + (BPB_NumFATs * FATSz) + RootDirSectors)
  1103                              <1> ; Count of clusters = DataSectors/BPB_SectorsPerCluster 
  1104                              <1> ;
  1105                              <1> ; FAT12: Total clusters < 4085
  1106                              <1> ; FAT16: Total clusters > 4085 && < 65525
  1107                              <1> ; FAT32: Total clusters > 65525
  1108                              <1> ;========================================================================================
  1109                              <1> FAT_DetermineType:
  1110 0000084A 60                  <1> 	pusha														; Push registers
  1111                              <1> 
  1112 0000084B E8EF00              <1> 	call	FAT_ReadBPB											; 
  1113                              <1> 
  1114                              <1> 	; Calculate RootDirSectors
  1115 0000084E 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1116 00000851 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1117 00000854 8B1E[7E0B]          <1> 	mov		bx,	WORD [FAT_BPB_RootEntCnt]						; Read root entries 
  1118 00000858 66C1E305            <1> 	shl		ebx, 5												; Each root entry is 32 bytes
  1119                              <1> 
  1120 0000085C A1[6C0B]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1121 0000085F 48                  <1> 	dec		ax													; Subtract one
  1122 00000860 6601D8              <1> 	add		eax, ebx											; Add root entry length to sector length
  1123                              <1> 
  1124 00000863 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1125 00000866 8B0E[6C0B]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1126 0000086A F7F1                <1> 	div		cx													; Divide by sector length (result = ax)
  1127 0000086C A3[880B]            <1> 	mov		WORD [FAT_RootDirSectors], ax						; Store result in memory
  1128                              <1> 
  1129                              <1> 	; Calculate number of data sectors
  1130 0000086F 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1131 00000872 A0[7C0B]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1132                              <1> 
  1133 00000875 668B0E[800B]        <1> 	mov		ecx, DWORD [FAT_BPB_FATSz]							; Read FAT size
  1134 0000087A 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in eax
  1135                              <1> 
  1136 0000087D 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1137 00000880 8B0E[7A0B]          <1> 	mov		cx, WORD [FAT_BPB_ReservedSectors]					; Read number of reserved sectors
  1138                              <1> 
  1139 00000884 6601C8              <1> 	add		eax, ecx											; Add count of reserved sectors to FAT size
  1140 00000887 668B0E[880B]        <1> 	mov		ecx, DWORD [FAT_RootDirSectors]						; Read RootDirSectors
  1141 0000088C 6601C8              <1> 	add		eax, ecx											; Add root directory sectors
  1142                              <1> 
  1143 0000088F 6691                <1> 	xchg	eax, ecx											; Subtract all of the above from total sectors
  1144                              <1> 
  1145 00000891 66A1[840B]          <1> 	mov		eax, DWORD [FAT_BPB_TotSec]							; Read total sector count
  1146 00000895 6629C8              <1> 	sub		eax, ecx											; Subtract from total sector count
  1147                              <1> 
  1148 00000898 66A3[8C0B]          <1> 	mov		DWORD [FAT_DataSectors], eax						; Store to memory
  1149                              <1> 
  1150                              <1> 	; Calculate cluster count
  1151 0000089C 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1152 0000089F 8A1E[780B]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1153 000008A3 66A1[8C0B]          <1> 	mov		eax, DWORD [FAT_DataSectors]						; Read number of data sectors
  1154 000008A7 66F7F3              <1> 	div		ebx													; Divide by sectors/cluster value 
  1155                              <1> 
  1156 000008AA 66A3[980B]          <1> 	mov		DWORD [FAT_TotalClusters], eax						; Store result in EAX
  1157                              <1> 
  1158                              <1> 	; Now, do some comparisons!
  1159 000008AE 663DF50F0000        <1> 	cmp		eax, 4085											; Is the FS FAT12?
  1160 000008B4 7F07                <1> 	jg		.notFAT12											; If not, branch
  1161                              <1> 
  1162 000008B6 C606[A00B]0C        <1> 	mov		BYTE [FAT_Type], 12									; FAT12
  1163 000008BB EB17                <1> 	jmp		SHORT .done											; Return
  1164                              <1> 
  1165                              <1> .notFAT12:
  1166 000008BD 663DF5FF0000        <1> 	cmp		eax, 65525											; Is the FS FAT16?
  1167 000008C3 7F0A                <1> 	jg		.notFAT16											; If not, branch
  1168                              <1> 
  1169 000008C5 E84C00              <1> 	call	FAT16_Calculate_RootDirSec							; Calculate location of root directory
  1170                              <1> 
  1171 000008C8 C606[A00B]10        <1> 	mov		BYTE [FAT_Type], 16									; FAT16
  1172 000008CD EB05                <1> 	jmp		SHORT .done											; Return
  1173                              <1> 
  1174                              <1> .notFAT16:
  1175                              <1> 	; Okay, if we get down here, it HAS to be FAT32 or a corrupt FS
  1176 000008CF C606[A00B]20        <1> 	mov		BYTE [FAT_Type], 32									; FAT32
  1177                              <1> 
  1178                              <1> .done:
  1179 000008D4 E80500              <1> 	call	FAT_Calculate_Misc									; Calculate miscellaneous stuff
  1180 000008D7 61                  <1> 	popa														; Restore registers
  1181                              <1> 
  1182 000008D8 A0[A00B]            <1> 	mov		al, BYTE [FAT_Type]									; Store FAT type in AL
  1183                              <1> 
  1184 000008DB C3                  <1> 	ret
  1185                              <1> 
  1186                              <1> ;========================================================================================
  1187                              <1> ; Calculates miscellaneous values that the FAT driver uses later
  1188                              <1> ;========================================================================================
  1189                              <1> FAT_Calculate_Misc:
  1190 000008DC 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1191 000008DF 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1192 000008E2 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1193                              <1> 
  1194 000008E5 8B0E[880B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1195 000008E9 8B1E[7A0B]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1196                              <1> 
  1197 000008ED 6601CB              <1> 	add		ebx, ecx											; Add to root dir sectors reserved sectors
  1198                              <1> 
  1199 000008F0 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1200 000008F3 8A0E[7C0B]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1201 000008F7 66A1[800B]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1202 000008FB 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1203                              <1> 
  1204 000008FE 6601D8              <1> 	add		eax, ebx											; Add FAT sectors to root dir and reserved count
  1205                              <1> 
  1206 00000901 66A3[900B]          <1> 	mov		DWORD [FAT_FirstDataSector], eax					; Store first data sector
  1207                              <1> 
  1208 00000905 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1209 00000908 8B0E[880B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1210 0000090C 6629C8              <1> 	sub		eax, ecx											; Subtract ecx
  1211 0000090F 66A3[940B]          <1> 	mov		DWORD [FAT_FirstClusterLocation], eax				; Write shaften
  1212 00000913 C3                  <1> 	ret
  1213                              <1> 
  1214                              <1> ;========================================================================================
  1215                              <1> ; Calculates the sector for the root directory for FAT12 and FAT16.
  1216                              <1> ;========================================================================================
  1217                              <1> FAT16_Calculate_RootDirSec:
  1218 00000914 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1219 00000917 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1220 0000091A 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1221                              <1> 
  1222 0000091D 8B1E[7A0B]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1223                              <1> 
  1224 00000921 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1225 00000924 A0[7C0B]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1226                              <1> 
  1227 00000927 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1228 0000092A 8A0E[7C0B]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1229 0000092E 66A1[800B]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1230 00000932 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1231                              <1> 
  1232 00000935 6601D8              <1> 	add		eax, ebx											; Add reserved sector count
  1233                              <1> 
  1234 00000938 66A3[740B]          <1> 	mov		DWORD [FAT_BPB_RootClus], eax						; Write location of root cluster
  1235                              <1> 
  1236                              <1> .done:
  1237 0000093C C3                  <1> 	ret
  1238                              <1> 
  1239                              <1> ;========================================================================================
  1240                              <1> ; Reads the BPB from the FAT 1st sector in SI.
  1241                              <1> ;========================================================================================
  1242                              <1> FAT_ReadBPB:
  1243 0000093D 8B440B              <1> 	mov		ax, WORD [si+11]									; Read Bytes/sector
  1244 00000940 A3[6C0B]            <1> 	mov		WORD [FAT_BPB_BytesPerSec], ax						; ""
  1245                              <1> 
  1246 00000943 8A440D              <1> 	mov		al, BYTE [si+13]									; Read sectors/cluster
  1247 00000946 A2[780B]            <1> 	mov		BYTE [FAT_BPB_SectorsPerCluster], al				; ""
  1248                              <1> 
  1249 00000949 8B440E              <1> 	mov		ax, WORD [si+14]									; Read reserved sectors
  1250 0000094C A3[7A0B]            <1> 	mov		WORD [FAT_BPB_ReservedSectors], ax					; ""
  1251                              <1> 
  1252 0000094F 8A4410              <1> 	mov		al, BYTE [si+16]									; Read number of FATs
  1253 00000952 A2[7C0B]            <1> 	mov		BYTE [FAT_BPB_NumFATs], al							; ""
  1254                              <1> 
  1255 00000955 8B4411              <1> 	mov		ax, WORD [si+17]									; Read num root entries
  1256 00000958 A3[7E0B]            <1> 	mov		WORD [FAT_BPB_RootEntCnt], ax						; ""
  1257                              <1> 
  1258 0000095B 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1259                              <1> 
  1260 0000095E 668B4420            <1> 	mov		eax, DWORD [si+32]									; Read BPB_TotSec32 first
  1261 00000962 663D00000000        <1> 	cmp		eax, 0												; Is EAX zero?
  1262 00000968 7503                <1> 	jne		.writeTotSec										; If not, branch
  1263                              <1> 
  1264 0000096A 8B4413              <1> 	mov		ax, WORD [si+19]									; Read BPB_TotSec16 first
  1265                              <1> 
  1266                              <1> .writeTotSec:
  1267 0000096D 66A3[840B]          <1> 	mov		DWORD [FAT_BPB_TotSec], eax							; ""
  1268                              <1> 
  1269 00000971 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1270                              <1> 
  1271 00000974 8B4416              <1> 	mov		ax, WORD [si+22]									; Read BPB_FATSz16
  1272 00000977 3D0000              <1> 	cmp		ax, 0												; Is it zero?
  1273 0000097A 7507                <1> 	jne		.writeFATSz											; If not, branch.
  1274                              <1> 
  1275 0000097C 668B4424            <1> 	mov		eax, DWORD [si+36]									; Read BPB_FATSz32
  1276                              <1> 
  1277 00000980 E80500              <1> 	call	.readFAT32Specifics									; Read FAT32-specific data
  1278                              <1> 
  1279                              <1> .writeFATSz:
  1280 00000983 66A3[800B]          <1> 	mov		DWORD [FAT_BPB_FATSz], eax							; Write FAT size
  1281                              <1> 
  1282 00000987 C3                  <1> 	ret
  1283                              <1> 
  1284                              <1> ; All FAT32-specific stuff is read here
  1285                              <1> .readFAT32Specifics:
  1286 00000988 8B5C28              <1> 	mov		bx, WORD [si+40]									; Read BPB_ExtFlags
  1287 0000098B 891E[700B]          <1> 	mov		WORD [FAT_BPB_ExtFlags], bx							; Write BPB_ExtFlags
  1288                              <1> 
  1289 0000098F 8B5C2A              <1> 	mov		bx, WORD [si+42]									; Read BPB_FSVer
  1290 00000992 891E[720B]          <1> 	mov		WORD [FAT_BPB_FSVer], bx							; Write BPB_FSVer
  1291                              <1> 
  1292 00000996 668B5C2C            <1> 	mov		ebx, DWORD [si+44]									; Read BPB_RootClus
  1293 0000099A 66891E[740B]        <1> 	mov		DWORD [FAT_BPB_RootClus], ebx						; Write BPB_RootClus
  1294                              <1> 
  1295 0000099F 8B5C30              <1> 	mov		bx, WORD [si+48]									; Read BPB_FSInfo
  1296 000009A2 891E[6E0B]          <1> 	mov		WORD [FAT_BPB_FSInfo], bx							; Write BPB_FSInfo
  1297                              <1> 
  1298                              <1> 
  1299 000009A6 C3                  <1> 	ret
  1300                              <1> 
  1301                              <1> ;========================================================================================
  1302                              <1> ; Calculates the entry location for cluster N in the FAT.
  1303                              <1> ; eax: Cluster number
  1304                              <1> ; eax: Sector number containing the cluster
  1305                              <1> ; ebx: Offset in sector
  1306                              <1> ;========================================================================================
  1307                              <1> FAT_FindClusterInTable:
  1308 000009A7 60                  <1> 	pusha														; Back up regs
  1309                              <1> 
  1310 000009A8 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1311 000009AB 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1312                              <1> 
  1313 000009AE 8A1E[A00B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1314 000009B2 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1315 000009B5 7406                <1> 	je		.FAT32												; If so, jump
  1316                              <1> 
  1317 000009B7 66D1E0              <1> 	shl		eax, 1												; Multiply cluster by 2
  1318 000009BA E90400              <1> 	jmp		.cont												; Skip over shift below
  1319                              <1> 
  1320                              <1> .FAT32:
  1321 000009BD 66C1E002            <1> 	shl		eax, 2												; Multiply cluster by 4
  1322                              <1> 
  1323                              <1> .cont:
  1324                              <1> 	; eax = Offset into FAT table
  1325                              <1> 
  1326 000009C1 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1327 000009C4 8B0E[6C0B]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1328 000009C8 66F7F1              <1> 	div		ecx													; Divide offset by bytes/sector
  1329                              <1> 	; eax = quotient, edx = remainder
  1330                              <1> 
  1331 000009CB 8B1E[7A0B]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; BX = reserved sector count
  1332 000009CF 6601D8              <1> 	add		eax, ebx											; Add to FAT offset (sectors)
  1333                              <1> 
  1334 000009D2 66A3[E709]          <1> 	mov		DWORD [.secNum], eax								; Store sector number
  1335 000009D6 8916[EB09]          <1> 	mov		WORD [.secOff], dx									; Store offset into sector
  1336                              <1> 
  1337                              <1> .done:
  1338 000009DA 61                  <1> 	popa														; Restore regs
  1339                              <1> 
  1340 000009DB 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1341 000009DE 66A1[E709]          <1> 	mov		eax, DWORD [.secNum]								; Get sector number
  1342 000009E2 8B1E[EB09]          <1> 	mov		bx, WORD [.secOff]									; Get offset into sector
  1343                              <1> 
  1344 000009E6 C3                  <1> 	ret
  1345                              <1> 
  1346                              <1> .secNum:
  1347 000009E7 00000000            <1> 	dd		0
  1348                              <1> 
  1349                              <1> .secOff:
  1350 000009EB 0000                <1> 	dw		0
  1351                              <1> 
  1352                              <1> ;========================================================================================
  1353                              <1> ; Converts the cluster number in eax into a sector number.
  1354                              <1> ;========================================================================================
  1355                              <1> FAT_ClusterToSector:
  1356 000009ED 6651                <1> 	push	ecx													; Back up EBX
  1357                              <1> 
  1358 000009EF 6648                <1> 	dec		eax													; Subtract 2 from cluster
  1359 000009F1 6648                <1> 	dec		eax													; ""
  1360                              <1> 
  1361 000009F3 6631C9              <1> 	xor		ecx, ecx											; Clear EBX
  1362 000009F6 8A0E[780B]          <1> 	mov		cl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1363 000009FA 66F7E1              <1> 	mul		ecx													; Multiply by number of sectors per cluster
  1364                              <1> 
  1365 000009FD 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1366 00000A00 8B0E[880B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Root directory sector
  1367 00000A04 6601C8              <1> 	add		eax, ecx											; Add to sector count
  1368                              <1> 
  1369 00000A07 668B0E[900B]        <1> 	mov		ecx, DWORD [FAT_FirstDataSector]					; Get first data sector
  1370 00000A0C 6601C8              <1> 	add		eax, ecx											; Add data sector offset
  1371                              <1> 
  1372 00000A0F 6659                <1> 	pop		ecx													; Restore EBX
  1373                              <1> 
  1374 00000A11 C3                  <1> 	ret
  1375                              <1> 
  1376                              <1> ;========================================================================================
  1377                              <1> ; Reads the sector containing the FAT entry for the specified cluster, then returns the
  1378                              <1> ; FAT read from the sector.
  1379                              <1> ; eax: Cluster
  1380                              <1> ; Sets carry flag if error.
  1381                              <1> ;========================================================================================
  1382                              <1> FAT_ReadFAT:
  1383 00000A12 E892FF              <1> 	call	FAT_FindClusterInTable								; Locate cluster
  1384 00000A15 6653                <1> 	push	ebx													; Push offset into sector to stack
  1385                              <1> 
  1386                              <1> 	; Read sector to memory
  1387 00000A17 E82500              <1> 	call	FAT_ReadSector										; Read sector
  1388 00000A1A 665B                <1> 	pop		ebx													; Pop offset into sector
  1389 00000A1C 721F                <1> 	jc 		SHORT .error										; If error, return
  1390                              <1> 
  1391                              <1> 	; Sector is now read to memory
  1392 00000A1E 8A1E[A00B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1393 00000A22 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1394 00000A25 740D                <1> 	je		.FAT32												; If so, jump
  1395                              <1> 
  1396 00000A27 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1397 00000A2A 678B83[C00B0000]    <1> 	mov		ax, WORD [FAT_ReadBuffer+ebx]						; Read FAT16 entry
  1398 00000A31 E90800              <1> 	jmp		.done												; Skip over read below
  1399                              <1> 
  1400                              <1> .FAT32:
  1401 00000A34 66678B83[C00B0000]  <1> 	mov		eax, DWORD [FAT_ReadBuffer+ebx]						; Read FAT32 entry
  1402                              <1> 
  1403                              <1> .done:
  1404 00000A3C C3                  <1> 	ret
  1405                              <1> 
  1406                              <1> .error:
  1407 00000A3D F9                  <1> 	stc															; Set carry
  1408 00000A3E C3                  <1> 	ret
  1409                              <1> 
  1410                              <1> ;========================================================================================
  1411                              <1> ; Reads a logical sector from the drive.
  1412                              <1> ; eax: Logical sector
  1413                              <1> ; Clears the carry flag if successful, set otherwise.
  1414                              <1> ;========================================================================================
  1415                              <1> FAT_ReadSector:
  1416 00000A3F 660306[9C0B]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1417                              <1> 
  1418 00000A44 668B1E[A40B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1419 00000A49 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1420 00000A4C 7429                <1> 	je		.done												; If they are the same sector, branch
  1421                              <1> 
  1422 00000A4E 66A3[B00B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1423 00000A52 C706[AA0B]0100      <1> 	mov		WORD [FAT_ERTable+0x02], 0x01						; Read one sector
  1424 00000A58 C706[AC0B][C00B]    <1> 	mov		WORD [FAT_ERTable+0x04], FAT_ReadBuffer				; Temporary sector buffer offset (seg 0)
  1425 00000A5E C706[AE0B]0000      <1> 	mov		WORD [FAT_ERTable+0x06], 0x00						; Page 0
  1426                              <1> 
  1427 00000A64 66A3[A40B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Store LBA we're loading
  1428                              <1> 
  1429 00000A68 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1430 00000A69 BE[A80B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1431 00000A6C B442                <1> 	mov 	ah, $42												; Extended Read
  1432 00000A6E 8A16[A10B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1433 00000A72 CD13                <1> 	int 	$13													; Perform read
  1434 00000A74 61                  <1> 	popa														; Pop registers
  1435 00000A75 7202                <1> 	jc 		SHORT .error										; If error, return
  1436                              <1> 
  1437                              <1> .done:
  1438 00000A77 F8                  <1> 	clc															; Clear carry
  1439 00000A78 C3                  <1> 	ret
  1440                              <1> 
  1441                              <1> .error:
  1442 00000A79 F9                  <1> 	stc															; Set carry
  1443 00000A7A C3                  <1> 	ret
  1444                              <1> 
  1445                              <1> ;========================================================================================
  1446                              <1> ; Tries to locate a file with the name pointed to by in esi in the root directory of the
  1447                              <1> ; FAT. If found, returns the first cluster of the file in eax, filesize in ebx, and
  1448                              <1> ; clears carry. If not found, sets carry.
  1449                              <1> ;
  1450                              <1> ; Note that this only searches the short filename.
  1451                              <1> ;========================================================================================
  1452                              <1> FAT_FindFileAtRoot:
  1453 00000A7B 60                  <1> 	pusha														; Push regs
  1454 00000A7C 66A1[740B]          <1> 	mov		eax, DWORD [FAT_BPB_RootClus]						; Read root sector location
  1455 00000A80 E86AFF              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1456 00000A83 E8B9FF              <1> 	call	FAT_ReadSector										; Read sector
  1457                              <1> 
  1458 00000A86 66BF[C00B0000]      <1> 	mov		edi, FAT_ReadBuffer									; FAT read buffer
  1459 00000A8C B91000              <1> 	mov		cx, (512/32)										; Search the first 512/32 entries
  1460                              <1> 
  1461                              <1> .searchLoop:
  1462 00000A8F 678A07              <1> 	mov		al, BYTE [edi]										; Read first byte of string
  1463                              <1> 
  1464 00000A92 3CE5                <1> 	cmp		al, $0E5											; Is directory entry free?
  1465 00000A94 7426                <1> 	je		.fileEntryIgnore									; If so, branch
  1466 00000A96 3C00                <1> 	cmp		al, $00												; Is directory entry free and last one?
  1467 00000A98 7428                <1> 	je		.notFound											; If so, exit loop.
  1468                              <1> 
  1469                              <1> 	; Store pointers
  1470 00000A9A 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1471 00000A9D 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1472 00000AA0 6689F8              <1> 	mov		eax, edi											; Copy read pointer to EAX
  1473 00000AA3 6689F2              <1> 	mov		edx, esi											; Copy filename compare ptr to EDX
  1474                              <1> 
  1475                              <1> 	; Compare filename
  1476 00000AA6 51                  <1> 	push	cx													; Push loop counter
  1477 00000AA7 B90B00              <1> 	mov		cx, $0B												; Filename is 11 bytes
  1478                              <1> 
  1479                              <1> .comparison:
  1480 00000AAA 678A18              <1> 	mov		bl, BYTE [eax]										; Read soruce ptr
  1481 00000AAD 673A1A              <1> 	cmp		bl, BYTE [edx]										; Compare against target
  1482 00000AB0 7509                <1> 	jne		.compareFailed										; If not equal, branch
  1483                              <1> 
  1484 00000AB2 6640                <1> 	inc		eax													; Increment read pointer
  1485 00000AB4 6642                <1> 	inc		edx													; Increment target pointer
  1486                              <1> 
  1487 00000AB6 E2F2                <1> 	loop	.comparison											; Compare 11 bytes
  1488                              <1> 
  1489 00000AB8 59                  <1> 	pop		cx													; Pop loop counter from stack
  1490 00000AB9 EB0A                <1> 	jmp		SHORT .found										; File was found
  1491                              <1> 
  1492                              <1> .compareFailed:
  1493 00000ABB 59                  <1> 	pop		cx													; Pop loop counter
  1494                              <1> 
  1495                              <1> .fileEntryIgnore:
  1496 00000ABC 81C72000            <1> 	add		di, $20												; Read next entry
  1497 00000AC0 E2CD                <1> 	loop	.searchLoop											; Loop through entries
  1498                              <1> 
  1499                              <1> ; Drop down here once loop finishes: file not found.
  1500                              <1> .notFound:
  1501 00000AC2 61                  <1> 	popa														; Pop registers
  1502 00000AC3 F9                  <1> 	stc															; Set carry
  1503 00000AC4 C3                  <1> 	ret
  1504                              <1> 
  1505                              <1> ; We found the file
  1506                              <1> .found:
  1507 00000AC5 678B471A            <1> 	mov		ax, WORD [edi+26]									; Read cluster low word
  1508 00000AC9 A3[E80A]            <1> 	mov		WORD [.clusterOfFile], ax							; ""
  1509 00000ACC 678B4714            <1> 	mov		ax, WORD [edi+20]									; Read cluster high word
  1510 00000AD0 A3[EA0A]            <1> 	mov		WORD [.clusterOfFile+2], ax							; ""
  1511                              <1> 
  1512 00000AD3 66678B471C          <1> 	mov		eax, DWORD [edi+28]									; Read filesize
  1513 00000AD8 66A3[EC0A]          <1> 	mov		DWORD [.sizeOfFile], eax							; ""
  1514                              <1> 
  1515 00000ADC 61                  <1> 	popa														; Pop registers
  1516 00000ADD 66A1[E80A]          <1> 	mov		eax, DWORD [.clusterOfFile]							; Read file's cluster
  1517 00000AE1 668B1E[EC0A]        <1> 	mov		ebx, DWORD [.sizeOfFile]							; Read file's size
  1518 00000AE6 F8                  <1> 	clc															; Clear carry bit
  1519 00000AE7 C3                  <1> 	ret
  1520                              <1> 
  1521                              <1> 	align	4
  1522                              <1> .clusterOfFile:
  1523 00000AE8 00000000            <1> 	dd		0
  1524                              <1> .sizeOfFile:
  1525 00000AEC 00000000            <1> 	dd		0
  1526                              <1> 
  1527                              <1> ;========================================================================================
  1528                              <1> ; Reads the file whose first cluster is in eax to es:di.
  1529                              <1> ;
  1530                              <1> ; Note that this function returns after reading a maximum of 256 chunks.
  1531                              <1> ;========================================================================================
  1532                              <1> FAT_ReadFile:
  1533 00000AF0 60                  <1> 	pusha														; Push all regisers
  1534                              <1> 
  1535 00000AF1 E80800              <1> 	call	FAT_ReadCluster										; Read cluster
  1536 00000AF4 7203                <1> 	jc 		SHORT .error										; If error, return
  1537                              <1> 
  1538                              <1> ;	xor		cx, cx												; Clear CX
  1539                              <1> ;	mov		gs, cx												; Clear GS
  1540                              <1> ;
  1541                              <1> ;.readLoop:
  1542                              <1> ;	call	FAT_ReadFAT											; Read FAT entry for current cluster
  1543                              <1> ;	and		eax, $0FFFFFFF										; Ignore high nybble
  1544                              <1> ;	cmp		eax, $0FFFFFF8										; End of chain marker?
  1545                              <1> ;	jae		.done												; If so, branch (unsigned compare)
  1546                              <1> ;
  1547                              <1> ;	call	FAT_ReadCluster										; Read cluster
  1548                              <1> ;	jc 		SHORT .error										; If error, return
  1549                              <1> ;
  1550                              <1> ;	mov		cx, gs												; Read GS
  1551                              <1> ;	inc		cx													; Increment GS
  1552                              <1> ;	mov		gs, cx												; Move back to GS
  1553                              <1> ;
  1554                              <1> ;	cmp		cl, $0FF											; Is it max? ($FF)
  1555                              <1> ;	je		.error												; If so, we're done
  1556                              <1> ;
  1557                              <1> ;	jmp		.readLoop											; Loop until all sectors of the file are read
  1558                              <1> 
  1559                              <1> .done:
  1560 00000AF6 61                  <1> 	popa														; Pop registers
  1561 00000AF7 F8                  <1> 	clc															; Clear carry
  1562 00000AF8 C3                  <1> 	ret
  1563                              <1> 
  1564                              <1> .error:
  1565 00000AF9 61                  <1> 	popa														; Pop registers
  1566 00000AFA F9                  <1> 	stc															; Set carry
  1567 00000AFB C3                  <1> 	ret
  1568                              <1> 
  1569                              <1> ;========================================================================================
  1570                              <1> ; Reads a logical sector from the drive.
  1571                              <1> ; eax: Logical cluster
  1572                              <1> ; es:di: Memory location (Incremented after read)
  1573                              <1> ; Clears the carry flag if successful, set otherwise.
  1574                              <1> ;========================================================================================
  1575                              <1> FAT_ReadCluster:
  1576 00000AFC 66A3[680B]          <1> 	mov		DWORD [.origCluster], eax							; Store original cluster
  1577 00000B00 E8EAFE              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1578                              <1> 
  1579 00000B03 660306[9C0B]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1580                              <1> 
  1581 00000B08 668B1E[A40B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1582 00000B0D 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1583 00000B10 742E                <1> 	je		.done												; If they are the same sector, branch
  1584 00000B12 66A3[A40B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Save sector we're reading
  1585                              <1> 
  1586 00000B16 31DB                <1> 	xor		bx, bx												; Clear BX
  1587 00000B18 8A1E[780B]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1588 00000B1C C706[AA0B]FF01      <1> 	mov		WORD [FAT_ERTable+0x02], $1FF							; Write sectors/cluster 
  1589 00000B22 66A3[B00B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1590 00000B26 893E[AC0B]          <1> 	mov		WORD [FAT_ERTable+0x04], di							; Offset in segment
  1591 00000B2A 8C06[AE0B]          <1> 	mov		WORD [FAT_ERTable+0x06], es							; Segment
  1592                              <1> 
  1593 00000B2E 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1594 00000B2F BE[A80B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1595 00000B32 B442                <1> 	mov 	ah, $42												; Extended Read		
  1596 00000B34 8A16[A10B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1597 00000B38 CD13                <1> 	int 	$13													; Perform read
  1598 00000B3A 61                  <1> 	popa														; Pop registers
  1599 00000B3B 7209                <1> 	jc 		SHORT .error										; If error, return
  1600                              <1> 
  1601 00000B3D E80C00              <1> 	call	.incrementReadPtr									; Increment read pointer
  1602                              <1> 
  1603                              <1> .done:	
  1604 00000B40 66A1[680B]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1605 00000B44 F8                  <1> 	clc															; Clear carry
  1606 00000B45 C3                  <1> 	ret
  1607                              <1> 
  1608                              <1> .error:
  1609 00000B46 66A1[680B]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1610 00000B4A F9                  <1> 	stc															; Set carry
  1611 00000B4B C3                  <1> 	ret
  1612                              <1> 
  1613                              <1> .incrementReadPtr:
  1614 00000B4C 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1615 00000B4F A1[6C0B]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1616 00000B52 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1617 00000B55 8A1E[780B]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read bytes per sector
  1618                              <1> 
  1619 00000B59 66F7E3              <1> 	mul		ebx													; EAX = value to add to write ptr
  1620 00000B5C 01C7                <1> 	add		di, ax												; Add cluster length to di
  1621 00000B5E 7107                <1> 	jno		.noOverflow											; If overflow bit isn't set, branch
  1622                              <1> 
  1623 00000B60 8CC0                <1> 	mov		ax, es												; Read segment we're writing to
  1624 00000B62 050010              <1> 	add		ax, $1000											; Write in next segment
  1625 00000B65 8EC0                <1> 	mov		es, ax												; Write to segment register
  1626                              <1> 
  1627                              <1> .noOverflow:
  1628 00000B67 C3                  <1> 	ret
  1629                              <1> 
  1630                              <1> 	align	4
  1631                              <1> .origCluster:
  1632 00000B68 00000000            <1> 	dd		0
  1633                              <1> 
  1634                              <1> ;========================================================================================
  1635                              <1> ; Data section
  1636                              <1> ;========================================================================================
  1637                              <1> 	align	4
  1638                              <1> FAT_BPB_BytesPerSec: ; file offset 11
  1639 00000B6C 0000                <1> 	dw		0
  1640                              <1> FAT_BPB_FSInfo: ; file offset 48, FAT32 only
  1641 00000B6E 0000                <1> 	dw		0
  1642                              <1> FAT_BPB_ExtFlags: ; file offset 40, FAT32 only
  1643 00000B70 0000                <1> 	dw		0
  1644                              <1> FAT_BPB_FSVer: ; file offset 42, FAT32 only
  1645 00000B72 0000                <1> 	dw		0
  1646                              <1> 
  1647                              <1> 	align	4
  1648                              <1> FAT_BPB_RootClus: ; file offset 44, FAT32 only
  1649 00000B74 00000000            <1> 	dd		0
  1650                              <1> FAT_BPB_SectorsPerCluster: ; file offset 13
  1651 00000B78 00                  <1> 	db		0
  1652                              <1> 
  1653 00000B79 90                  <1> 	align	2
  1654                              <1> FAT_BPB_ReservedSectors: ; file offset 14
  1655 00000B7A 0000                <1> 	dw		0
  1656                              <1> FAT_BPB_NumFATs: ; file offset 16
  1657 00000B7C 00                  <1> 	db		0
  1658                              <1> 
  1659 00000B7D 90                  <1> 	align	2
  1660                              <1> FAT_BPB_RootEntCnt:	; file offset 17
  1661 00000B7E 0000                <1> 	dw		0
  1662                              <1> 
  1663                              <1> 	align	4
  1664                              <1> FAT_BPB_FATSz: ; file offset 22 if FAT16, 36 if FAT32 and word at 22 is 0
  1665 00000B80 00000000            <1> 	dd		0
  1666                              <1> 
  1667                              <1> ; Works with FAT32
  1668                              <1> ; For the total sector count, try to read BPB_FATSz16 first (19), then the 32-bit at off 32
  1669                              <1> FAT_BPB_TotSec: ; file offset 32 if 19 = 0
  1670 00000B84 00000000            <1> 	dd		0
  1671                              <1> 
  1672                              <1> ; Calculated when identifying FS
  1673                              <1> FAT_RootDirSectors:
  1674 00000B88 0000                <1> 	dw		0
  1675                              <1> 
  1676 00000B8A 90<rept>            <1> 	align	4
  1677                              <1> FAT_DataSectors:
  1678 00000B8C 00000000            <1> 	dd		0
  1679                              <1> FAT_FirstDataSector:
  1680 00000B90 00000000            <1> 	dd		0
  1681                              <1> FAT_FirstClusterLocation:
  1682 00000B94 00000000            <1> 	dd		0
  1683                              <1> FAT_TotalClusters:
  1684 00000B98 00000000            <1> 	dd		0
  1685                              <1> 
  1686                              <1> ; Offset into drive in sectors to the start of the FAT partition
  1687                              <1> FAT_PartitionOffset:
  1688 00000B9C 00000000            <1> 	dd		0
  1689                              <1> FAT_Type:
  1690 00000BA0 00                  <1> 	db		0
  1691                              <1> 
  1692                              <1> ; BIOS drive to read from
  1693                              <1> FAT_Drive:
  1694 00000BA1 00                  <1> 	db		0
  1695                              <1> 
  1696 00000BA2 90<rept>            <1> 	align	4
  1697                              <1> FAT_LastLoadedSector:
  1698 00000BA4 00000000            <1> 	dd		0
  1699                              <1> 
  1700                              <1> 	align	4
  1701                              <1> FAT_ERTable:
  1702 00000BA8 10                  <1> 	db	$10
  1703 00000BA9 00                  <1> 	db	0
  1704 00000BAA 0000                <1> 	dw	0														; Num blocks
  1705 00000BAC 0000                <1> 	dw	0														; Dest
  1706 00000BAE 0000                <1> 	dw	0														; Memory page
  1707 00000BB0 00000000            <1> 	dd	0														; Starting LBA
  1708 00000BB4 00000000            <1> 	dd	0	
  1709                              <1> 
  1710 00000BB8 90<rept>            <1> 	align	$10
  1711                              <1> FAT_ReadBuffer:
  1712                                  
  1713                                  SectorBuf:
  1714 00000BC0 00<rept>                	times	512 db 0

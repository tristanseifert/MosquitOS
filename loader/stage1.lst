     1                                  	BITS	16
     2                                  
     3                                  ; Size of second stage loader, in sectors
     4                                  stage2_len:		EQU $2F
     5                                  ; Start of second stage loader on disk, in sectors
     6                                  stage2_start:	EQU $02
     7                                  ; Segment to load second stage to (Physical address $00500)
     8                                  stage2_seg:		EQU $0000
     9                                  stage2_off:		EQU $0500
    10                                  
    11                                  loader_start:
    12 00000000 B8C007                  	mov		ax, $07C0											; Set up 4K stack space after this bootloader
    13 00000003 052001                  	add 	ax, 288												; (4096 + 512) / 16 bytes per frame
    14 00000006 8ED0                    	mov 	ss, ax
    15 00000008 BC0010                  	mov 	sp, 4096											; Set up SP
    16                                  
    17 0000000B B8C007                  	mov 	ax, $07C0											; Set data segment to where we're loaded
    18 0000000E 8ED8                    	mov 	ds, ax
    19                                  
    20 00000010 B280                    	mov		dl, $80
    21 00000012 8816[1001]              	mov		BYTE [BootDevice], dl								; Save boot device number
    22                                  
    23 00000016 30E4                    	xor		ah, ah												; Change video mode (AH = $00)
    24 00000018 B003                    	mov		al, $03												; 40x25 text mode
    25 0000001A CD10                    	int		$10													; Call video BIOS
    26                                  
    27 0000001C 31FF                    	xor		di, di												; Clear colour value
    28 0000001E 31D2                    	xor		dx, dx												; Row 0, col 0
    29 00000020 BE[DF00]                	mov 	si, str_loadstage2									; Put string position into SI
    30 00000023 E84700                  	call 	print_string										; Call string printing routine
    31                                  
    32                                  	; Enable the A20 gate so we can use the full address range
    33                                  ;	call	check_a20											; Determine if A20 gate is set
    34                                  ;	cmp		ax, $0												; Is A20 line disabled?
    35                                  ;	jne		.A20GateEnabled										; If not, branch.
    36                                  
    37 00000026 B80124                  	mov		ax, $2401											; Try to enable A20 using the BIOS
    38 00000029 CD15                    	int		$15
    39 0000002B 80FC00                  	cmp		ah, $0												; Was there an error?
    40 0000002E 740C                    	je		.A20GateEnabled										; If not, branch
    41                                  
    42 00000030 E492                    	in		al, $92												; Use "Fast A20 Gate" method
    43 00000032 A802                    	test	al, 2
    44 00000034 7506                    	jnz		.A20GateEnabled
    45 00000036 0C02                    	or		al, 2
    46 00000038 24FE                    	and		al, $0FE
    47 0000003A E692                    	out		$92, al
    48                                  
    49                                  .A20GateEnabled:
    50 0000003C 30E4                    	xor		ah, ah												; Reset drive controller
    51                                  
    52 0000003E 8A16[1001]              	mov		dl, BYTE [BootDevice]								; Device number
    53 00000042 CD13                    	int		$13													; Reset drive
    54                                  
    55                                  .readStage2:
    56 00000044 BE[1401]                	mov 	si, ExtendedRead_Table								; address of "disk address packet"
    57 00000047 B442                    	mov 	ah, $42												; Extended Read
    58 00000049 8A16[1001]              	mov		dl, BYTE [BootDevice]								; Device number
    59 0000004D CD13                    	int 	$13
    60 0000004F 7209                    	jc 		SHORT .readErr
    61                                  
    62 00000051 8A16[1001]              	mov		dl, BYTE [BootDevice]								; Fetch boot device
    63 00000055 EA00050000              	jmp		stage2_seg:stage2_off								; Jump to second stage
    64                                  
    65                                  .readErr:
    66 0000005A 8B16[1101]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
    67 0000005E BF4F00                  	mov		di, $04F											; White text on red background
    68 00000061 BE[F000]                	mov 	si, str_floppyError									; Put string position into SI
    69 00000064 E80600                  	call 	print_string										; Call string printing routine
    70                                  
    71 00000067 31C0                    	xor		ax, ax												; Clear AX
    72 00000069 CD16                    	int		$16													; Wait for keypress
    73                                  
    74 0000006B EBD7                    	jmp		.readStage2
    75                                  
    76                                  ;========================================================================================
    77                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h.
    78                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
    79                                  ;========================================================================================
    80                                  print_string:
    81 0000006D 52                      	push	dx													; Push column
    82                                  
    83 0000006E 85FF                    	test	di, di												; Check if DI is set
    84 00000070 7406                    	jz		.useDefaultColour									; If so, branch
    85                                  
    86 00000072 89F8                    	mov		ax, di												; Set colour
    87 00000074 88C3                    	mov		bl, al												; Get low byte only
    88 00000076 EB02                    	jmp		SHORT .setCursor
    89                                  
    90                                  .useDefaultColour:
    91 00000078 B307                    	mov		bl, $007											; Light gray text on black background
    92                                  
    93                                  .setCursor:
    94 0000007A B402                    	mov 	ah, $02												; Set cursor position
    95 0000007C 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
    96 0000007E CD10                    	int		$10													; Set cursor
    97                                  
    98                                  .repeat:
    99 00000080 AC                      	lodsb														; Get character from string
   100 00000081 3C00                    	cmp 	al, 0
   101 00000083 7417                    	je		.done												; If char is zero, end of string
   102                                  	
   103 00000085 3C0A                    	cmp 	al, $0A												; Process newline
   104 00000087 741B                    	je		.newline
   105                                  
   106 00000089 B90100                  	mov		cx, $01												; Write one ASCII character
   107 0000008C 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   108 0000008E B409                    	mov 	ah, $09												; Write character
   109 00000090 CD10                    	int		$10													; Print character
   110                                  
   111 00000092 B402                    	mov 	ah, $02												; Set cursor position
   112 00000094 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   113 00000096 FEC2                    	inc		dl													; Increment column
   114 00000098 CD10                    	int		$10													; Set cursor
   115                                  
   116 0000009A EBE4                    	jmp		.repeat
   117                                  
   118                                  .done:
   119 0000009C 8916[1101]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   120 000000A0 5A                      	pop		dx													; Pop position
   121 000000A1 31FF                    	xor		di, di												; Clear colour
   122 000000A3 C3                      	ret
   123                                  
   124                                  .newline:
   125 000000A4 5A                      	pop		dx													; Get original column
   126 000000A5 FEC6                    	inc		dh													; Increment row
   127 000000A7 52                      	push	dx													; Push it back to stack
   128 000000A8 EBD6                    	jmp		.repeat
   129                                  
   130                                  ;========================================================================================
   131                                  ; Checks if the A20 gate is enabled.
   132                                  ;
   133                                  ; Returns:  0 in ax if the a20 line is disabled (memory wraps around)
   134                                  ;			1 in ax if the a20 line is enabled (memory does not wrap around)
   135                                  ;========================================================================================
   136                                  check_a20:
   137 000000AA 9C                      	pushf
   138 000000AB FA                      	cli
   139                                   
   140 000000AC 31C0                    	xor		ax, ax ; ax = 0
   141 000000AE 8EC0                    	mov		es, ax
   142                                   
   143 000000B0 F7D0                    	not		ax ; ax = 0xFFFF
   144 000000B2 8ED8                    	mov		ds, ax
   145                                   
   146 000000B4 BF0005                  	mov		di, 0x0500
   147 000000B7 BE1005                  	mov		si, 0x0510
   148                                   
   149 000000BA 268A05                  	mov		al, BYTE [es:di]
   150 000000BD 50                      	push	ax
   151                                   
   152 000000BE 3E8A04                  	mov		al, BYTE [ds:si]
   153 000000C1 50                      	push	ax
   154                                   
   155 000000C2 26C60500                	mov		BYTE [es:di], 0x00
   156 000000C6 3EC604FF                	mov		BYTE [ds:si], 0xFF
   157                                   
   158 000000CA 26803DFF                	cmp		BYTE [es:di], 0xFF
   159                                   
   160 000000CE 58                      	pop		ax
   161 000000CF 3E8804                  	mov		BYTE [ds:si], al
   162                                   
   163 000000D2 58                      	pop		ax
   164 000000D3 268805                  	mov		BYTE [es:di], al
   165                                   
   166 000000D6 31C0                    	xor		ax, ax
   167 000000D8 7403                    	je		.done
   168                                   
   169 000000DA B80100                  	mov		ax, 1
   170                                   
   171                                  .done:
   172 000000DD 9D                      	popf
   173 000000DE C3                      	ret
   174                                  
   175                                  ;========================================================================================
   176                                  ; DATA SECTION
   177                                  ;========================================================================================
   178                                  str_loadstage2:
   179 000000DF 4C6F6164696E672053-     	db 		"Loading Stage 2", $0A, 0
   180 000000E8 7461676520320A00   
   181                                  
   182                                  str_floppyError:
   183 000000F0 52656164206572726F-     	db 		"Read error, press key to retry", $0A, 0
   184 000000F9 722C20707265737320-
   185 00000102 6B657920746F207265-
   186 0000010B 7472790A00         
   187                                  
   188                                  BootDevice:
   189 00000110 80                      	db		$80
   190                                  
   191                                  LastCursorPosition:
   192 00000111 0000                    	dw		0
   193                                  
   194 00000113 90                      	align 2
   195                                  ExtendedRead_Table:
   196 00000114 10                      	db	$10
   197 00000115 00                      	db	0
   198 00000116 2F00                    	dw	stage2_len											; Num blocks
   199 00000118 0005                    	dw	stage2_off											; Dest
   200 0000011A 0000                    	dw	stage2_seg											; Memory page
   201 0000011C 01000000                	dd	stage2_start-1										; Starting LBA
   202 00000120 00000000                	dd	0													; more storage bytes only for big lba's ( > 4 bytes )
   203                                  
   204                                  ;========================================================================================
   205                                  ; MBR part 2
   206                                  ;========================================================================================
   207 00000124 00<rept>                	times	0x1B8-($-$$) db 0									; Align at 0x1B8
   208                                  
   209 000001B8 00000000                	dd		0													; Disk signature
   210 000001BC 0000                    	dw		0													; Reserved
   211                                  
   212                                  	; FAT partition 0
   213 000001BE 80                      	db		$80													; Bootable
   214 000001BF FEFFFF                  	db		$0FE, $0FF, $0FF									; CHS start (1023, 254, 63)
   215 000001C2 0C                      	db		$0C													; FAT32 with LBA addressing
   216 000001C3 FEFFFF                  	db		$0FE, $0FF, $0FF									; CHS end (1023, 254, 63)
   217 000001C6 40000000                	dd		$40													; FAT partition table starts at sector $40 (32K of padding for bootloader)
   218 000001CA 24FB0200                	dd		$2FB24												; 100 MB
   219                                  	; End FAT partition 0
   220                                  
   221 000001CE 000000000000000000-     	dd		0, 0, 0, 0											; Partition entry 2
   222 000001D7 00000000000000     
   223 000001DE 000000000000000000-     	dd		0, 0, 0, 0											; Partition entry 3
   224 000001E7 00000000000000     
   225 000001EE 000000000000000000-     	dd		0, 0, 0, 0											; Partition entry 4
   226 000001F7 00000000000000     
   227                                  
   228                                  	times	510-($-$$) db 0										; Pad remainder of boot sector with 0s
   229 000001FE 55AA                    	dw 		0xAA55												; Standard PC boot signature

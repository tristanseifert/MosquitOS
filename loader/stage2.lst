     1                                  	BITS	16
     2                                  	org		$0500
     3                                  
     4                                  ; Kernel will be loaded to segment $0A80, or $00A800 physical
     5                                  kern_loc:				EQU $0A80
     6                                  kern_loc_phys:			EQU kern_loc<<4
     7                                  kern_start:				EQU 6
     8                                  kern_len:				EQU 32									; Length in sectors
     9                                  
    10                                  ; Location to store various BIOS info at
    11                                  Kern_Info_Struct:		EQU $0160								; $001600 phys (len = $400 max)
    12                                  Kern_Info_StructPhys:	EQU (Kern_Info_Struct<<4)
    13                                  VESA_SupportedModes:	EQU	$01A0								; $001A00 phys (len = $200)
    14                                  BIOS_MemMapSeg:			EQU	$0200								; $002000 phys (len = $800 max)
    15                                  
    16                                  ; Physical protected mode addresses
    17                                  MMU_PageDir:			EQU $003000
    18                                  MMU_PageTable1:			EQU $004000
    19                                  MMU_PageTable2:			EQU $005000
    20                                  MMU_PageTable3:			EQU $006000
    21                                  MMU_PageTable4:			EQU $007000
    22                                  MMU_PageTable5:			EQU $008000
    23                                  
    24                                  ;	+$00 uint32_t munchieValue; // Should be "KERN"
    25                                  ;	+$04 uint16_t supportBits;
    26                                  ;	+$06 uint16_t high16Mem; // 64K blocks above 16M
    27                                  ;	+$08 uint16_t low16Mem; // 1k blocks below 16M
    28                                  ;	+$0A uint32_t memMap; // 32-bit ptr to list
    29                                  ;	+$0E uint16_t numMemMapEnt; // Number of entries in above map
    30                                  ;	+$10 uint8_t vesaSupport;
    31                                  ;	+$11 uint8_t bootDrive;
    32                                  ;	+$12 uint32_t vesaMap;
    33                                  
    34                                  stage2_start:
    35 00000000 B80080                  	mov		ax, $8000											; AX = stack segment value (Stack to go at $80000)
    36 00000003 8ED0                    	mov 	ss, ax
    37 00000005 BC0010                  	mov 	sp, 4096											; Set up SP
    38                                  
    39 00000008 8CC8                    	mov 	ax, cs												; Set data segment to where we're loaded
    40 0000000A 8ED8                    	mov 	ds, ax
    41                                  
    42 0000000C 8816[8D07]              	mov		BYTE [BootDevice], dl								; Save boot device number
    43 00000010 8816[A10B]              	mov		BYTE [FAT_Drive], dl								; Set FAT read drive
    44                                  
    45 00000014 66C70600164B45524E      	mov		DWORD [Kern_Info_StructPhys], "KERN"				; Set magic value for kern struct
    46                                  
    47 0000001D A0[8D07]                	mov		al, [BootDevice]									; Set boot drive
    48 00000020 A21116                  	mov		BYTE [Kern_Info_StructPhys+$11], al					; ""
    49                                  
    50                                  	; Set up video
    51 00000023 B400                    	mov		ah, $00												; Change video mode
    52 00000025 B003                    	mov		al, $03												; 80x25 text mode
    53 00000027 CD10                    	int		$10													; Call video BIOS
    54                                  
    55 00000029 BE[9405]                	mov 	si, str_stage2loaded								; Put string position into SI
    56 0000002C 31D2                    	xor		dx, dx												; Cursor position
    57 0000002E BF2F00                  	mov		di, $2F												; Set colour
    58 00000031 E8BA03                  	call 	print_string										; Call string printing routine
    59                                  
    60                                  	; Call VESA BIOS routines to get supported video modes
    61 00000034 B8A001                  	mov		ax, VESA_SupportedModes								; Memory location of supported mode struct
    62 00000037 8EC0                    	mov		es, ax												; ""
    63 00000039 31FF                    	xor		di, di												; Offset 0 in segment
    64                                  
    65 0000003B 2666C70556424532        	mov		[es:di], DWORD "VBE2"								; Tell BIOS we want 512 bytes of data
    66                                  
    67 00000043 B8004F                  	mov		ax, $4F00											; VESA BIOS routines â€” get supported modes
    68 00000046 CD10                    	int		$10													; Perform lookup
    69                                  
    70 00000048 84E4                    	test	ah, ah												; Is AH not zero (i.e. error)
    71 0000004A 7400                    	je		.vesaDone											; If so, VESA is unsupported
    72                                  
    73                                  .vesaDone:
    74                                  	; Call BIOS to get memory information
    75 0000004C 31C9                    	xor 	cx, cx
    76 0000004E 31D2                    	xor 	dx, dx
    77 00000050 B801E8                  	mov 	ax, $0E801
    78 00000053 CD15                    	int 	$15													; Request upper memory size
    79 00000055 7250                    	jc 		error_memoryDetect
    80 00000057 80FC86                  	cmp 	ah, $86												; Unsupported function
    81 0000005A 744B                    	je		error_memoryDetect
    82 0000005C 80FC80                  	cmp		ah, $80												; Invalid command
    83 0000005F 7446                    	je		error_memoryDetect
    84 00000061 E304                    	jcxz 	.useax												; Was the CX result invalid?
    85                                   
    86 00000063 89C8                    	mov		ax, cx												; Number of continuous 1K blocks (1M-16M)
    87 00000065 89D3                    	mov		bx, dx												; Number of continuous 64K block above 16M
    88                                  
    89                                  .useax:
    90 00000067 31FF                    	xor		di, di												; Clear DI
    91 00000069 891E[9007]              	mov		WORD [MemBlocksAbove16M], bx						; Store amount of memory available
    92 0000006D 891E0616                	mov		WORD [Kern_Info_StructPhys+$06], bx					; Highmem
    93 00000071 A3[9207]                	mov		WORD [MemBlocksBelow16M], ax						; ""
    94 00000074 A30816                  	mov		WORD [Kern_Info_StructPhys+$08], ax					; Lowmem
    95                                  
    96 00000077 E84F03                  	call	display_memsize										; Display the memory size
    97                                  
    98                                  	; Fetch memory map
    99 0000007A B80002                  	mov 	ax, BIOS_MemMapSeg									; Write mem map to $01800 in physical space
   100 0000007D 8EC0                    	mov 	es, ax
   101 0000007F 31FF                    	xor		di, di												; Start of segment
   102                                  
   103 00000081 E81304                  	call	fetch_mem_map										; Fetch a memory map
   104 00000084 7221                    	jc 		SHORT error_memoryDetect							; Branch if error
   105                                  
   106 00000086 892E0E16                	mov		WORD [Kern_Info_StructPhys+$0E], bp					; ""
   107 0000008A 66C7060A1600200000      	mov		DWORD [Kern_Info_StructPhys+$0A], (BIOS_MemMapSeg<<4); Physical location of table
   108                                  
   109                                  	; Initialise FAT library
   110 00000093 E89A07                  	call	FAT_Init
   111                                  
   112                                  	; Check which partitions are bootable from MBR partition map
   113 00000096 E87F02                  	call	find_bootable_partitions
   114 00000099 C606[9E07]00            	mov		BYTE [HDD_Selected], 0								; Clear HDD selection
   115                                  
   116                                  	; Set up the partition chooser UI
   117 0000009E E8FA00                  	call	render_partition_chooser
   118                                  
   119                                  	; Process keypresses, and loads kernel from FS if ENTER is pressed
   120 000000A1 E8F001                  	call	chooser_loop
   121 000000A4 E90800                  	jmp		boot
   122                                  
   123                                  ;========================================================================================
   124                                  ; Memory detection error handler
   125                                  ;========================================================================================
   126                                  error_memoryDetect:
   127 000000A7 BE[AF05]                	mov 	si, str_errorDetectMem								; Put string position into SI
   128 000000AA E83B03                  	call 	print_error											; Call string printing routine
   129 000000AD EBFE                    	jmp		$
   130                                  
   131                                  ;========================================================================================
   132                                  ; Code to boot the kernel
   133                                  ;========================================================================================
   134                                  boot:
   135                                  	; Hide cursor
   136 000000AF 31D2                    	xor		dx, dx												; Clear dx
   137 000000B1 F7D2                    	not		dx													; dx = $FFFF
   138 000000B3 B402                    	mov 	ah, $02												; Set cursor position
   139 000000B5 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   140 000000B7 CD10                    	int		$10													; Set cursor
   141                                  
   142                                  	; Set up GDT
   143 000000B9 FA                      	cli															; Disable ints
   144 000000BA 0F0116[2808]            	lgdt	[gdt_table]											; Set up GDTR
   145                                  
   146                                  	; Jump into protected mode, woot!
   147 000000BF 0F20C0                  	mov		eax, cr0											; Get control reg
   148 000000C2 0C01                    	or		al, 00000001b										; Set PE bit
   149 000000C4 0F22C0                  	mov		cr0, eax											; Write control reg
   150                                  
   151                                  	; Set up selectors
   152 000000C7 B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   153 000000CA 8ED8                    	mov		ds, ax												; Set data selector
   154                                  
   155 000000CC B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   156 000000CF 8EC0                    	mov		es, ax												; Update other selectors to point to data segment
   157 000000D1 8EE0                    	mov		fs, ax
   158 000000D3 8EE8                    	mov		gs, ax
   159 000000D5 8ED0                    	mov		ss, ax
   160                                  
   161                                  	; The kernel is loaded to $00003000 phys (segmented address 0300h:0000h)
   162 000000D7 66                      	db		$66													; 32-bit prefix
   163 000000D8 EA                      	db		$0EA												; Far jump opcode
   164 000000D9 [DF000000]              	dd		copy_kernel											; Jump to kernel copying routine
   165 000000DD 0800                    	dw		$08													; Selector for CODE32_DESCRIPTOR
   166                                  
   167                                  	BITS	32
   168                                  copy_kernel:
   169 000000DF BC00004000              	mov		esp, $400000										; Stackzors at $400000
   170                                  
   171 000000E4 B800A80000              	mov		eax, kern_loc_phys									; Physical kernel location
   172 000000E9 BB00001000              	mov		ebx, $00100000										; Destination memory address
   173 000000EE B900400000              	mov		ecx, $4000											; Number of long-words to copy (64KB)
   174                                  
   175 000000F3 90                      	align	4													; DWORD align
   176                                  .copy:
   177 000000F4 8B10                    	mov		edx, DWORD [eax]									; Read a DWORD from lowmem
   178 000000F6 8913                    	mov		DWORD [ebx], edx									; Write DWORD to himem
   179                                  
   180 000000F8 0504000000              	add		eax, $04											; Increment read ptr
   181 000000FD 81C304000000            	add		ebx, $04											; Increment write ptr
   182                                  
   183 00000103 E2EF                    	loop	.copy												; Loop and copy everything
   184                                  
   185                                  	; Here, we build a page directory and table to map $C0000000 to $00100000.
   186 00000105 31C0                    	xor		eax, eax
   187 00000107 BB00300000              	mov		ebx, MMU_PageDir
   188 0000010C B900100000              	mov		ecx, $1000
   189                                  
   190                                  .clrTablesLoop:
   191 00000111 8903                    	mov		DWORD [ebx], eax
   192 00000113 81C304000000            	add		ebx, $04
   193 00000119 E2F6                    	loop	.clrTablesLoop
   194                                  
   195                                  
   196                                  	; Since we only need to map 4M for right now, concern ourselves only with entry 0x300 and 0x000
   197                                  	; Also, map 0x00000000 to 0x003FFFFF
   198 0000011B C70500300000034000-     	mov		DWORD [MMU_PageDir+0x000], (MMU_PageTable1 | $3)
   199 00000124 00                 
   200                                  
   201 00000125 C705003C0000035000-     	mov		DWORD [MMU_PageDir+0xC00], (MMU_PageTable2 | $3)
   202 0000012E 00                 
   203 0000012F C705043C0000036000-     	mov		DWORD [MMU_PageDir+0xC04], (MMU_PageTable3 | $3)
   204 00000138 00                 
   205 00000139 C705083C0000037000-     	mov		DWORD [MMU_PageDir+0xC08], (MMU_PageTable4 | $3)
   206 00000142 00                 
   207 00000143 C7050C3C0000038000-     	mov		DWORD [MMU_PageDir+0xC0C], (MMU_PageTable5 | $3)
   208 0000014C 00                 
   209                                  
   210                                  
   211                                  	; Run a loop 1024 times to fill the first page table
   212 0000014D B900040000              	mov		ecx, $400
   213 00000152 31DB                    	xor		ebx, ebx											; Page table offset
   214 00000154 B807000000              	mov		eax, DWORD $00000007									; Physical address start
   215                                  
   216                                  .fillPageTable1:
   217 00000159 89049D00400000          	mov		DWORD [MMU_PageTable1+ebx*4], eax					; Write physical location
   218                                  
   219 00000160 43                      	inc		ebx													; Go to next entry in page table
   220 00000161 0500100000              	add		eax, $1000											; Increment physical address
   221 00000166 E2F1                    	loop	.fillPageTable1
   222                                  
   223                                  
   224                                  	; Run a loop 8192 times to fill the second page table
   225 00000168 B900100000              	mov		ecx, $1000
   226 0000016D 31DB                    	xor		ebx, ebx											; Page table offset
   227 0000016F B807001000              	mov		eax, DWORD $00100007								; Physical address start
   228                                  
   229                                  .fillPageTable2:
   230 00000174 89049D00500000          	mov		DWORD [MMU_PageTable2+ebx*4], eax					; Write physical location
   231                                  
   232 0000017B 43                      	inc		ebx													; Go to next entry in page table
   233 0000017C 0500100000              	add		eax, $1000											; Increment physical address
   234 00000181 E2F1                    	loop	.fillPageTable2
   235                                  
   236                                  
   237                                  	; Set paging directory to CR3
   238 00000183 B800300000              	mov		eax, MMU_PageDir
   239 00000188 0F22D8                  	mov		cr3, eax
   240                                  
   241                                  	; Enable paging in CR0
   242 0000018B 0F20C0                  	mov		eax, cr0
   243 0000018E 0D00000080              	or		eax, $80000000
   244 00000193 0F22C0                  	mov		cr0, eax
   245                                  
   246                                  	; Jump into kernel
   247 00000196 E9(000000C0)            	jmp		$0C0000000
   248                                  
   249                                  	BITS	16
   250                                  
   251                                  ;========================================================================================
   252                                  ; Renders the partition chooser
   253                                  ;========================================================================================
   254                                  render_partition_chooser:
   255 0000019B BE[5D06]                	mov 	si, str_select_partition							; Put string position into SI
   256 0000019E BA0105                  	mov		dx, $0501											; Cursor position
   257 000001A1 BF0700                  	mov		di, $07												; Set colour
   258 000001A4 E84702                  	call 	print_string										; Call string printing routine
   259                                  
   260 000001A7 C706[8E07]0407          	mov		WORD [LastCursorPosition], 0x0704					; Read last cursor position
   261                                  
   262 000001AD 66BA[96070000]          	mov		edx, HDD_BootablePartitions							; EDX contains bootable partition ptr
   263 000001B3 B90400                  	mov		cx, $04												; Loop 4x
   264                                  
   265                                  .disp_loop:
   266 000001B6 678A02                  	mov		al, BYTE [edx]										; Read bootability
   267 000001B9 2480                    	and		al, $80												; Get high bit only
   268 000001BB 3C80                    	cmp		al, $80												; Is it $80?
   269 000001BD 7505                    	jne		.not_bootable										; If not, it's not a bootable drive
   270                                  
   271 000001BF E81300                  	call	.render_boot										; Render bootable drive label
   272                                  
   273 000001C2 EB03                    	jmp		SHORT .next											; Skip over non-bootable code
   274                                  
   275                                  .not_bootable:
   276 000001C4 E87900                  	call	.render_noboot										; Render non-bootable drive label
   277                                  
   278                                  .next:
   279 000001C7 6642                    	inc		edx													; Go to next item
   280 000001C9 E2EB                    	loop	.disp_loop											; Loop over all 4 partitions
   281                                  
   282 000001CB BA010C                  	mov		dx, $0C01
   283 000001CE BE[F006]                	mov		si, str_err_clear_err								; Clear error
   284 000001D1 E81A02                  	call	print_string										; Display
   285                                  
   286 000001D4 C3                      	ret
   287                                  
   288                                  ;========================================================================================
   289                                  ; Renders an entry for a bootable drive
   290                                  ;========================================================================================
   291                                  .render_boot:
   292 000001D5 B004                    	mov		al, $04												; Max drive num to al
   293 000001D7 28C8                    	sub		al, cl												; Subtract loop counter
   294 000001D9 A2[3C02]                	mov		BYTE [.index], al									; Write index
   295 000001DC 0430                    	add		al, $30												; ASCII numbers
   296                                  
   297 000001DE 66C706[CF07]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   298 000001E6 2C                 
   299 000001E7 A2[D307]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   300 000001EA C706[D407]3A20          	mov		WORD [Temp_StrBuf+5], ": "							; Colon, space
   301                                  
   302 000001F0 60                      	pusha														; Push registers
   303 000001F1 66BA[D6070000]          	mov		edx, Temp_StrBuf+7									; String buffer write place
   304 000001F7 66BB[9F070000]          	mov		ebx, HDD_PartitionNames								; Partition names
   305 000001FD B90C00                  	mov		cx, $0C												; $0C characters
   306                                  
   307                                  .copyNameLoop:
   308 00000200 678A03                  	mov		al, BYTE [ebx]										; Copy a character
   309 00000203 678802                  	mov		BYTE [edx], al										; Write to temp buffer
   310 00000206 6643                    	inc		ebx													; Increment read pointer
   311 00000208 6642                    	inc		edx													; Increment write pointer
   312 0000020A E2F4                    	loop	.copyNameLoop
   313                                  
   314 0000020C 67C742FF0A00            	mov		WORD [edx-1], 0x000A								; Insert newline
   315                                  
   316 00000212 6631C0                  	xor		eax, eax											; Clear EAX
   317 00000215 66BA[9A070000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type matrix
   318 0000021B 0216[3C02]              	add		dl, BYTE [.index]
   319 0000021F 678A02                  	mov		al, BYTE [edx]										; Read FAT type to AL
   320                                  
   321 00000222 8A1E[9E07]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   322 00000226 80E303                  	and		bl, $3												; Get low 2 bits only
   323 00000229 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   324 0000022B 7503                    	jne		.no_highlight										; If not, branch.
   325                                  
   326 0000022D BF7000                  	mov		di, $070											; Black text on white background
   327                                  
   328                                  .no_highlight:
   329 00000230 8B16[8E07]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   330 00000234 BE[CF07]                	mov		si, Temp_StrBuf										; Temporary string buffer
   331 00000237 E8B401                  	call 	print_string										; Call string printing routine
   332 0000023A 61                      	popa														; Pop registers
   333                                  
   334 0000023B C3                      	ret
   335                                  
   336                                  .index:
   337 0000023C 00                      	db	0
   338                                  
   339                                  ;========================================================================================
   340                                  ; Renders an entry for a non-bootable drive.
   341                                  ;========================================================================================
   342 0000023D 90<rept>                	align 4
   343                                  
   344                                  .render_noboot:
   345 00000240 B004                    	mov		al, $04												; Max drive num to al
   346 00000242 28C8                    	sub		al, cl												; Subtract loop counter
   347 00000244 0430                    	add		al, $30												; ASCII numbers
   348                                  
   349 00000246 66C706[CF07]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   350 0000024E 2C                 
   351 0000024F A2[D307]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   352 00000252 66C706[D407]3A204E-     	mov		DWORD [Temp_StrBuf+5], ": No"						; "Not Bootable"
   353 0000025A 6F                 
   354 0000025B 66C706[D807]742042-     	mov		DWORD [Temp_StrBuf+9], "t Bo"
   355 00000263 6F                 
   356 00000264 66C706[DC07]6F7461-     	mov		DWORD [Temp_StrBuf+13], "otab"
   357 0000026C 62                 
   358 0000026D C706[E007]6C65          	mov		WORD [Temp_StrBuf+17], "le"
   359 00000273 C706[E207]0A00          	mov		WORD [Temp_StrBuf+19], 0x000A						; Newline, terminator
   360                                  
   361 00000279 60                      	pusha														; Push registers
   362                                  
   363 0000027A 8A1E[9E07]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   364 0000027E 80E303                  	and		bl, $3												; Get low 2 bits only
   365 00000281 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   366 00000283 7503                    	jne		.no_highlight2										; If not, branch.
   367                                  
   368 00000285 BF7000                  	mov		di, $070											; Black text on white background
   369                                  
   370                                  .no_highlight2:
   371 00000288 8B16[8E07]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   372 0000028C BE[CF07]                	mov		si, Temp_StrBuf										; Temporary string buffer
   373 0000028F E85C01                  	call 	print_string										; Call string printing routine
   374 00000292 61                      	popa														; Pop registers
   375                                  
   376 00000293 C3                      	ret
   377                                  
   378                                  ;========================================================================================
   379                                  ; Handle keypresses for chooser
   380                                  ;========================================================================================
   381                                  chooser_loop:
   382 00000294 E91500                  	jmp		partition_chooser_enter
   383                                  
   384 00000297 30E4                    	xor		ah, ah												; Wait for keystroke
   385 00000299 CD16                    	int		$16													; Call into BIOS
   386                                  
   387 0000029B 80FC50                  	cmp		ah, $50												; Down pressed?
   388 0000029E 7459                    	je		partition_chooser_dn
   389                                  
   390 000002A0 80FC48                  	cmp		ah, $48												; Up pressed?
   391 000002A3 7463                    	je		partition_chooser_up
   392                                  
   393 000002A5 80FC1C                  	cmp		ah, $1C												; Enter pressed?
   394 000002A8 7402                    	je		partition_chooser_enter
   395                                  
   396 000002AA EBE8                    	jmp		chooser_loop
   397                                  
   398                                  partition_chooser_enter:
   399 000002AC 31DB                    	xor		bx, bx												; Clear BX
   400 000002AE 8A1E[9E07]              	mov		bl, BYTE [HDD_Selected]								; Get selection
   401                                  
   402 000002B2 8A87[9607]              	mov		al, BYTE [HDD_BootablePartitions+bx]				; Check bootability status
   403 000002B6 2480                    	and		al, $80												; Get high bit only
   404 000002B8 3C80                    	cmp		al, $80
   405 000002BA 7527                    	jne		.noBootErr											; If not bootable, branch
   406                                  
   407 000002BC BE[0408]                	mov		si, kernel_filename									; Filename to find
   408 000002BF E8B907                  	call	FAT_FindFileAtRoot									; Find file
   409 000002C2 722A                    	jc		.fileNotFound										; Carry set = KERNEL.BIN not found
   410                                  
   411 000002C4 66A3[0008]              	mov		DWORD [kernel_cluster], eax							; Store cluster
   412                                  
   413 000002C8 31C0                    	xor		ax, ax												; Segment 0
   414 000002CA 8EC0                    	mov		es, ax												; Write segment											
   415 000002CC BF00A8                  	mov		di, kern_loc_phys									; Offset into segment
   416                                  
   417 000002CF 66A1[0008]              	mov		eax, DWORD [kernel_cluster]							; Kernel's cluster location
   418 000002D3 E81A08                  	call	FAT_ReadFile										; Read file
   419                                  
   420 000002D6 BE[4207]                	mov 	si, str_kernel_loaded_ok							; Put string position into SI
   421 000002D9 BA010C                  	mov		dx, $0C01											; Cursor position
   422 000002DC BF0200                  	mov		di, $02												; Set colour
   423 000002DF E80C01                  	call 	print_string										; Call string printing routine
   424                                  
   425 000002E2 C3                      	ret
   426                                  
   427                                  .noBootErr:
   428 000002E3 BA010C                  	mov		dx, $0C01
   429 000002E6 BE[9206]                	mov		si, str_err_not_bootable							; Not bootable error
   430 000002E9 E8FC00                  	call	print_error											; Display
   431 000002EC EBA6                    	jmp		chooser_loop
   432                                  
   433                                  .fileNotFound:
   434 000002EE BA010C                  	mov		dx, $0C01
   435 000002F1 BE[BC06]                	mov		si, str_err_kern_not_found							; Not found error
   436 000002F4 E8F100                  	call	print_error											; Display
   437 000002F7 EB9B                    	jmp		chooser_loop
   438                                  
   439                                  partition_chooser_dn:
   440 000002F9 A0[9E07]                	mov		al, BYTE [HDD_Selected]								; Read selection
   441 000002FC FEC8                    	dec		al													; Move cursor up
   442 000002FE 2403                    	and		al, $03												; Get low 2 bits only
   443 00000300 A2[9E07]                	mov		BYTE [HDD_Selected], al								; Restore
   444                                  
   445 00000303 E895FE                  	call	render_partition_chooser							; Update display
   446 00000306 EB8C                    	jmp		chooser_loop
   447                                  
   448                                  partition_chooser_up:
   449 00000308 A0[9E07]                	mov		al, BYTE [HDD_Selected]								; Read selection
   450 0000030B FEC0                    	inc		al													; Move cursor down
   451 0000030D 2403                    	and		al, $03												; Get low 2 bits only
   452 0000030F A2[9E07]                	mov		BYTE [HDD_Selected], al								; Restore
   453                                  
   454 00000312 E886FE                  	call	render_partition_chooser							; Update display
   455 00000315 E97CFF                  	jmp		chooser_loop
   456                                  
   457                                  ;========================================================================================
   458                                  ; Finds all partitions that are bootable.
   459                                  ;========================================================================================
   460                                  find_bootable_partitions:
   461 00000318 B90400                  	mov		cx, $4												; MBR contains 4 partition maps
   462                                  
   463 0000031B B8C007                  	mov		ax, $07C0											; Bootloader at 0x7C00
   464 0000031E 8EC0                    	mov		es, ax												; Set ES to the bootloader's place in memory
   465 00000320 BFBE01                  	mov		di, $1BE											; Start of partition map
   466                                  
   467 00000323 8CD8                    	mov		ax, ds												; Fetch data segment
   468 00000325 8EE8                    	mov		gs, ax												; Set GS to data segment
   469                                  
   470 00000327 66BE[96070000]          	mov		esi, HDD_BootablePartitions							; ESI contains bootable partition ptr
   471 0000032D 66BA[9F070000]          	mov		edx, HDD_PartitionNames								; Partition name ptr
   472                                  
   473                                  .loop:
   474 00000333 268A05                  	mov		al, BYTE [es:di]									; Read bootable flag
   475 00000336 2480                    	and		al, $80												; Get high bit only
   476 00000338 3C80                    	cmp		al, $80												; Is it $80?
   477 0000033A 754B                    	jne		.not_bootable										; If not, it's not a bootable drive
   478                                  
   479 0000033C 678806                  	mov		BYTE [esi], al										; Write bootability flag
   480                                  
   481 0000033F 880E[9E07]              	mov		BYTE [HDD_Selected], cl								; Write index
   482                                  
   483                                  	; Try to read the LBA of the partition
   484 00000343 26668B4508              	mov		eax, DWORD [es:di+8]								; Read partition LBA
   485 00000348 663D00000000            	cmp		eax, $00											; Is it zero?
   486 0000034E 7437                    	je		.no_valid_lba										; If so, fuck off
   487                                  
   488 00000350 66A3[F807]              	mov		DWORD [ExtendedRead_Table+0x08], eax				; Write LBA
   489 00000354 C706[F207]0100          	mov		WORD [ExtendedRead_Table+0x02], 0x01				; Read one sector
   490 0000035A C706[F407][C00B]        	mov		WORD [ExtendedRead_Table+0x04], SectorBuf			; Temporary sector buffer offset (seg 0)
   491                                  
   492 00000360 66A3[9C0B]              	mov		DWORD [FAT_PartitionOffset], eax					; Write offset into FAT
   493                                  
   494 00000364 60                      	pusha														; Push registers (BIOS may clobber them)
   495 00000365 BE[F007]                	mov 	si, ExtendedRead_Table								; address of "disk address packet"
   496 00000368 B442                    	mov 	ah, $42												; Extended Read
   497 0000036A 8A16[8D07]              	mov		dl, BYTE [BootDevice]								; Device number
   498 0000036E CD13                    	int 	$13
   499 00000370 61                      	popa														; Pop registers
   500 00000371 7214                    	jc 		SHORT .no_valid_lba									; If error, fuck off
   501                                  
   502 00000373 E82100                  	call	.typeDetermine										; Determine type and label loc
   503                                  
   504 00000376 51                      	push	cx													; Back up original loop counter
   505                                  
   506 00000377 B90B00                  	mov		cx, $0B												; Copy 0xB bytes
   507                                  .copy_str_loop:
   508 0000037A 678A18                  	mov		bl, BYTE [eax]										; Copy from source
   509 0000037D 67881A                  	mov		BYTE [edx], bl										; Write to target buffer
   510 00000380 6640                    	inc		eax													; Increment read pointer
   511 00000382 6642                    	inc		edx													; Increment write pointer
   512 00000384 E2F4                    	loop	.copy_str_loop										; Copy all bytes.
   513                                  
   514 00000386 59                      	pop		cx													; Restore original loop counter.
   515                                  
   516                                  .no_valid_lba:
   517                                  
   518                                  .not_bootable:
   519 00000387 81C71000                	add		di, $10												; Go to next entry in bootsector
   520 0000038B 6646                    	inc		esi													; Write next bootability flag
   521 0000038D 6681C20C000000          	add		edx, $0C											; Each entry of partition names is 0x0C in length
   522 00000394 E29D                    	loop	.loop												; Loop through all partitions
   523                                  
   524                                  .done:
   525 00000396 C3                      	ret
   526                                  
   527                                  ; Determines FAT type and stores pointer to read volume label in eax
   528                                  .typeDetermine:
   529 00000397 6656                    	push	esi													; Push old ESI
   530 00000399 BE[C00B]                	mov		si, SectorBuf										; Sector buffer
   531 0000039C E8AB04                  	call	FAT_DetermineType									; Determine type of FS
   532 0000039F 665E                    	pop		esi													; Pop ESI
   533                                  
   534 000003A1 6652                    	push	edx													; Back up EDX
   535 000003A3 B304                    	mov		bl, $04												; Max drive num to al
   536 000003A5 28CB                    	sub		bl, cl												; Subtract loop counter
   537                                  
   538 000003A7 66BA[9A070000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type ptr
   539 000003AD 28DA                    	sub		dl, bl												; Subtract index
   540 000003AF 678802                  	mov		BYTE [edx], al										; Write FAT size
   541 000003B2 665A                    	pop		edx													; Restore EDX
   542                                  
   543 000003B4 3C20                    	cmp		al, $20												; Is it a FAT32 volume?
   544 000003B6 7509                    	jne		.fat16_label										; If so, branch
   545                                  
   546 000003B8 66B8[070C0000]          	mov		eax, SectorBuf+$47									; FAT32 has volume label at 0x47
   547                                  
   548 000003BE E90600                  	jmp		.copy												; Copy label
   549                                  
   550                                  	; Extract volume label from sector buffer
   551                                  .fat16_label:
   552 000003C1 66B8[EB0B0000]          	mov		eax, SectorBuf+$2B									; FAT16 has volume label at 0x2B
   553                                  
   554                                  .copy:
   555 000003C7 C3                      	ret
   556                                  
   557                                  .index:
   558 000003C8 00                      	db		0
   559                                  
   560                                  ;========================================================================================
   561                                  ; Displays the memory size on the screen 
   562                                  ;========================================================================================
   563                                  display_memsize:
   564 000003C9 BE[0706]                	mov 	si, str_available_lomem								; Put string position into SI
   565 000003CC BA0002                  	mov		dx, $0200
   566 000003CF E81C00                  	call 	print_string										; Call string printing routine
   567 000003D2 A1[9207]                	mov		ax, WORD [MemBlocksBelow16M]						; Get total of memory blocks to EDX
   568 000003D5 E88100                  	call	hex_to_ascii
   569                                  
   570 000003D8 BE[3206]                	mov 	si, str_available_himem								; Put string position into SI
   571 000003DB BA0003                  	mov		dx, $0300
   572 000003DE E80D00                  	call 	print_string										; Call string printing routine
   573 000003E1 A1[9007]                	mov		ax, WORD [MemBlocksAbove16M]						; Get total of memory blocks to EDX
   574 000003E4 E87200                  	call	hex_to_ascii
   575                                  
   576 000003E7 C3                      	ret
   577                                  
   578                                  ;========================================================================================
   579                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h with the styling
   580                                  ; required for an error string.
   581                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   582                                  ;========================================================================================
   583                                  print_error:
   584 000003E8 BF4F00                  	mov		di, $04F											; White text on red background
   585 000003EB E90000                  	jmp 	print_string										; Call string printing routine
   586                                  
   587                                  ;========================================================================================
   588                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h.
   589                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   590                                  ;========================================================================================
   591                                  print_string:
   592 000003EE 52                      	push	dx													; Push column
   593                                  
   594 000003EF 85FF                    	test	di, di												; Check if DI is set
   595 000003F1 7406                    	jz		.useDefaultColour									; If so, branch
   596                                  
   597 000003F3 89F8                    	mov		ax, di												; Set colour
   598 000003F5 88C3                    	mov		bl, al												; Get low byte only
   599 000003F7 EB02                    	jmp		SHORT .setCursor
   600                                  
   601                                  .useDefaultColour:
   602 000003F9 B307                    	mov		bl, $007											; Light gray text on black background
   603                                  
   604                                  .setCursor:
   605 000003FB B402                    	mov 	ah, $02												; Set cursor position
   606 000003FD 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   607 000003FF CD10                    	int		$10													; Set cursor
   608                                  
   609                                  .repeat:
   610 00000401 AC                      	lodsb														; Get character from string
   611 00000402 3C00                    	cmp 	al, 0
   612 00000404 7417                    	je		.done												; If char is zero, end of string
   613                                  	
   614 00000406 3C0A                    	cmp 	al, $0A												; Process newline
   615 00000408 741B                    	je		.newline
   616                                  
   617 0000040A B90100                  	mov		cx, $01												; Write one ASCII character
   618 0000040D 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   619 0000040F B409                    	mov 	ah, $09												; Write character
   620 00000411 CD10                    	int		$10													; Print character
   621                                  
   622 00000413 B402                    	mov 	ah, $02												; Set cursor position
   623 00000415 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   624 00000417 FEC2                    	inc		dl													; Increment column
   625 00000419 CD10                    	int		$10													; Set cursor
   626                                  
   627 0000041B EBE4                    	jmp		.repeat
   628                                  
   629                                  .done:
   630 0000041D 8916[8E07]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   631 00000421 5A                      	pop		dx													; Pop position
   632 00000422 31FF                    	xor		di, di												; Clear colour
   633 00000424 C3                      	ret
   634                                  
   635                                  .newline:
   636 00000425 5A                      	pop		dx													; Get original column
   637 00000426 FEC6                    	inc		dh													; Increment row
   638 00000428 52                      	push	dx													; Push it back to stack
   639 00000429 EBD6                    	jmp		.repeat
   640                                  
   641                                  ;========================================================================================
   642                                  ; Prints the character in al to the screen at the current cursor position, using the
   643                                  ; colour in di.
   644                                  ;========================================================================================
   645                                  putc:
   646 0000042B 85FF                    	test	di, di												; Check if DI is set
   647 0000042D 7406                    	jz		.useDefaultColour									; If so, branch
   648                                  
   649 0000042F 89F8                    	mov		ax, di												; Set colour
   650 00000431 88C3                    	mov		bl, al												; Get low byte only
   651 00000433 EB02                    	jmp		SHORT .setCursor
   652                                  
   653                                  .useDefaultColour:
   654 00000435 B307                    	mov		bl, $007											; Light gray text on black background
   655                                  
   656                                  .setCursor:
   657 00000437 8B16[8E07]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   658 0000043B B402                    	mov 	ah, $02												; Set cursor position
   659 0000043D B700                    	mov		bh, $0												; Video page 0
   660 0000043F CD10                    	int		$10													; Set cursor
   661                                  
   662 00000441 B90100                  	mov		cx, $01												; Write one ASCII character
   663 00000444 B700                    	mov		bh, $0												; Video page 0
   664 00000446 B409                    	mov 	ah, $09												; Write character
   665 00000448 CD10                    	int		$10													; Print character
   666                                  
   667 0000044A FEC2                    	inc		dl													; Increment column
   668                                  
   669 0000044C B402                    	mov 	ah, $02												; Set cursor position
   670 0000044E B700                    	mov		bh, $0												; Video page 0
   671 00000450 CD10                    	int		$10													; Set cursor
   672                                  
   673 00000452 8916[8E07]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   674 00000456 31FF                    	xor		di, di												; Clear colour
   675 00000458 C3                      	ret
   676                                  
   677                                  ;========================================================================================
   678                                  ; Prints the value in eax to the screen.
   679                                  ;========================================================================================
   680                                  hex_to_ascii:
   681 00000459 31C9                    	xor 	cx, cx
   682                                  
   683 0000045B 88E1                    	mov 	cl, ah												; Move high byte of ax to cl
   684 0000045D E81000                  	call 	.nibble_high										; Print low nibble to ASCII
   685 00000460 88E1                    	mov 	cl, ah
   686 00000462 E81100                  	call 	.nibble_low
   687 00000465 88C1                    	mov 	cl, al
   688 00000467 E80600                  	call 	.nibble_high
   689 0000046A 88C1                    	mov 	cl, al
   690 0000046C E80700                  	call 	.nibble_low
   691 0000046F C3                      	ret
   692                                  
   693                                  .nibble_high:
   694 00000470 C0E904                  	shr 	cl, $04
   695 00000473 E90600                  	jmp 	.convert_check
   696                                  
   697                                  .nibble_low:
   698 00000476 80E10F                  	and 	cl, $0F
   699 00000479 E90000                  	jmp 	.convert_check
   700                                  
   701                                  .convert_check:
   702 0000047C 80F90A                  	cmp 	cl, $0A
   703 0000047F 7D0B                    	jge 	.letter
   704 00000481 80C130                  	add 	cl, $30
   705 00000484 50                      	push 	ax
   706 00000485 88C8                    	mov 	al, cl
   707 00000487 E8A1FF                  	call 	putc
   708 0000048A 58                      	pop 	ax
   709 0000048B C3                      	ret
   710                                  
   711                                  .letter:
   712 0000048C 80C137                  	add 	cl, $37
   713 0000048F 50                      	push	ax
   714 00000490 88C8                    	mov 	al, cl
   715 00000492 E896FF                  	call	putc
   716 00000495 58                      	pop 	ax
   717 00000496 C3                      	ret
   718                                  
   719                                  ;========================================================================================
   720                                  ; Uses BIOS INT $15, EAX $E820 function to get the memory map of the system
   721                                  ; input: 	es:di = destination buffer for 24 byte entries
   722                                  ; output: 	bp = entry count, trashes all registers except esi
   723                                  ;========================================================================================
   724                                  fetch_mem_map:
   725 00000497 6631DB                  	xor		ebx, ebx											; Clear EBX
   726 0000049A 31ED                    	xor		bp, bp												; Use BP as an entry count
   727 0000049C 66BA50414D53            	mov		edx, $0534D4150										; Place "SMAP" into edx (magic value)
   728 000004A2 66B820E80000            	mov		eax, $0E820											; Function call
   729                                  
   730 000004A8 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   731 000004B1 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   732 000004B7 CD15                    	int		$15
   733                                  
   734 000004B9 7257                    	jc		SHORT .error										; If carry set, the function is unsupported
   735                                  
   736 000004BB 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   737 000004C1 6639D0                  	cmp		eax, edx											; On success, EAX = "SMAP"
   738 000004C4 754C                    	jne		SHORT .error
   739                                  
   740 000004C6 6685DB                  	test	ebx, ebx											; ebx = 0 implies list is only 1 entry long (worthless)
   741 000004C9 7447                    	je		SHORT .error
   742                                  
   743 000004CB EB1F                    	jmp		SHORT .startLoop									; Jump into the loop
   744                                  
   745                                  .getEntryLoop:
   746 000004CD 66B820E80000            	mov		eax, $0E820											; Reset command (EAX, ECX are trashed)
   747 000004D3 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   748 000004DC 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   749 000004E2 CD15                    	int		$15
   750                                  
   751 000004E4 722A                    	jc		SHORT .done											; If carry set, we are done
   752 000004E6 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   753                                  
   754                                  .startLoop:
   755 000004EC E31D                    	jcxz	.skipEntry											; Skip any 0 length entries
   756                                  
   757 000004EE 80F914                  	cmp		cl, 20												; Did we get 24-byte ACPI 3.x data?
   758 000004F1 7607                    	jbe		SHORT .notext
   759                                  
   760 000004F3 26F6451401              	test	BYTE [es:di+20], 1									; If so, is the "ignore this data" bit clear?
   761 000004F8 7411                    	je		SHORT .skipEntry
   762                                  
   763                                  .notext:
   764 000004FA 26668B4D08              	mov		ecx, [es:di+8]										; get lower dword of memory region length
   765 000004FF 26660B4D0C              	or		ecx, [es:di+12]										; Check if zero (OR with upper dword)
   766 00000504 7405                    	jz		.skipEntry											; If length qword is 0, skip entry
   767                                  
   768 00000506 45                      	inc		bp													; We got a good entry, increment count, go to next entry
   769                                  
   770 00000507 81C71800                	add		di, 24
   771                                  
   772                                  .skipEntry:
   773 0000050B 6685DB                  	test	ebx, ebx											; If EBX = 0, then the BIOS has given us all entries
   774 0000050E 75BD                    	jne		SHORT .getEntryLoop
   775                                  
   776                                  .done:
   777 00000510 F8                      	clc															; There is "jc" on end of list to this point, so the carry must be cleared
   778 00000511 C3                      	ret
   779                                  
   780                                  .error:
   781 00000512 F9                      	stc															; Set carry if this BIOS sucks ass and doesn't support this
   782 00000513 C3                      	ret
   783                                  
   784                                  ;========================================================================================
   785                                  ; Writes a register dump to the VGA hardware
   786                                  ;========================================================================================
   787                                  VGA_MISC_WRITE		EQU	$3C2
   788                                  VGA_SEQ_INDEX		EQU	$3C4
   789                                  VGA_SEQ_DATA		EQU	$3C5
   790                                  VGA_CRTC_INDEX		EQU	$3D4
   791                                  VGA_CRTC_DATA		EQU	$3D5
   792                                  VGA_INSTAT_READ		EQU	$3DA
   793                                  
   794                                  NUM_SEQ_REGS		EQU	5
   795                                  NUM_CRTC_REGS		EQU	25
   796                                  
   797                                  write_regs:
   798 00000514 56                      	push 	si
   799 00000515 52                      	push 	dx
   800 00000516 51                      	push 	cx
   801 00000517 50                      	push 	ax
   802 00000518 FC                      	cld
   803                                  
   804                                  ; write MISC register
   805 00000519 BAC203                  	mov 	dx, VGA_MISC_WRITE
   806 0000051C AC                      	lodsb
   807 0000051D EE                      	out 	dx, al
   808                                  
   809                                  ; write SEQuencer registers
   810 0000051E B90500                  	mov 	cx, NUM_SEQ_REGS
   811 00000521 30E4                    	xor 	ah, ah
   812                                  
   813                                  write_seq:
   814 00000523 BAC403                  	mov 	dx, VGA_SEQ_INDEX
   815 00000526 88E0                    	mov 	al, ah
   816 00000528 EE                      	out 	dx, al
   817                                  
   818 00000529 BAC503                  	mov 	dx, VGA_SEQ_DATA
   819 0000052C AC                      	lodsb
   820 0000052D EE                      	out 	dx, al
   821                                  
   822 0000052E FEC4                    	inc 	ah
   823 00000530 E2F1                    	loop 	write_seq
   824                                  
   825                                  ; write CRTC registers
   826                                  ; Unlock CRTC registers: enable writes to CRTC regs 0-7
   827 00000532 BAD403                  	mov 	dx, VGA_CRTC_INDEX
   828 00000535 B011                    	mov 	al, 17
   829 00000537 EE                      	out 	dx, al
   830                                  
   831 00000538 BAD503                  	mov 	dx, VGA_CRTC_DATA
   832 0000053B EC                      	in		al, dx
   833 0000053C 247F                    	and 	al, $7F
   834 0000053E EE                      	out 	dx, al
   835                                  
   836                                  ; Unlock CRTC registers: enable access to vertical retrace regs
   837 0000053F BAD403                  	mov 	dx, VGA_CRTC_INDEX
   838 00000542 B003                    	mov 	al, 3
   839 00000544 EE                      	out 	dx, al
   840                                  
   841 00000545 BAD503                  	mov 	dx ,VGA_CRTC_DATA
   842 00000548 EC                      	in		al, dx
   843 00000549 0C80                    	or		al, $80
   844 0000054B EE                      	out		dx, al
   845                                  
   846                                  ; make sure CRTC registers remain unlocked
   847 0000054C 8A4411                  	mov		al,[si + 17]
   848 0000054F 247F                    	and 	al, $7F
   849 00000551 884411                  	mov 	[si + 17],al
   850                                  
   851 00000554 8A4403                  	mov 	al,[si + 3]
   852 00000557 0C80                    	or		al, $80
   853 00000559 884403                  	mov 	[si + 3], al
   854                                  
   855                                  ; now, finally, write them
   856 0000055C B91900                  	mov 	cx, NUM_CRTC_REGS
   857 0000055F B400                    	mov 	ah, 0
   858                                  
   859                                  write_crtc:
   860 00000561 BAD403                  	mov 	dx, VGA_CRTC_INDEX
   861 00000564 88E0                    	mov 	al, ah
   862 00000566 EE                      	out 	dx, al
   863                                  
   864 00000567 BAD503                  	mov 	dx, VGA_CRTC_DATA
   865 0000056A AC                      	lodsb
   866 0000056B EE                      	out 	dx, al
   867                                  
   868 0000056C FEC4                    	inc 	ah
   869 0000056E E2F1                    	loop write_crtc
   870                                  
   871 00000570 58                      	pop 	ax
   872 00000571 59                      	pop 	cx
   873 00000572 5A                      	pop 	dx
   874 00000573 5E                      	pop 	si
   875 00000574 C3                      	ret
   876                                  
   877                                  ;========================================================================================
   878                                  ; DATA SECTION
   879                                  ;========================================================================================
   880                                  regs_90x60:
   881                                  ; MISC
   882 00000575 E7                      	db	0E7h
   883                                  ; SEQuencer
   884 00000576 0301030002              	db	03h, 01h, 03h, 00h, 02h
   885                                  ; CRTC
   886 0000057B 6B595A82608D0B3E        	db	6Bh, 59h,  5Ah, 82h, 60h,  8Dh, 0Bh,  3Eh,
   887 00000583 0047060700000000        	db	00h, 47h,  06h, 07h, 00h,  00h, 00h,  00h,
   888 0000058B EA0CDF2D08E805A3        	db	0EAh, 0Ch, 0DFh, 2Dh, 08h, 0E8h, 05h, 0A3h,
   889 00000593 FF                      	db 	0FFh
   890                                  ; GC (no)
   891                                  ; AC (no)
   892                                  
   893                                  str_stage2loaded:
   894 00000594 537461676520322042-     	db 	'Stage 2 Bootloader (boot2)', 0
   895 0000059D 6F6F746C6F61646572-
   896 000005A6 2028626F6F74322900 
   897                                  
   898                                  str_errorDetectMem:
   899 000005AF 4572726F7220646574-     	db 	"Error detecting available memory, cannot continue", 0
   900 000005B8 656374696E67206176-
   901 000005C1 61696C61626C65206D-
   902 000005CA 656D6F72792C206361-
   903 000005D3 6E6E6F7420636F6E74-
   904 000005DC 696E756500         
   905                                  
   906                                  str_floppyError:
   907 000005E1 466C6F707079204572-     	db 	"Floppy Error, press any key to retry", $0A, 0
   908 000005EA 726F722C2070726573-
   909 000005F3 7320616E79206B6579-
   910 000005FC 20746F207265747279-
   911 00000605 0A00               
   912                                  
   913                                  str_available_lomem:
   914 00000607 436F6E74696E756F75-     	db 	"Continuous 01K blocks below 0x01000000: 0x", 0
   915 00000610 732030314B20626C6F-
   916 00000619 636B732062656C6F77-
   917 00000622 203078303130303030-
   918 0000062B 30303A20307800     
   919                                  
   920                                  str_available_himem:
   921 00000632 436F6E74696E756F75-     	db 	"Continuous 64K blocks above 0x01000000: 0x", 0
   922 0000063B 732036344B20626C6F-
   923 00000644 636B732061626F7665-
   924 0000064D 203078303130303030-
   925 00000656 30303A20307800     
   926                                  
   927                                  str_select_partition:
   928 0000065D 557365207468652063-     	db 	"Use the cursor to select the partition to boot from.", 0
   929 00000666 7572736F7220746F20-
   930 0000066F 73656C656374207468-
   931 00000678 652070617274697469-
   932 00000681 6F6E20746F20626F6F-
   933 0000068A 742066726F6D2E00   
   934                                  
   935                                  str_err_not_bootable:
   936 00000692 546869732070617274-     	db 	"This partition is not marked as bootable!", 0
   937 0000069B 6974696F6E20697320-
   938 000006A4 6E6F74206D61726B65-
   939 000006AD 6420617320626F6F74-
   940 000006B6 61626C652100       
   941                                  
   942                                  str_err_kern_not_found:
   943 000006BC 436F756C64206E6F74-     	db	"Could not find KERNEL.BIN at the root of the drive!", 0
   944 000006C5 2066696E64204B4552-
   945 000006CE 4E454C2E42494E2061-
   946 000006D7 742074686520726F6F-
   947 000006E0 74206F662074686520-
   948 000006E9 64726976652100     
   949                                  
   950                                  str_err_clear_err:
   951 000006F0 20<rept>                	times	0x40 db 0x20
   952 00000730 00                      	db	0
   953                                  
   954                                  
   955                                  str_kernel_loading:
   956 00000731 4C6F6164696E67206B-     	db 	"Loading kernel: ", 0
   957 0000073A 65726E656C3A2000   
   958                                  
   959                                  str_kernel_loaded_ok:
   960 00000742 4B65726E656C206C6F-     	db 	"Kernel loaded. Transferring control now...", 0
   961 0000074B 616465642E20547261-
   962 00000754 6E7366657272696E67-
   963 0000075D 20636F6E74726F6C20-
   964 00000766 6E6F772E2E2E00     
   965                                  
   966                                  str_err_loadkernel:
   967 0000076D 436F756C64206E6F74-     	db 	"Could not load kernel: Fuck you", 0
   968 00000776 206C6F6164206B6572-
   969 0000077F 6E656C3A204675636B-
   970 00000788 20796F7500         
   971                                  
   972                                  BootDevice:
   973 0000078D 00                      	db	0
   974                                  
   975                                  LastCursorPosition:
   976 0000078E 0000                    	dw	0
   977                                  
   978                                  MemBlocksAbove16M:
   979 00000790 0000                    	dw	0
   980                                  
   981                                  MemBlocksBelow16M:
   982 00000792 0000                    	dw	0
   983                                  
   984                                  MemMap_NumEntries:
   985 00000794 0000                    	dw	0
   986                                  
   987                                  HDD_BootablePartitions:
   988 00000796 00000000                	dd	0
   989                                  
   990                                  HDD_BootablePartitionsFATType:
   991 0000079A 00000000                	dd	0
   992                                  
   993                                  HDD_Selected:
   994 0000079E 00                      	db	0
   995                                  
   996                                  HDD_PartitionNames:
   997 0000079F 00<rept>                	times	(0xB+1)*4 db 0
   998                                  
   999                                  Temp_StrBuf:
  1000 000007CF 00<rept>                	times	0x20 db 0
  1001                                  
  1002 000007EF 90                      	align 2
  1003                                  ExtendedRead_Table:
  1004 000007F0 10                      	db	$10
  1005 000007F1 00                      	db	0
  1006 000007F2 0000                    	dw	0														; Num blocks
  1007 000007F4 0000                    	dw	0														; Dest
  1008 000007F6 0000                    	dw	0														; Memory page
  1009 000007F8 00000000                	dd	0														; Starting LBA
  1010 000007FC 00000000                	dd	0	
  1011                                  
  1012                                  kernel_cluster:
  1013 00000800 00000000                	dd	0
  1014                                  
  1015                                  kernel_filename:
  1016 00000804 4B45524E454C202042-     	db	"KERNEL  BIN", 0
  1017 0000080D 494E00             
  1018                                  
  1019                                  ;========================================================================================
  1020                                  ; Global Descriptor Table
  1021                                  ;========================================================================================
  1022                                  	align	$10
  1023                                  
  1024                                  gdt_start:
  1025 00000810 0000000000000000        	dd	$00, $00												; Null Descriptor
  1026                                  
  1027                                  	; Code segment
  1028 00000818 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
  1029 0000081A 0000                    	dw	$0000													; Base 0:15 = $0000
  1030 0000081C 00                      	db	$00														; Base 16:23 = $00
  1031 0000081D 9A                      	db	$9A														; Access byte: Present, ring 0, Exec, grow up, R/W
  1032 0000081E CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
  1033 0000081F 00                      	db	$00														; Base 24:31 = $00
  1034                                  
  1035                                  	; Data segment
  1036 00000820 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
  1037 00000822 0000                    	dw	$0000													; Base 0:15 = $0000
  1038 00000824 00                      	db	$00														; Base 16:23 = $00
  1039 00000825 92                      	db	$92														; Access byte: Present, ring 0, Not exec, grow up, R/W
  1040 00000826 CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
  1041 00000827 00                      	db	$00														; Base 24:31 = $00	
  1042                                  
  1043                                  gdt_table:
  1044 00000828 1700                    	dw	(gdt_table-gdt_start)-1									; Length
  1045 0000082A [10080000]              	dd	gdt_start												; Physical address to GDT	
  1046                                  
  1047 0000082E 90<rept>                	align 4														; DWORD align
  1048                                  	%include	"./fat.asm"
  1049                              <1> ;========================================================================================
  1050                              <1> ; FAT Filesystem Library v 0.1
  1051                              <1> ; By Tristan Seifert
  1052                              <1> ;
  1053                              <1> ; All sector values returned by functions are "logical," i.e. they are relative to the
  1054                              <1> ; first sector of the filesystem.
  1055                              <1> ;
  1056                              <1> ; In addition, this library does not offer full support for FAT12 due to the uncommonality
  1057                              <1> ; of it on media besides floppy disks.
  1058                              <1> ;========================================================================================
  1059                              <1> ; Equates
  1060                              <1> ;========================================================================================
  1061                              <1> 
  1062                              <1> ;========================================================================================
  1063                              <1> ; Initialises the FAT filesystem library
  1064                              <1> ;========================================================================================
  1065                              <1> FAT_Init:
  1066 00000830 B90001              <1> 	mov		cx, (1024/4)										; Clear 2 sectors worth
  1067 00000833 66BA[C00B0000]      <1> 	mov		edx, FAT_ReadBuffer									; Pointer to buffer
  1068 00000839 6631C0              <1> 	xor		eax, eax											; Clear value ($00000000)
  1069                              <1> 
  1070                              <1> .clearLoop:
  1071 0000083C 66678902            <1> 	mov		DWORD [edx], eax									; Clear a DWORD
  1072 00000840 6681C204000000      <1> 	add		edx, $04											; Increment pointer
  1073 00000847 E2F3                <1> 	loop	.clearLoop											; Loop
  1074                              <1> 
  1075                              <1> .done:
  1076 00000849 C3                  <1> 	ret
  1077                              <1>  
  1078                              <1> ;========================================================================================
  1079                              <1> ; Determines the type of FAT, give that the first logical sector of the partition is
  1080                              <1> ; pointed to by SI, and returns the FAT bit size in AL.
  1081                              <1> ;
  1082                              <1> ; This is how Microsoft recommends we determine FAT type:
  1083                              <1> ;
  1084                              <1> ; RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytesPerSec - 1)) / BPB_BytesPerSec
  1085                              <1> ; DataSectors = Total Sectors - (BPB_ReservedSectors + (BPB_NumFATs * FATSz) + RootDirSectors)
  1086                              <1> ; Count of clusters = DataSectors/BPB_SectorsPerCluster 
  1087                              <1> ;
  1088                              <1> ; FAT12: Total clusters < 4085
  1089                              <1> ; FAT16: Total clusters > 4085 && < 65525
  1090                              <1> ; FAT32: Total clusters > 65525
  1091                              <1> ;========================================================================================
  1092                              <1> FAT_DetermineType:
  1093 0000084A 60                  <1> 	pusha														; Push registers
  1094                              <1> 
  1095 0000084B E8EF00              <1> 	call	FAT_ReadBPB											; 
  1096                              <1> 
  1097                              <1> 	; Calculate RootDirSectors
  1098 0000084E 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1099 00000851 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1100 00000854 8B1E[7E0B]          <1> 	mov		bx,	WORD [FAT_BPB_RootEntCnt]						; Read root entries 
  1101 00000858 66C1E305            <1> 	shl		ebx, 5												; Each root entry is 32 bytes
  1102                              <1> 
  1103 0000085C A1[6C0B]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1104 0000085F 48                  <1> 	dec		ax													; Subtract one
  1105 00000860 6601D8              <1> 	add		eax, ebx											; Add root entry length to sector length
  1106                              <1> 
  1107 00000863 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1108 00000866 8B0E[6C0B]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1109 0000086A F7F1                <1> 	div		cx													; Divide by sector length (result = ax)
  1110 0000086C A3[880B]            <1> 	mov		WORD [FAT_RootDirSectors], ax						; Store result in memory
  1111                              <1> 
  1112                              <1> 	; Calculate number of data sectors
  1113 0000086F 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1114 00000872 A0[7C0B]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1115                              <1> 
  1116 00000875 668B0E[800B]        <1> 	mov		ecx, DWORD [FAT_BPB_FATSz]							; Read FAT size
  1117 0000087A 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in eax
  1118                              <1> 
  1119 0000087D 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1120 00000880 8B0E[7A0B]          <1> 	mov		cx, WORD [FAT_BPB_ReservedSectors]					; Read number of reserved sectors
  1121                              <1> 
  1122 00000884 6601C8              <1> 	add		eax, ecx											; Add count of reserved sectors to FAT size
  1123 00000887 668B0E[880B]        <1> 	mov		ecx, DWORD [FAT_RootDirSectors]						; Read RootDirSectors
  1124 0000088C 6601C8              <1> 	add		eax, ecx											; Add root directory sectors
  1125                              <1> 
  1126 0000088F 6691                <1> 	xchg	eax, ecx											; Subtract all of the above from total sectors
  1127                              <1> 
  1128 00000891 66A1[840B]          <1> 	mov		eax, DWORD [FAT_BPB_TotSec]							; Read total sector count
  1129 00000895 6629C8              <1> 	sub		eax, ecx											; Subtract from total sector count
  1130                              <1> 
  1131 00000898 66A3[8C0B]          <1> 	mov		DWORD [FAT_DataSectors], eax						; Store to memory
  1132                              <1> 
  1133                              <1> 	; Calculate cluster count
  1134 0000089C 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1135 0000089F 8A1E[780B]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1136 000008A3 66A1[8C0B]          <1> 	mov		eax, DWORD [FAT_DataSectors]						; Read number of data sectors
  1137 000008A7 66F7F3              <1> 	div		ebx													; Divide by sectors/cluster value 
  1138                              <1> 
  1139 000008AA 66A3[980B]          <1> 	mov		DWORD [FAT_TotalClusters], eax						; Store result in EAX
  1140                              <1> 
  1141                              <1> 	; Now, do some comparisons!
  1142 000008AE 663DF50F0000        <1> 	cmp		eax, 4085											; Is the FS FAT12?
  1143 000008B4 7F07                <1> 	jg		.notFAT12											; If not, branch
  1144                              <1> 
  1145 000008B6 C606[A00B]0C        <1> 	mov		BYTE [FAT_Type], 12									; FAT12
  1146 000008BB EB17                <1> 	jmp		SHORT .done											; Return
  1147                              <1> 
  1148                              <1> .notFAT12:
  1149 000008BD 663DF5FF0000        <1> 	cmp		eax, 65525											; Is the FS FAT16?
  1150 000008C3 7F0A                <1> 	jg		.notFAT16											; If not, branch
  1151                              <1> 
  1152 000008C5 E84C00              <1> 	call	FAT16_Calculate_RootDirSec							; Calculate location of root directory
  1153                              <1> 
  1154 000008C8 C606[A00B]10        <1> 	mov		BYTE [FAT_Type], 16									; FAT16
  1155 000008CD EB05                <1> 	jmp		SHORT .done											; Return
  1156                              <1> 
  1157                              <1> .notFAT16:
  1158                              <1> 	; Okay, if we get down here, it HAS to be FAT32 or a corrupt FS
  1159 000008CF C606[A00B]20        <1> 	mov		BYTE [FAT_Type], 32									; FAT32
  1160                              <1> 
  1161                              <1> .done:
  1162 000008D4 E80500              <1> 	call	FAT_Calculate_Misc									; Calculate miscellaneous stuff
  1163 000008D7 61                  <1> 	popa														; Restore registers
  1164                              <1> 
  1165 000008D8 A0[A00B]            <1> 	mov		al, BYTE [FAT_Type]									; Store FAT type in AL
  1166                              <1> 
  1167 000008DB C3                  <1> 	ret
  1168                              <1> 
  1169                              <1> ;========================================================================================
  1170                              <1> ; Calculates miscellaneous values that the FAT driver uses later
  1171                              <1> ;========================================================================================
  1172                              <1> FAT_Calculate_Misc:
  1173 000008DC 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1174 000008DF 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1175 000008E2 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1176                              <1> 
  1177 000008E5 8B0E[880B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1178 000008E9 8B1E[7A0B]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1179                              <1> 
  1180 000008ED 6601CB              <1> 	add		ebx, ecx											; Add to root dir sectors reserved sectors
  1181                              <1> 
  1182 000008F0 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1183 000008F3 8A0E[7C0B]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1184 000008F7 66A1[800B]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1185 000008FB 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1186                              <1> 
  1187 000008FE 6601D8              <1> 	add		eax, ebx											; Add FAT sectors to root dir and reserved count
  1188                              <1> 
  1189 00000901 66A3[900B]          <1> 	mov		DWORD [FAT_FirstDataSector], eax					; Store first data sector
  1190                              <1> 
  1191 00000905 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1192 00000908 8B0E[880B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1193 0000090C 6629C8              <1> 	sub		eax, ecx											; Subtract ecx
  1194 0000090F 66A3[940B]          <1> 	mov		DWORD [FAT_FirstClusterLocation], eax				; Write shaften
  1195 00000913 C3                  <1> 	ret
  1196                              <1> 
  1197                              <1> ;========================================================================================
  1198                              <1> ; Calculates the sector for the root directory for FAT12 and FAT16.
  1199                              <1> ;========================================================================================
  1200                              <1> FAT16_Calculate_RootDirSec:
  1201 00000914 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1202 00000917 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1203 0000091A 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1204                              <1> 
  1205 0000091D 8B1E[7A0B]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1206                              <1> 
  1207 00000921 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1208 00000924 A0[7C0B]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1209                              <1> 
  1210 00000927 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1211 0000092A 8A0E[7C0B]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1212 0000092E 66A1[800B]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1213 00000932 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1214                              <1> 
  1215 00000935 6601D8              <1> 	add		eax, ebx											; Add reserved sector count
  1216                              <1> 
  1217 00000938 66A3[740B]          <1> 	mov		DWORD [FAT_BPB_RootClus], eax						; Write location of root cluster
  1218                              <1> 
  1219                              <1> .done:
  1220 0000093C C3                  <1> 	ret
  1221                              <1> 
  1222                              <1> ;========================================================================================
  1223                              <1> ; Reads the BPB from the FAT 1st sector in SI.
  1224                              <1> ;========================================================================================
  1225                              <1> FAT_ReadBPB:
  1226 0000093D 8B440B              <1> 	mov		ax, WORD [si+11]									; Read Bytes/sector
  1227 00000940 A3[6C0B]            <1> 	mov		WORD [FAT_BPB_BytesPerSec], ax						; ""
  1228                              <1> 
  1229 00000943 8A440D              <1> 	mov		al, BYTE [si+13]									; Read sectors/cluster
  1230 00000946 A2[780B]            <1> 	mov		BYTE [FAT_BPB_SectorsPerCluster], al				; ""
  1231                              <1> 
  1232 00000949 8B440E              <1> 	mov		ax, WORD [si+14]									; Read reserved sectors
  1233 0000094C A3[7A0B]            <1> 	mov		WORD [FAT_BPB_ReservedSectors], ax					; ""
  1234                              <1> 
  1235 0000094F 8A4410              <1> 	mov		al, BYTE [si+16]									; Read number of FATs
  1236 00000952 A2[7C0B]            <1> 	mov		BYTE [FAT_BPB_NumFATs], al							; ""
  1237                              <1> 
  1238 00000955 8B4411              <1> 	mov		ax, WORD [si+17]									; Read num root entries
  1239 00000958 A3[7E0B]            <1> 	mov		WORD [FAT_BPB_RootEntCnt], ax						; ""
  1240                              <1> 
  1241 0000095B 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1242                              <1> 
  1243 0000095E 668B4420            <1> 	mov		eax, DWORD [si+32]									; Read BPB_TotSec32 first
  1244 00000962 663D00000000        <1> 	cmp		eax, 0												; Is EAX zero?
  1245 00000968 7503                <1> 	jne		.writeTotSec										; If not, branch
  1246                              <1> 
  1247 0000096A 8B4413              <1> 	mov		ax, WORD [si+19]									; Read BPB_TotSec16 first
  1248                              <1> 
  1249                              <1> .writeTotSec:
  1250 0000096D 66A3[840B]          <1> 	mov		DWORD [FAT_BPB_TotSec], eax							; ""
  1251                              <1> 
  1252 00000971 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1253                              <1> 
  1254 00000974 8B4416              <1> 	mov		ax, WORD [si+22]									; Read BPB_FATSz16
  1255 00000977 3D0000              <1> 	cmp		ax, 0												; Is it zero?
  1256 0000097A 7507                <1> 	jne		.writeFATSz											; If not, branch.
  1257                              <1> 
  1258 0000097C 668B4424            <1> 	mov		eax, DWORD [si+36]									; Read BPB_FATSz32
  1259                              <1> 
  1260 00000980 E80500              <1> 	call	.readFAT32Specifics									; Read FAT32-specific data
  1261                              <1> 
  1262                              <1> .writeFATSz:
  1263 00000983 66A3[800B]          <1> 	mov		DWORD [FAT_BPB_FATSz], eax							; Write FAT size
  1264                              <1> 
  1265 00000987 C3                  <1> 	ret
  1266                              <1> 
  1267                              <1> ; All FAT32-specific stuff is read here
  1268                              <1> .readFAT32Specifics:
  1269 00000988 8B5C28              <1> 	mov		bx, WORD [si+40]									; Read BPB_ExtFlags
  1270 0000098B 891E[700B]          <1> 	mov		WORD [FAT_BPB_ExtFlags], bx							; Write BPB_ExtFlags
  1271                              <1> 
  1272 0000098F 8B5C2A              <1> 	mov		bx, WORD [si+42]									; Read BPB_FSVer
  1273 00000992 891E[720B]          <1> 	mov		WORD [FAT_BPB_FSVer], bx							; Write BPB_FSVer
  1274                              <1> 
  1275 00000996 668B5C2C            <1> 	mov		ebx, DWORD [si+44]									; Read BPB_RootClus
  1276 0000099A 66891E[740B]        <1> 	mov		DWORD [FAT_BPB_RootClus], ebx						; Write BPB_RootClus
  1277                              <1> 
  1278 0000099F 8B5C30              <1> 	mov		bx, WORD [si+48]									; Read BPB_FSInfo
  1279 000009A2 891E[6E0B]          <1> 	mov		WORD [FAT_BPB_FSInfo], bx							; Write BPB_FSInfo
  1280                              <1> 
  1281                              <1> 
  1282 000009A6 C3                  <1> 	ret
  1283                              <1> 
  1284                              <1> ;========================================================================================
  1285                              <1> ; Calculates the entry location for cluster N in the FAT.
  1286                              <1> ; eax: Cluster number
  1287                              <1> ; eax: Sector number containing the cluster
  1288                              <1> ; ebx: Offset in sector
  1289                              <1> ;========================================================================================
  1290                              <1> FAT_FindClusterInTable:
  1291 000009A7 60                  <1> 	pusha														; Back up regs
  1292                              <1> 
  1293 000009A8 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1294 000009AB 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1295                              <1> 
  1296 000009AE 8A1E[A00B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1297 000009B2 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1298 000009B5 7406                <1> 	je		.FAT32												; If so, jump
  1299                              <1> 
  1300 000009B7 66D1E0              <1> 	shl		eax, 1												; Multiply cluster by 2
  1301 000009BA E90400              <1> 	jmp		.cont												; Skip over shift below
  1302                              <1> 
  1303                              <1> .FAT32:
  1304 000009BD 66C1E002            <1> 	shl		eax, 2												; Multiply cluster by 4
  1305                              <1> 
  1306                              <1> .cont:
  1307                              <1> 	; eax = Offset into FAT table
  1308                              <1> 
  1309 000009C1 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1310 000009C4 8B0E[6C0B]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1311 000009C8 66F7F1              <1> 	div		ecx													; Divide offset by bytes/sector
  1312                              <1> 	; eax = quotient, edx = remainder
  1313                              <1> 
  1314 000009CB 8B1E[7A0B]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; BX = reserved sector count
  1315 000009CF 6601D8              <1> 	add		eax, ebx											; Add to FAT offset (sectors)
  1316                              <1> 
  1317 000009D2 66A3[E709]          <1> 	mov		DWORD [.secNum], eax								; Store sector number
  1318 000009D6 8916[EB09]          <1> 	mov		WORD [.secOff], dx									; Store offset into sector
  1319                              <1> 
  1320                              <1> .done:
  1321 000009DA 61                  <1> 	popa														; Restore regs
  1322                              <1> 
  1323 000009DB 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1324 000009DE 66A1[E709]          <1> 	mov		eax, DWORD [.secNum]								; Get sector number
  1325 000009E2 8B1E[EB09]          <1> 	mov		bx, WORD [.secOff]									; Get offset into sector
  1326                              <1> 
  1327 000009E6 C3                  <1> 	ret
  1328                              <1> 
  1329                              <1> .secNum:
  1330 000009E7 00000000            <1> 	dd		0
  1331                              <1> 
  1332                              <1> .secOff:
  1333 000009EB 0000                <1> 	dw		0
  1334                              <1> 
  1335                              <1> ;========================================================================================
  1336                              <1> ; Converts the cluster number in eax into a sector number.
  1337                              <1> ;========================================================================================
  1338                              <1> FAT_ClusterToSector:
  1339 000009ED 6651                <1> 	push	ecx													; Back up EBX
  1340                              <1> 
  1341 000009EF 6648                <1> 	dec		eax													; Subtract 2 from cluster
  1342 000009F1 6648                <1> 	dec		eax													; ""
  1343                              <1> 
  1344 000009F3 6631C9              <1> 	xor		ecx, ecx											; Clear EBX
  1345 000009F6 8A0E[780B]          <1> 	mov		cl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1346 000009FA 66F7E1              <1> 	mul		ecx													; Multiply by number of sectors per cluster
  1347                              <1> 
  1348 000009FD 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1349 00000A00 8B0E[880B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Root directory sector
  1350 00000A04 6601C8              <1> 	add		eax, ecx											; Add to sector count
  1351                              <1> 
  1352 00000A07 668B0E[900B]        <1> 	mov		ecx, DWORD [FAT_FirstDataSector]					; Get first data sector
  1353 00000A0C 6601C8              <1> 	add		eax, ecx											; Add data sector offset
  1354                              <1> 
  1355 00000A0F 6659                <1> 	pop		ecx													; Restore EBX
  1356                              <1> 
  1357 00000A11 C3                  <1> 	ret
  1358                              <1> 
  1359                              <1> ;========================================================================================
  1360                              <1> ; Reads the sector containing the FAT entry for the specified cluster, then returns the
  1361                              <1> ; FAT read from the sector.
  1362                              <1> ; eax: Cluster
  1363                              <1> ; Sets carry flag if error.
  1364                              <1> ;========================================================================================
  1365                              <1> FAT_ReadFAT:
  1366 00000A12 E892FF              <1> 	call	FAT_FindClusterInTable								; Locate cluster
  1367 00000A15 6653                <1> 	push	ebx													; Push offset into sector to stack
  1368                              <1> 
  1369                              <1> 	; Read sector to memory
  1370 00000A17 E82500              <1> 	call	FAT_ReadSector										; Read sector
  1371 00000A1A 665B                <1> 	pop		ebx													; Pop offset into sector
  1372 00000A1C 721F                <1> 	jc 		SHORT .error										; If error, return
  1373                              <1> 
  1374                              <1> 	; Sector is now read to memory
  1375 00000A1E 8A1E[A00B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1376 00000A22 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1377 00000A25 740D                <1> 	je		.FAT32												; If so, jump
  1378                              <1> 
  1379 00000A27 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1380 00000A2A 678B83[C00B0000]    <1> 	mov		ax, WORD [FAT_ReadBuffer+ebx]						; Read FAT16 entry
  1381 00000A31 E90800              <1> 	jmp		.done												; Skip over read below
  1382                              <1> 
  1383                              <1> .FAT32:
  1384 00000A34 66678B83[C00B0000]  <1> 	mov		eax, DWORD [FAT_ReadBuffer+ebx]						; Read FAT32 entry
  1385                              <1> 
  1386                              <1> .done:
  1387 00000A3C C3                  <1> 	ret
  1388                              <1> 
  1389                              <1> .error:
  1390 00000A3D F9                  <1> 	stc															; Set carry
  1391 00000A3E C3                  <1> 	ret
  1392                              <1> 
  1393                              <1> ;========================================================================================
  1394                              <1> ; Reads a logical sector from the drive.
  1395                              <1> ; eax: Logical sector
  1396                              <1> ; Clears the carry flag if successful, set otherwise.
  1397                              <1> ;========================================================================================
  1398                              <1> FAT_ReadSector:
  1399 00000A3F 660306[9C0B]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1400                              <1> 
  1401 00000A44 668B1E[A40B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1402 00000A49 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1403 00000A4C 7429                <1> 	je		.done												; If they are the same sector, branch
  1404                              <1> 
  1405 00000A4E 66A3[B00B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1406 00000A52 C706[AA0B]0100      <1> 	mov		WORD [FAT_ERTable+0x02], 0x01						; Read one sector
  1407 00000A58 C706[AC0B][C00B]    <1> 	mov		WORD [FAT_ERTable+0x04], FAT_ReadBuffer				; Temporary sector buffer offset (seg 0)
  1408 00000A5E C706[AE0B]0000      <1> 	mov		WORD [FAT_ERTable+0x06], 0x00						; Page 0
  1409                              <1> 
  1410 00000A64 66A3[A40B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Store LBA we're loading
  1411                              <1> 
  1412 00000A68 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1413 00000A69 BE[A80B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1414 00000A6C B442                <1> 	mov 	ah, $42												; Extended Read
  1415 00000A6E 8A16[A10B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1416 00000A72 CD13                <1> 	int 	$13													; Perform read
  1417 00000A74 61                  <1> 	popa														; Pop registers
  1418 00000A75 7202                <1> 	jc 		SHORT .error										; If error, return
  1419                              <1> 
  1420                              <1> .done:
  1421 00000A77 F8                  <1> 	clc															; Clear carry
  1422 00000A78 C3                  <1> 	ret
  1423                              <1> 
  1424                              <1> .error:
  1425 00000A79 F9                  <1> 	stc															; Set carry
  1426 00000A7A C3                  <1> 	ret
  1427                              <1> 
  1428                              <1> ;========================================================================================
  1429                              <1> ; Tries to locate a file with the name pointed to by in esi in the root directory of the
  1430                              <1> ; FAT. If found, returns the first cluster of the file in eax, filesize in ebx, and
  1431                              <1> ; clears carry. If not found, sets carry.
  1432                              <1> ;
  1433                              <1> ; Note that this only searches the short filename.
  1434                              <1> ;========================================================================================
  1435                              <1> FAT_FindFileAtRoot:
  1436 00000A7B 60                  <1> 	pusha														; Push regs
  1437 00000A7C 66A1[740B]          <1> 	mov		eax, DWORD [FAT_BPB_RootClus]						; Read root sector location
  1438 00000A80 E86AFF              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1439 00000A83 E8B9FF              <1> 	call	FAT_ReadSector										; Read sector
  1440                              <1> 
  1441 00000A86 66BF[C00B0000]      <1> 	mov		edi, FAT_ReadBuffer									; FAT read buffer
  1442 00000A8C B91000              <1> 	mov		cx, (512/32)										; Search the first 512/32 entries
  1443                              <1> 
  1444                              <1> .searchLoop:
  1445 00000A8F 678A07              <1> 	mov		al, BYTE [edi]										; Read first byte of string
  1446                              <1> 
  1447 00000A92 3CE5                <1> 	cmp		al, $0E5											; Is directory entry free?
  1448 00000A94 7426                <1> 	je		.fileEntryIgnore									; If so, branch
  1449 00000A96 3C00                <1> 	cmp		al, $00												; Is directory entry free and last one?
  1450 00000A98 7428                <1> 	je		.notFound											; If so, exit loop.
  1451                              <1> 
  1452                              <1> 	; Store pointers
  1453 00000A9A 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1454 00000A9D 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1455 00000AA0 6689F8              <1> 	mov		eax, edi											; Copy read pointer to EAX
  1456 00000AA3 6689F2              <1> 	mov		edx, esi											; Copy filename compare ptr to EDX
  1457                              <1> 
  1458                              <1> 	; Compare filename
  1459 00000AA6 51                  <1> 	push	cx													; Push loop counter
  1460 00000AA7 B90B00              <1> 	mov		cx, $0B												; Filename is 11 bytes
  1461                              <1> 
  1462                              <1> .comparison:
  1463 00000AAA 678A18              <1> 	mov		bl, BYTE [eax]										; Read soruce ptr
  1464 00000AAD 673A1A              <1> 	cmp		bl, BYTE [edx]										; Compare against target
  1465 00000AB0 7509                <1> 	jne		.compareFailed										; If not equal, branch
  1466                              <1> 
  1467 00000AB2 6640                <1> 	inc		eax													; Increment read pointer
  1468 00000AB4 6642                <1> 	inc		edx													; Increment target pointer
  1469                              <1> 
  1470 00000AB6 E2F2                <1> 	loop	.comparison											; Compare 11 bytes
  1471                              <1> 
  1472 00000AB8 59                  <1> 	pop		cx													; Pop loop counter from stack
  1473 00000AB9 EB0A                <1> 	jmp		SHORT .found										; File was found
  1474                              <1> 
  1475                              <1> .compareFailed:
  1476 00000ABB 59                  <1> 	pop		cx													; Pop loop counter
  1477                              <1> 
  1478                              <1> .fileEntryIgnore:
  1479 00000ABC 81C72000            <1> 	add		di, $20												; Read next entry
  1480 00000AC0 E2CD                <1> 	loop	.searchLoop											; Loop through entries
  1481                              <1> 
  1482                              <1> ; Drop down here once loop finishes: file not found.
  1483                              <1> .notFound:
  1484 00000AC2 61                  <1> 	popa														; Pop registers
  1485 00000AC3 F9                  <1> 	stc															; Set carry
  1486 00000AC4 C3                  <1> 	ret
  1487                              <1> 
  1488                              <1> ; We found the file
  1489                              <1> .found:
  1490 00000AC5 678B471A            <1> 	mov		ax, WORD [edi+26]									; Read cluster low word
  1491 00000AC9 A3[E80A]            <1> 	mov		WORD [.clusterOfFile], ax							; ""
  1492 00000ACC 678B4714            <1> 	mov		ax, WORD [edi+20]									; Read cluster high word
  1493 00000AD0 A3[EA0A]            <1> 	mov		WORD [.clusterOfFile+2], ax							; ""
  1494                              <1> 
  1495 00000AD3 66678B471C          <1> 	mov		eax, DWORD [edi+28]									; Read filesize
  1496 00000AD8 66A3[EC0A]          <1> 	mov		DWORD [.sizeOfFile], eax							; ""
  1497                              <1> 
  1498 00000ADC 61                  <1> 	popa														; Pop registers
  1499 00000ADD 66A1[E80A]          <1> 	mov		eax, DWORD [.clusterOfFile]							; Read file's cluster
  1500 00000AE1 668B1E[EC0A]        <1> 	mov		ebx, DWORD [.sizeOfFile]							; Read file's size
  1501 00000AE6 F8                  <1> 	clc															; Clear carry bit
  1502 00000AE7 C3                  <1> 	ret
  1503                              <1> 
  1504                              <1> 	align	4
  1505                              <1> .clusterOfFile:
  1506 00000AE8 00000000            <1> 	dd		0
  1507                              <1> .sizeOfFile:
  1508 00000AEC 00000000            <1> 	dd		0
  1509                              <1> 
  1510                              <1> ;========================================================================================
  1511                              <1> ; Reads the file whose first cluster is in eax to es:di.
  1512                              <1> ;
  1513                              <1> ; Note that this function returns after reading a maximum of 256 chunks.
  1514                              <1> ;========================================================================================
  1515                              <1> FAT_ReadFile:
  1516 00000AF0 60                  <1> 	pusha														; Push all regisers
  1517                              <1> 
  1518 00000AF1 E80800              <1> 	call	FAT_ReadCluster										; Read cluster
  1519 00000AF4 7203                <1> 	jc 		SHORT .error										; If error, return
  1520                              <1> 
  1521                              <1> ;	xor		cx, cx												; Clear CX
  1522                              <1> ;	mov		gs, cx												; Clear GS
  1523                              <1> ;
  1524                              <1> ;.readLoop:
  1525                              <1> ;	call	FAT_ReadFAT											; Read FAT entry for current cluster
  1526                              <1> ;	and		eax, $0FFFFFFF										; Ignore high nybble
  1527                              <1> ;	cmp		eax, $0FFFFFF8										; End of chain marker?
  1528                              <1> ;	jae		.done												; If so, branch (unsigned compare)
  1529                              <1> ;
  1530                              <1> ;	call	FAT_ReadCluster										; Read cluster
  1531                              <1> ;	jc 		SHORT .error										; If error, return
  1532                              <1> ;
  1533                              <1> ;	mov		cx, gs												; Read GS
  1534                              <1> ;	inc		cx													; Increment GS
  1535                              <1> ;	mov		gs, cx												; Move back to GS
  1536                              <1> ;
  1537                              <1> ;	cmp		cl, $0FF											; Is it max? ($FF)
  1538                              <1> ;	je		.error												; If so, we're done
  1539                              <1> ;
  1540                              <1> ;	jmp		.readLoop											; Loop until all sectors of the file are read
  1541                              <1> 
  1542                              <1> .done:
  1543 00000AF6 61                  <1> 	popa														; Pop registers
  1544 00000AF7 F8                  <1> 	clc															; Clear carry
  1545 00000AF8 C3                  <1> 	ret
  1546                              <1> 
  1547                              <1> .error:
  1548 00000AF9 61                  <1> 	popa														; Pop registers
  1549 00000AFA F9                  <1> 	stc															; Set carry
  1550 00000AFB C3                  <1> 	ret
  1551                              <1> 
  1552                              <1> ;========================================================================================
  1553                              <1> ; Reads a logical sector from the drive.
  1554                              <1> ; eax: Logical cluster
  1555                              <1> ; es:di: Memory location (Incremented after read)
  1556                              <1> ; Clears the carry flag if successful, set otherwise.
  1557                              <1> ;========================================================================================
  1558                              <1> FAT_ReadCluster:
  1559 00000AFC 66A3[680B]          <1> 	mov		DWORD [.origCluster], eax							; Store original cluster
  1560 00000B00 E8EAFE              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1561                              <1> 
  1562 00000B03 660306[9C0B]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1563                              <1> 
  1564 00000B08 668B1E[A40B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1565 00000B0D 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1566 00000B10 742E                <1> 	je		.done												; If they are the same sector, branch
  1567 00000B12 66A3[A40B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Save sector we're reading
  1568                              <1> 
  1569 00000B16 31DB                <1> 	xor		bx, bx												; Clear BX
  1570 00000B18 8A1E[780B]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1571 00000B1C C706[AA0B]7F00      <1> 	mov		WORD [FAT_ERTable+0x02], $7F							; Write sectors/cluster 
  1572 00000B22 66A3[B00B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1573 00000B26 893E[AC0B]          <1> 	mov		WORD [FAT_ERTable+0x04], di							; Offset in segment
  1574 00000B2A 8C06[AE0B]          <1> 	mov		WORD [FAT_ERTable+0x06], es							; Segment
  1575                              <1> 
  1576 00000B2E 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1577 00000B2F BE[A80B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1578 00000B32 B442                <1> 	mov 	ah, $42												; Extended Read		
  1579 00000B34 8A16[A10B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1580 00000B38 CD13                <1> 	int 	$13													; Perform read
  1581 00000B3A 61                  <1> 	popa														; Pop registers
  1582 00000B3B 7209                <1> 	jc 		SHORT .error										; If error, return
  1583                              <1> 
  1584 00000B3D E80C00              <1> 	call	.incrementReadPtr									; Increment read pointer
  1585                              <1> 
  1586                              <1> .done:	
  1587 00000B40 66A1[680B]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1588 00000B44 F8                  <1> 	clc															; Clear carry
  1589 00000B45 C3                  <1> 	ret
  1590                              <1> 
  1591                              <1> .error:
  1592 00000B46 66A1[680B]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1593 00000B4A F9                  <1> 	stc															; Set carry
  1594 00000B4B C3                  <1> 	ret
  1595                              <1> 
  1596                              <1> .incrementReadPtr:
  1597 00000B4C 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1598 00000B4F A1[6C0B]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1599 00000B52 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1600 00000B55 8A1E[780B]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read bytes per sector
  1601                              <1> 
  1602 00000B59 66F7E3              <1> 	mul		ebx													; EAX = value to add to write ptr
  1603 00000B5C 01C7                <1> 	add		di, ax												; Add cluster length to di
  1604 00000B5E 7107                <1> 	jno		.noOverflow											; If overflow bit isn't set, branch
  1605                              <1> 
  1606 00000B60 8CC0                <1> 	mov		ax, es												; Read segment we're writing to
  1607 00000B62 050010              <1> 	add		ax, $1000											; Write in next segment
  1608 00000B65 8EC0                <1> 	mov		es, ax												; Write to segment register
  1609                              <1> 
  1610                              <1> .noOverflow:
  1611 00000B67 C3                  <1> 	ret
  1612                              <1> 
  1613                              <1> 	align	4
  1614                              <1> .origCluster:
  1615 00000B68 00000000            <1> 	dd		0
  1616                              <1> 
  1617                              <1> ;========================================================================================
  1618                              <1> ; Data section
  1619                              <1> ;========================================================================================
  1620                              <1> 	align	4
  1621                              <1> FAT_BPB_BytesPerSec: ; file offset 11
  1622 00000B6C 0000                <1> 	dw		0
  1623                              <1> FAT_BPB_FSInfo: ; file offset 48, FAT32 only
  1624 00000B6E 0000                <1> 	dw		0
  1625                              <1> FAT_BPB_ExtFlags: ; file offset 40, FAT32 only
  1626 00000B70 0000                <1> 	dw		0
  1627                              <1> FAT_BPB_FSVer: ; file offset 42, FAT32 only
  1628 00000B72 0000                <1> 	dw		0
  1629                              <1> 
  1630                              <1> 	align	4
  1631                              <1> FAT_BPB_RootClus: ; file offset 44, FAT32 only
  1632 00000B74 00000000            <1> 	dd		0
  1633                              <1> FAT_BPB_SectorsPerCluster: ; file offset 13
  1634 00000B78 00                  <1> 	db		0
  1635                              <1> 
  1636 00000B79 90                  <1> 	align	2
  1637                              <1> FAT_BPB_ReservedSectors: ; file offset 14
  1638 00000B7A 0000                <1> 	dw		0
  1639                              <1> FAT_BPB_NumFATs: ; file offset 16
  1640 00000B7C 00                  <1> 	db		0
  1641                              <1> 
  1642 00000B7D 90                  <1> 	align	2
  1643                              <1> FAT_BPB_RootEntCnt:	; file offset 17
  1644 00000B7E 0000                <1> 	dw		0
  1645                              <1> 
  1646                              <1> 	align	4
  1647                              <1> FAT_BPB_FATSz: ; file offset 22 if FAT16, 36 if FAT32 and word at 22 is 0
  1648 00000B80 00000000            <1> 	dd		0
  1649                              <1> 
  1650                              <1> ; Works with FAT32
  1651                              <1> ; For the total sector count, try to read BPB_FATSz16 first (19), then the 32-bit at off 32
  1652                              <1> FAT_BPB_TotSec: ; file offset 32 if 19 = 0
  1653 00000B84 00000000            <1> 	dd		0
  1654                              <1> 
  1655                              <1> ; Calculated when identifying FS
  1656                              <1> FAT_RootDirSectors:
  1657 00000B88 0000                <1> 	dw		0
  1658                              <1> 
  1659 00000B8A 90<rept>            <1> 	align	4
  1660                              <1> FAT_DataSectors:
  1661 00000B8C 00000000            <1> 	dd		0
  1662                              <1> FAT_FirstDataSector:
  1663 00000B90 00000000            <1> 	dd		0
  1664                              <1> FAT_FirstClusterLocation:
  1665 00000B94 00000000            <1> 	dd		0
  1666                              <1> FAT_TotalClusters:
  1667 00000B98 00000000            <1> 	dd		0
  1668                              <1> 
  1669                              <1> ; Offset into drive in sectors to the start of the FAT partition
  1670                              <1> FAT_PartitionOffset:
  1671 00000B9C 00000000            <1> 	dd		0
  1672                              <1> FAT_Type:
  1673 00000BA0 00                  <1> 	db		0
  1674                              <1> 
  1675                              <1> ; BIOS drive to read from
  1676                              <1> FAT_Drive:
  1677 00000BA1 00                  <1> 	db		0
  1678                              <1> 
  1679 00000BA2 90<rept>            <1> 	align	4
  1680                              <1> FAT_LastLoadedSector:
  1681 00000BA4 00000000            <1> 	dd		0
  1682                              <1> 
  1683                              <1> 	align	4
  1684                              <1> FAT_ERTable:
  1685 00000BA8 10                  <1> 	db	$10
  1686 00000BA9 00                  <1> 	db	0
  1687 00000BAA 0000                <1> 	dw	0														; Num blocks
  1688 00000BAC 0000                <1> 	dw	0														; Dest
  1689 00000BAE 0000                <1> 	dw	0														; Memory page
  1690 00000BB0 00000000            <1> 	dd	0														; Starting LBA
  1691 00000BB4 00000000            <1> 	dd	0	
  1692                              <1> 
  1693 00000BB8 90<rept>            <1> 	align	$10
  1694                              <1> FAT_ReadBuffer:
  1695                                  
  1696                                  	align 4
  1697                                  
  1698                                  SectorBuf:
  1699 00000BC0 00<rept>                	times	512 db 0

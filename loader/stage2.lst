     1                                  	BITS	16
     2                                  	org		$0500
     3                                  
     4                                  ; Kernel will be loaded to segment $0300, or $003000 physical
     5                                  kern_loc:				EQU $0300
     6                                  kern_loc_phys:			EQU kern_loc<<4
     7                                  kern_start:				EQU 6
     8                                  kern_len:				EQU 32									; Length in sectors
     9                                  
    10                                  ; Location to store various BIOS info at
    11                                  Kern_Info_Struct:		EQU $0160								; $001600 phys (len = $400 max)
    12                                  VESA_SupportedModes:	EQU	$01A0								; $001A00 phys (len = $200)
    13                                  BIOS_MemMapSeg:			EQU	$0200								; $002000 phys (len = $800 max)
    14                                  
    15                                  struc KernInfoStruct
    16                                  	.munchieValue	resd	0									; X Munchie value
    17                                  	.supportBits	resw	0									; Support Bitfield
    18                                  	.high16Mem		resw	0									; X 64K blocks above 16M
    19                                  	.low16Mem		resw	0									; X 1K blocks below 16M
    20                                  	.memMap			resd	0									; X Physical pointer to memory map
    21                                  	.numMemMapEnt	resw	0									; X Number of entries in memory map
    22                                  	.vesaSupport	resb	0									; VESA support byte
    23                                  	.bootDrive		resb	0									; X Boot drive
    24                                  	.vesaMap		resd	0									; Physical pointer to VESA mode map
    25                                  endstruc
    26                                  
    27                                  %define KINFO(x)  (Kern_Info_Struct<<4) + KernInfoStruct. %+ x
    28                                  
    29                                  stage2_start:
    30 00000000 B80080                  	mov		ax, $8000											; AX = stack segment value (Stack to go at $80000)
    31 00000003 8ED0                    	mov 	ss, ax
    32 00000005 BC0010                  	mov 	sp, 4096											; Set up SP
    33                                  
    34 00000008 8CC8                    	mov 	ax, cs												; Set data segment to where we're loaded
    35 0000000A 8ED8                    	mov 	ds, ax
    36                                  
    37 0000000C 8816[0D07]              	mov		BYTE [BootDevice], dl								; Save boot device number
    38 00000010 8816[210B]              	mov		BYTE [FAT_Drive], dl								; Set FAT read drive
    39                                  
    40                                  	; Set up GS to point to a place in memory that houses the kernel info structure
    41 00000014 B86001                  	mov		ax, Kern_Info_Struct								; Place that houses the struct
    42 00000017 8EE8                    	mov		gs, ax												; Set up register
    43                                  
    44 00000019 31FF                    	xor		di, di												; Clear DI
    45 0000001B 66C70600164B45524E      	mov		[KINFO(munchieValue)], DWORD "KERN"					; Set magic value for kern struct
    46                                  
    47 00000024 A0[0D07]                	mov		al, [BootDevice]									; Set boot drive
    48 00000027 A20016                  	mov		[KINFO(bootDrive)], al								; ""
    49                                  
    50                                  	; Set up video
    51 0000002A B400                    	mov		ah, $00												; Change video mode
    52 0000002C B003                    	mov		al, $03												; 80x25 text mode
    53 0000002E CD10                    	int		$10													; Call video BIOS
    54                                  
    55 00000030 BE[1405]                	mov 	si, str_stage2loaded								; Put string position into SI
    56 00000033 31D2                    	xor		dx, dx												; Cursor position
    57 00000035 BF2F00                  	mov		di, $2F												; Set colour
    58 00000038 E83303                  	call 	print_string										; Call string printing routine
    59                                  
    60                                  	; Call VESA BIOS routines to get supported video modes
    61 0000003B B8A001                  	mov		ax, VESA_SupportedModes								; Memory location of supported mode struct
    62 0000003E 8EC0                    	mov		es, ax												; ""
    63 00000040 31FF                    	xor		di, di												; Offset 0 in segment
    64                                  
    65 00000042 2666C70556424532        	mov		[es:di], DWORD "VBE2"								; Tell BIOS we want 512 bytes of data
    66                                  
    67 0000004A B8004F                  	mov		ax, $4F00											; VESA BIOS routines â€” get supported modes
    68 0000004D CD10                    	int		$10													; Perform lookup
    69                                  
    70 0000004F 84E4                    	test	ah, ah												; Is AH not zero (i.e. error)
    71 00000051 7400                    	je		.vesaDone											; If so, VESA is unsupported
    72                                  
    73                                  .vesaDone:
    74                                  	; Call BIOS to get memory information
    75 00000053 31C9                    	xor 	cx, cx
    76 00000055 31D2                    	xor 	dx, dx
    77 00000057 B801E8                  	mov 	ax, $0E801
    78 0000005A CD15                    	int 	$15													; Request upper memory size
    79 0000005C 7257                    	jc 		error_memoryDetect
    80 0000005E 80FC86                  	cmp 	ah, $86												; Unsupported function
    81 00000061 7452                    	je		error_memoryDetect
    82 00000063 80FC80                  	cmp		ah, $80												; Invalid command
    83 00000066 744D                    	je		error_memoryDetect
    84 00000068 E304                    	jcxz 	.useax												; Was the CX result invalid?
    85                                   
    86 0000006A 89C8                    	mov		ax, cx												; Number of continuous 1K blocks (1M-16M)
    87 0000006C 89D3                    	mov		bx, dx												; Number of continuous 64K block above 16M
    88                                  
    89                                  .useax:
    90 0000006E 31FF                    	xor		di, di												; Clear DI
    91 00000070 891E[1007]              	mov		WORD [MemBlocksAbove16M], bx						; Store amount of memory available
    92                                  
    93 00000074 B86001                  	mov		ax, Kern_Info_Struct								; Place that houses the struct
    94 00000077 8EE8                    	mov		gs, ax												; Set up register
    95                                  
    96 00000079 891E0016                	mov		[KINFO(high16Mem)], bx								; ""
    97 0000007D A3[1207]                	mov		WORD [MemBlocksBelow16M], ax						; ""
    98 00000080 A30016                  	mov		[KINFO(low16Mem)], ax								; ""
    99                                  
   100 00000083 E8C302                  	call	display_memsize										; Display the memory size
   101                                  
   102                                  	; Fetch memory map
   103 00000086 B80002                  	mov 	ax, BIOS_MemMapSeg									; Write mem map to $01800 in physical space
   104 00000089 8EC0                    	mov 	es, ax
   105 0000008B 31FF                    	xor		di, di												; Start of segment
   106                                  
   107 0000008D E88703                  	call	fetch_mem_map										; Fetch a memory map
   108 00000090 7223                    	jc 		SHORT error_memoryDetect							; Branch if error
   109                                  
   110 00000092 B86001                  	mov		ax, Kern_Info_Struct								; Place that houses the struct
   111 00000095 8EE8                    	mov		gs, ax												; Set up register
   112                                  
   113 00000097 892E0016                	mov		WORD [KINFO(numMemMapEnt)], bp						; ""
   114 0000009B C70600160020            	mov		WORD [KINFO(memMap)], (BIOS_MemMapSeg<<4)			; Physical location of table
   115                                  
   116                                  	; Initialise FAT library
   117 000000A1 E80C07                  	call	FAT_Init
   118                                  
   119                                  	; Check which partitions are bootable from MBR partition map
   120 000000A4 E8F101                  	call	find_bootable_partitions
   121 000000A7 C606[1E07]00            	mov		BYTE [HDD_Selected], 0								; Clear HDD selection
   122                                  
   123                                  	; Set up the partition chooser UI
   124 000000AC E86F00                  	call	render_partition_chooser
   125                                  
   126                                  	; Process keypresses, and loads kernel from FS if ENTER is pressed
   127 000000AF E86201                  	call	chooser_loop
   128 000000B2 E90800                  	jmp		boot
   129                                  
   130                                  ;========================================================================================
   131                                  ; Memory detection error handler
   132                                  ;========================================================================================
   133                                  error_memoryDetect:
   134 000000B5 BE[2F05]                	mov 	si, str_errorDetectMem								; Put string position into SI
   135 000000B8 E8AD02                  	call 	print_error											; Call string printing routine
   136 000000BB EBFE                    	jmp		$
   137                                  
   138                                  ;========================================================================================
   139                                  ; Code to boot the kernel
   140                                  ;========================================================================================
   141                                  boot:
   142                                  	; Hide cursor
   143 000000BD 31D2                    	xor		dx, dx												; Clear dx
   144 000000BF F7D2                    	not		dx													; dx = $FFFF
   145 000000C1 B402                    	mov 	ah, $02												; Set cursor position
   146 000000C3 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   147 000000C5 CD10                    	int		$10													; Set cursor
   148                                  
   149                                  	; Set up GDT
   150 000000C7 FA                      	cli															; Disable ints
   151 000000C8 0F0116[A807]            	lgdt	[gdt_table]											; Set up GDTR
   152                                  
   153 000000CD 8B360000                	mov		si, [KernInfoStruct]								; Load address to kernel info struct in SI
   154                                  
   155                                  	; Jump into protected mode, woot!
   156 000000D1 0F20C0                  	mov		eax, cr0											; Get control reg
   157 000000D4 0C01                    	or		al, 00000001b										; Set PE bit
   158 000000D6 0F22C0                  	mov		cr0, eax											; Write control reg
   159                                  
   160                                  	; Set up selectors
   161 000000D9 B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   162 000000DC 8ED8                    	mov		ds, ax												; Set data selector
   163                                  
   164 000000DE B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   165 000000E1 8EC0                    	mov		es, ax												; Update other selectors to point to data segment
   166 000000E3 8EE0                    	mov		fs, ax
   167 000000E5 8EE8                    	mov		gs, ax
   168 000000E7 8ED0                    	mov		ss, ax
   169                                  
   170                                  	; The kernel is loaded to $00003000 phys (segmented address 0300h:0000h)
   171 000000E9 66                      	db		$66													; 32-bit prefix
   172 000000EA EA                      	db		$0EA												; Far jump opcode
   173 000000EB [F1000000]              	dd		copy_kernel											; Jump to kernel copying routine
   174 000000EF 0800                    	dw		$08													; Selector for CODE32_DESCRIPTOR
   175                                  
   176                                  	BITS	32
   177                                  copy_kernel:
   178 000000F1 BC00004000              	mov		esp, $400000										; Stackzors at $400000
   179                                  
   180 000000F6 B800300000              	mov		eax, kern_loc_phys									; Physical kernel location
   181 000000FB BB00001000              	mov		ebx, $00100000										; Destination memory address
   182 00000100 B900400000              	mov		ecx, $4000											; Number of long-words to copy (64KB)
   183                                  
   184 00000105 90<rept>                	align	4													; DWORD align
   185                                  .copy:
   186 00000108 8B10                    	mov		edx, DWORD [eax]									; Read a DWORD from lowmem
   187 0000010A 8913                    	mov		DWORD [ebx], edx									; Write DWORD to himem
   188                                  
   189 0000010C 0504000000              	add		eax, $04											; Increment read ptr
   190 00000111 81C304000000            	add		ebx, $04											; Increment write ptr
   191                                  
   192 00000117 E2EF                    	loop	.copy												; Loop and copy everything
   193 00000119 E9(00001000)            	jmp		$100000												; Jump into relocated kernel
   194                                  
   195                                  	BITS	16
   196                                  
   197                                  ;========================================================================================
   198                                  ; Renders the partition chooser
   199                                  ;========================================================================================
   200                                  render_partition_chooser:
   201 0000011E BE[DD05]                	mov 	si, str_select_partition							; Put string position into SI
   202 00000121 BA0105                  	mov		dx, $0501											; Cursor position
   203 00000124 BF0700                  	mov		di, $07												; Set colour
   204 00000127 E84402                  	call 	print_string										; Call string printing routine
   205                                  
   206 0000012A C706[0E07]0407          	mov		WORD [LastCursorPosition], 0x0704					; Read last cursor position
   207                                  
   208 00000130 66BA[16070000]          	mov		edx, HDD_BootablePartitions							; EDX contains bootable partition ptr
   209 00000136 B90400                  	mov		cx, $04												; Loop 4x
   210                                  
   211                                  .disp_loop:
   212 00000139 678A02                  	mov		al, BYTE [edx]										; Read bootability
   213 0000013C 2480                    	and		al, $80												; Get high bit only
   214 0000013E 3C80                    	cmp		al, $80												; Is it $80?
   215 00000140 7505                    	jne		.not_bootable										; If not, it's not a bootable drive
   216                                  
   217 00000142 E81300                  	call	.render_boot										; Render bootable drive label
   218                                  
   219 00000145 EB03                    	jmp		SHORT .next											; Skip over non-bootable code
   220                                  
   221                                  .not_bootable:
   222 00000147 E87600                  	call	.render_noboot										; Render non-bootable drive label
   223                                  
   224                                  .next:
   225 0000014A 6642                    	inc		edx													; Go to next item
   226 0000014C E2EB                    	loop	.disp_loop											; Loop over all 4 partitions
   227                                  
   228 0000014E BA010C                  	mov		dx, $0C01
   229 00000151 BE[7006]                	mov		si, str_err_clear_err								; Clear error
   230 00000154 E81702                  	call	print_string										; Display
   231                                  
   232 00000157 C3                      	ret
   233                                  
   234                                  ;========================================================================================
   235                                  ; Renders an entry for a bootable drive
   236                                  ;========================================================================================
   237                                  .render_boot:
   238 00000158 B004                    	mov		al, $04												; Max drive num to al
   239 0000015A 28C8                    	sub		al, cl												; Subtract loop counter
   240 0000015C A2[BF01]                	mov		BYTE [.index], al									; Write index
   241 0000015F 0430                    	add		al, $30												; ASCII numbers
   242                                  
   243 00000161 66C706[4F07]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   244 00000169 2C                 
   245 0000016A A2[5307]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   246 0000016D C706[5407]3A20          	mov		WORD [Temp_StrBuf+5], ": "							; Colon, space
   247                                  
   248 00000173 60                      	pusha														; Push registers
   249 00000174 66BA[56070000]          	mov		edx, Temp_StrBuf+7									; String buffer write place
   250 0000017A 66BB[1F070000]          	mov		ebx, HDD_PartitionNames								; Partition names
   251 00000180 B90C00                  	mov		cx, $0C												; $0C characters
   252                                  
   253                                  .copyNameLoop:
   254 00000183 678A03                  	mov		al, BYTE [ebx]										; Copy a character
   255 00000186 678802                  	mov		BYTE [edx], al										; Write to temp buffer
   256 00000189 6643                    	inc		ebx													; Increment read pointer
   257 0000018B 6642                    	inc		edx													; Increment write pointer
   258 0000018D E2F4                    	loop	.copyNameLoop
   259                                  
   260 0000018F 67C742FF0A00            	mov		WORD [edx-1], 0x000A								; Insert newline
   261                                  
   262 00000195 6631C0                  	xor		eax, eax											; Clear EAX
   263 00000198 66BA[1A070000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type matrix
   264 0000019E 0216[BF01]              	add		dl, BYTE [.index]
   265 000001A2 678A02                  	mov		al, BYTE [edx]										; Read FAT type to AL
   266                                  
   267 000001A5 8A1E[1E07]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   268 000001A9 80E303                  	and		bl, $3												; Get low 2 bits only
   269 000001AC 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   270 000001AE 7503                    	jne		.no_highlight										; If not, branch.
   271                                  
   272 000001B0 BF7000                  	mov		di, $070											; Black text on white background
   273                                  
   274                                  .no_highlight:
   275 000001B3 8B16[0E07]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   276 000001B7 BE[4F07]                	mov		si, Temp_StrBuf										; Temporary string buffer
   277 000001BA E8B101                  	call 	print_string										; Call string printing routine
   278 000001BD 61                      	popa														; Pop registers
   279                                  
   280 000001BE C3                      	ret
   281                                  
   282                                  .index:
   283 000001BF 00                      	db	0
   284                                  
   285                                  ;========================================================================================
   286                                  ; Renders an entry for a non-bootable drive.
   287                                  ;========================================================================================
   288                                  	align 4
   289                                  
   290                                  .render_noboot:
   291 000001C0 B004                    	mov		al, $04												; Max drive num to al
   292 000001C2 28C8                    	sub		al, cl												; Subtract loop counter
   293 000001C4 0430                    	add		al, $30												; ASCII numbers
   294                                  
   295 000001C6 66C706[4F07]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   296 000001CE 2C                 
   297 000001CF A2[5307]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   298 000001D2 66C706[5407]3A204E-     	mov		DWORD [Temp_StrBuf+5], ": No"						; "Not Bootable"
   299 000001DA 6F                 
   300 000001DB 66C706[5807]742042-     	mov		DWORD [Temp_StrBuf+9], "t Bo"
   301 000001E3 6F                 
   302 000001E4 66C706[5C07]6F7461-     	mov		DWORD [Temp_StrBuf+13], "otab"
   303 000001EC 62                 
   304 000001ED C706[6007]6C65          	mov		WORD [Temp_StrBuf+17], "le"
   305 000001F3 C706[6207]0A00          	mov		WORD [Temp_StrBuf+19], 0x000A						; Newline, terminator
   306                                  
   307 000001F9 60                      	pusha														; Push registers
   308                                  
   309 000001FA 8A1E[1E07]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   310 000001FE 80E303                  	and		bl, $3												; Get low 2 bits only
   311 00000201 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   312 00000203 7503                    	jne		.no_highlight2										; If not, branch.
   313                                  
   314 00000205 BF7000                  	mov		di, $070											; Black text on white background
   315                                  
   316                                  .no_highlight2:
   317 00000208 8B16[0E07]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   318 0000020C BE[4F07]                	mov		si, Temp_StrBuf										; Temporary string buffer
   319 0000020F E85C01                  	call 	print_string										; Call string printing routine
   320 00000212 61                      	popa														; Pop registers
   321                                  
   322 00000213 C3                      	ret
   323                                  
   324                                  ;========================================================================================
   325                                  ; Handle keypresses for chooser
   326                                  ;========================================================================================
   327                                  chooser_loop:
   328 00000214 E91500                  	jmp		partition_chooser_enter
   329                                  
   330 00000217 30E4                    	xor		ah, ah												; Wait for keystroke
   331 00000219 CD16                    	int		$16													; Call into BIOS
   332                                  
   333 0000021B 80FC50                  	cmp		ah, $50												; Down pressed?
   334 0000021E 7459                    	je		partition_chooser_dn
   335                                  
   336 00000220 80FC48                  	cmp		ah, $48												; Up pressed?
   337 00000223 7463                    	je		partition_chooser_up
   338                                  
   339 00000225 80FC1C                  	cmp		ah, $1C												; Enter pressed?
   340 00000228 7402                    	je		partition_chooser_enter
   341                                  
   342 0000022A EBE8                    	jmp		chooser_loop
   343                                  
   344                                  partition_chooser_enter:
   345 0000022C 31DB                    	xor		bx, bx												; Clear BX
   346 0000022E 8A1E[1E07]              	mov		bl, BYTE [HDD_Selected]								; Get selection
   347                                  
   348 00000232 8A87[1607]              	mov		al, BYTE [HDD_BootablePartitions+bx]				; Check bootability status
   349 00000236 2480                    	and		al, $80												; Get high bit only
   350 00000238 3C80                    	cmp		al, $80
   351 0000023A 7527                    	jne		.noBootErr											; If not bootable, branch
   352                                  
   353 0000023C BE[8407]                	mov		si, kernel_filename									; Filename to find
   354 0000023F E8B907                  	call	FAT_FindFileAtRoot									; Find file
   355 00000242 722A                    	jc		.fileNotFound										; Carry set = KERNEL.BIN not found
   356                                  
   357 00000244 66A3[8007]              	mov		DWORD [kernel_cluster], eax							; Store cluster
   358                                  
   359 00000248 31C0                    	xor		ax, ax												; Segment 0
   360 0000024A 8EC0                    	mov		es, ax												; Write segment											
   361 0000024C BF0030                  	mov		di, kern_loc_phys									; Offset into segment
   362                                  
   363 0000024F 66A1[8007]              	mov		eax, DWORD [kernel_cluster]							; Kernel's cluster location
   364 00000253 E81A08                  	call	FAT_ReadFile										; Read file
   365                                  
   366 00000256 BE[C206]                	mov 	si, str_kernel_loaded_ok							; Put string position into SI
   367 00000259 BA010C                  	mov		dx, $0C01											; Cursor position
   368 0000025C BF0200                  	mov		di, $02												; Set colour
   369 0000025F E80C01                  	call 	print_string										; Call string printing routine
   370                                  
   371 00000262 C3                      	ret
   372                                  
   373                                  .noBootErr:
   374 00000263 BA010C                  	mov		dx, $0C01
   375 00000266 BE[1206]                	mov		si, str_err_not_bootable							; Not bootable error
   376 00000269 E8FC00                  	call	print_error											; Display
   377 0000026C EBA6                    	jmp		chooser_loop
   378                                  
   379                                  .fileNotFound:
   380 0000026E BA010C                  	mov		dx, $0C01
   381 00000271 BE[3C06]                	mov		si, str_err_kern_not_found							; Not found error
   382 00000274 E8F100                  	call	print_error											; Display
   383 00000277 EB9B                    	jmp		chooser_loop
   384                                  
   385                                  partition_chooser_dn:
   386 00000279 A0[1E07]                	mov		al, BYTE [HDD_Selected]								; Read selection
   387 0000027C FEC8                    	dec		al													; Move cursor up
   388 0000027E 2403                    	and		al, $03												; Get low 2 bits only
   389 00000280 A2[1E07]                	mov		BYTE [HDD_Selected], al								; Restore
   390                                  
   391 00000283 E898FE                  	call	render_partition_chooser							; Update display
   392 00000286 EB8C                    	jmp		chooser_loop
   393                                  
   394                                  partition_chooser_up:
   395 00000288 A0[1E07]                	mov		al, BYTE [HDD_Selected]								; Read selection
   396 0000028B FEC0                    	inc		al													; Move cursor down
   397 0000028D 2403                    	and		al, $03												; Get low 2 bits only
   398 0000028F A2[1E07]                	mov		BYTE [HDD_Selected], al								; Restore
   399                                  
   400 00000292 E889FE                  	call	render_partition_chooser							; Update display
   401 00000295 E97CFF                  	jmp		chooser_loop
   402                                  
   403                                  ;========================================================================================
   404                                  ; Finds all partitions that are bootable.
   405                                  ;========================================================================================
   406                                  find_bootable_partitions:
   407 00000298 B90400                  	mov		cx, $4												; MBR contains 4 partition maps
   408                                  
   409 0000029B B8C007                  	mov		ax, $07C0											; Bootloader at 0x7C00
   410 0000029E 8EC0                    	mov		es, ax												; Set ES to the bootloader's place in memory
   411 000002A0 BFBE01                  	mov		di, $1BE											; Start of partition map
   412                                  
   413 000002A3 8CD8                    	mov		ax, ds												; Fetch data segment
   414 000002A5 8EE8                    	mov		gs, ax												; Set GS to data segment
   415                                  
   416 000002A7 66BE[16070000]          	mov		esi, HDD_BootablePartitions							; ESI contains bootable partition ptr
   417 000002AD 66BA[1F070000]          	mov		edx, HDD_PartitionNames								; Partition name ptr
   418                                  
   419                                  .loop:
   420 000002B3 268A05                  	mov		al, BYTE [es:di]									; Read bootable flag
   421 000002B6 2480                    	and		al, $80												; Get high bit only
   422 000002B8 3C80                    	cmp		al, $80												; Is it $80?
   423 000002BA 754B                    	jne		.not_bootable										; If not, it's not a bootable drive
   424                                  
   425 000002BC 678806                  	mov		BYTE [esi], al										; Write bootability flag
   426                                  
   427 000002BF 880E[1E07]              	mov		BYTE [HDD_Selected], cl								; Write index
   428                                  
   429                                  	; Try to read the LBA of the partition
   430 000002C3 26668B4508              	mov		eax, DWORD [es:di+8]								; Read partition LBA
   431 000002C8 663D00000000            	cmp		eax, $00											; Is it zero?
   432 000002CE 7437                    	je		.no_valid_lba										; If so, fuck off
   433                                  
   434 000002D0 66A3[7807]              	mov		DWORD [ExtendedRead_Table+0x08], eax				; Write LBA
   435 000002D4 C706[7207]0100          	mov		WORD [ExtendedRead_Table+0x02], 0x01				; Read one sector
   436 000002DA C706[7407][400B]        	mov		WORD [ExtendedRead_Table+0x04], SectorBuf			; Temporary sector buffer offset (seg 0)
   437                                  
   438 000002E0 66A3[1C0B]              	mov		DWORD [FAT_PartitionOffset], eax					; Write offset into FAT
   439                                  
   440 000002E4 60                      	pusha														; Push registers (BIOS may clobber them)
   441 000002E5 BE[7007]                	mov 	si, ExtendedRead_Table								; address of "disk address packet"
   442 000002E8 B442                    	mov 	ah, $42												; Extended Read
   443 000002EA 8A16[0D07]              	mov		dl, BYTE [BootDevice]								; Device number
   444 000002EE CD13                    	int 	$13
   445 000002F0 61                      	popa														; Pop registers
   446 000002F1 7214                    	jc 		SHORT .no_valid_lba									; If error, fuck off
   447                                  
   448 000002F3 E82100                  	call	.typeDetermine										; Determine type and label loc
   449                                  
   450 000002F6 51                      	push	cx													; Back up original loop counter
   451                                  
   452 000002F7 B90B00                  	mov		cx, $0B												; Copy 0xB bytes
   453                                  .copy_str_loop:
   454 000002FA 678A18                  	mov		bl, BYTE [eax]										; Copy from source
   455 000002FD 67881A                  	mov		BYTE [edx], bl										; Write to target buffer
   456 00000300 6640                    	inc		eax													; Increment read pointer
   457 00000302 6642                    	inc		edx													; Increment write pointer
   458 00000304 E2F4                    	loop	.copy_str_loop										; Copy all bytes.
   459                                  
   460 00000306 59                      	pop		cx													; Restore original loop counter.
   461                                  
   462                                  .no_valid_lba:
   463                                  
   464                                  .not_bootable:
   465 00000307 81C71000                	add		di, $10												; Go to next entry in bootsector
   466 0000030B 6646                    	inc		esi													; Write next bootability flag
   467 0000030D 6681C20C000000          	add		edx, $0C											; Each entry of partition names is 0x0C in length
   468 00000314 E29D                    	loop	.loop												; Loop through all partitions
   469                                  
   470                                  .done:
   471 00000316 C3                      	ret
   472                                  
   473                                  ; Determines FAT type and stores pointer to read volume label in eax
   474                                  .typeDetermine:
   475 00000317 6656                    	push	esi													; Push old ESI
   476 00000319 BE[400B]                	mov		si, SectorBuf										; Sector buffer
   477 0000031C E8AB04                  	call	FAT_DetermineType									; Determine type of FS
   478 0000031F 665E                    	pop		esi													; Pop ESI
   479                                  
   480 00000321 6652                    	push	edx													; Back up EDX
   481 00000323 B304                    	mov		bl, $04												; Max drive num to al
   482 00000325 28CB                    	sub		bl, cl												; Subtract loop counter
   483                                  
   484 00000327 66BA[1A070000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type ptr
   485 0000032D 28DA                    	sub		dl, bl												; Subtract index
   486 0000032F 678802                  	mov		BYTE [edx], al										; Write FAT size
   487 00000332 665A                    	pop		edx													; Restore EDX
   488                                  
   489 00000334 3C20                    	cmp		al, $20												; Is it a FAT32 volume?
   490 00000336 7509                    	jne		.fat16_label										; If so, branch
   491                                  
   492 00000338 66B8[870B0000]          	mov		eax, SectorBuf+$47									; FAT32 has volume label at 0x47
   493                                  
   494 0000033E E90600                  	jmp		.copy												; Copy label
   495                                  
   496                                  	; Extract volume label from sector buffer
   497                                  .fat16_label:
   498 00000341 66B8[6B0B0000]          	mov		eax, SectorBuf+$2B									; FAT16 has volume label at 0x2B
   499                                  
   500                                  .copy:
   501 00000347 C3                      	ret
   502                                  
   503                                  .index:
   504 00000348 00                      	db		0
   505                                  
   506                                  ;========================================================================================
   507                                  ; Displays the memory size on the screen 
   508                                  ;========================================================================================
   509                                  display_memsize:
   510 00000349 BE[8705]                	mov 	si, str_available_lomem								; Put string position into SI
   511 0000034C BA0002                  	mov		dx, $0200
   512 0000034F E81C00                  	call 	print_string										; Call string printing routine
   513 00000352 A1[1207]                	mov		ax, WORD [MemBlocksBelow16M]						; Get total of memory blocks to EDX
   514 00000355 E88100                  	call	hex_to_ascii
   515                                  
   516 00000358 BE[B205]                	mov 	si, str_available_himem								; Put string position into SI
   517 0000035B BA0003                  	mov		dx, $0300
   518 0000035E E80D00                  	call 	print_string										; Call string printing routine
   519 00000361 A1[1007]                	mov		ax, WORD [MemBlocksAbove16M]						; Get total of memory blocks to EDX
   520 00000364 E87200                  	call	hex_to_ascii
   521                                  
   522 00000367 C3                      	ret
   523                                  
   524                                  ;========================================================================================
   525                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h with the styling
   526                                  ; required for an error string.
   527                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   528                                  ;========================================================================================
   529                                  print_error:
   530 00000368 BF4F00                  	mov		di, $04F											; White text on red background
   531 0000036B E90000                  	jmp 	print_string										; Call string printing routine
   532                                  
   533                                  ;========================================================================================
   534                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h.
   535                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   536                                  ;========================================================================================
   537                                  print_string:
   538 0000036E 52                      	push	dx													; Push column
   539                                  
   540 0000036F 85FF                    	test	di, di												; Check if DI is set
   541 00000371 7406                    	jz		.useDefaultColour									; If so, branch
   542                                  
   543 00000373 89F8                    	mov		ax, di												; Set colour
   544 00000375 88C3                    	mov		bl, al												; Get low byte only
   545 00000377 EB02                    	jmp		SHORT .setCursor
   546                                  
   547                                  .useDefaultColour:
   548 00000379 B307                    	mov		bl, $007											; Light gray text on black background
   549                                  
   550                                  .setCursor:
   551 0000037B B402                    	mov 	ah, $02												; Set cursor position
   552 0000037D 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   553 0000037F CD10                    	int		$10													; Set cursor
   554                                  
   555                                  .repeat:
   556 00000381 AC                      	lodsb														; Get character from string
   557 00000382 3C00                    	cmp 	al, 0
   558 00000384 7417                    	je		.done												; If char is zero, end of string
   559                                  	
   560 00000386 3C0A                    	cmp 	al, $0A												; Process newline
   561 00000388 741B                    	je		.newline
   562                                  
   563 0000038A B90100                  	mov		cx, $01												; Write one ASCII character
   564 0000038D 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   565 0000038F B409                    	mov 	ah, $09												; Write character
   566 00000391 CD10                    	int		$10													; Print character
   567                                  
   568 00000393 B402                    	mov 	ah, $02												; Set cursor position
   569 00000395 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   570 00000397 FEC2                    	inc		dl													; Increment column
   571 00000399 CD10                    	int		$10													; Set cursor
   572                                  
   573 0000039B EBE4                    	jmp		.repeat
   574                                  
   575                                  .done:
   576 0000039D 8916[0E07]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   577 000003A1 5A                      	pop		dx													; Pop position
   578 000003A2 31FF                    	xor		di, di												; Clear colour
   579 000003A4 C3                      	ret
   580                                  
   581                                  .newline:
   582 000003A5 5A                      	pop		dx													; Get original column
   583 000003A6 FEC6                    	inc		dh													; Increment row
   584 000003A8 52                      	push	dx													; Push it back to stack
   585 000003A9 EBD6                    	jmp		.repeat
   586                                  
   587                                  ;========================================================================================
   588                                  ; Prints the character in al to the screen at the current cursor position, using the
   589                                  ; colour in di.
   590                                  ;========================================================================================
   591                                  putc:
   592 000003AB 85FF                    	test	di, di												; Check if DI is set
   593 000003AD 7406                    	jz		.useDefaultColour									; If so, branch
   594                                  
   595 000003AF 89F8                    	mov		ax, di												; Set colour
   596 000003B1 88C3                    	mov		bl, al												; Get low byte only
   597 000003B3 EB02                    	jmp		SHORT .setCursor
   598                                  
   599                                  .useDefaultColour:
   600 000003B5 B307                    	mov		bl, $007											; Light gray text on black background
   601                                  
   602                                  .setCursor:
   603 000003B7 8B16[0E07]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   604 000003BB B402                    	mov 	ah, $02												; Set cursor position
   605 000003BD B700                    	mov		bh, $0												; Video page 0
   606 000003BF CD10                    	int		$10													; Set cursor
   607                                  
   608 000003C1 B90100                  	mov		cx, $01												; Write one ASCII character
   609 000003C4 B700                    	mov		bh, $0												; Video page 0
   610 000003C6 B409                    	mov 	ah, $09												; Write character
   611 000003C8 CD10                    	int		$10													; Print character
   612                                  
   613 000003CA FEC2                    	inc		dl													; Increment column
   614                                  
   615 000003CC B402                    	mov 	ah, $02												; Set cursor position
   616 000003CE B700                    	mov		bh, $0												; Video page 0
   617 000003D0 CD10                    	int		$10													; Set cursor
   618                                  
   619 000003D2 8916[0E07]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   620 000003D6 31FF                    	xor		di, di												; Clear colour
   621 000003D8 C3                      	ret
   622                                  
   623                                  ;========================================================================================
   624                                  ; Prints the value in eax to the screen.
   625                                  ;========================================================================================
   626                                  hex_to_ascii:
   627 000003D9 31C9                    	xor 	cx, cx
   628                                  
   629 000003DB 88E1                    	mov 	cl, ah												; Move high byte of ax to cl
   630 000003DD E81000                  	call 	.nibble_high										; Print low nibble to ASCII
   631 000003E0 88E1                    	mov 	cl, ah
   632 000003E2 E81100                  	call 	.nibble_low
   633 000003E5 88C1                    	mov 	cl, al
   634 000003E7 E80600                  	call 	.nibble_high
   635 000003EA 88C1                    	mov 	cl, al
   636 000003EC E80700                  	call 	.nibble_low
   637 000003EF C3                      	ret
   638                                  
   639                                  .nibble_high:
   640 000003F0 C0E904                  	shr 	cl, $04
   641 000003F3 E90600                  	jmp 	.convert_check
   642                                  
   643                                  .nibble_low:
   644 000003F6 80E10F                  	and 	cl, $0F
   645 000003F9 E90000                  	jmp 	.convert_check
   646                                  
   647                                  .convert_check:
   648 000003FC 80F90A                  	cmp 	cl, $0A
   649 000003FF 7D0B                    	jge 	.letter
   650 00000401 80C130                  	add 	cl, $30
   651 00000404 50                      	push 	ax
   652 00000405 88C8                    	mov 	al, cl
   653 00000407 E8A1FF                  	call 	putc
   654 0000040A 58                      	pop 	ax
   655 0000040B C3                      	ret
   656                                  
   657                                  .letter:
   658 0000040C 80C137                  	add 	cl, $37
   659 0000040F 50                      	push	ax
   660 00000410 88C8                    	mov 	al, cl
   661 00000412 E896FF                  	call	putc
   662 00000415 58                      	pop 	ax
   663 00000416 C3                      	ret
   664                                  
   665                                  ;========================================================================================
   666                                  ; Uses BIOS INT $15, EAX $E820 function to get the memory map of the system
   667                                  ; input: 	es:di = destination buffer for 24 byte entries
   668                                  ; output: 	bp = entry count, trashes all registers except esi
   669                                  ;========================================================================================
   670                                  fetch_mem_map:
   671 00000417 6631DB                  	xor		ebx, ebx											; Clear EBX
   672 0000041A 31ED                    	xor		bp, bp												; Use BP as an entry count
   673 0000041C 66BA50414D53            	mov		edx, $0534D4150										; Place "SMAP" into edx (magic value)
   674 00000422 66B820E80000            	mov		eax, $0E820											; Function call
   675                                  
   676 00000428 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   677 00000431 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   678 00000437 CD15                    	int		$15
   679                                  
   680 00000439 7257                    	jc		SHORT .error										; If carry set, the function is unsupported
   681                                  
   682 0000043B 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   683 00000441 6639D0                  	cmp		eax, edx											; On success, EAX = "SMAP"
   684 00000444 754C                    	jne		SHORT .error
   685                                  
   686 00000446 6685DB                  	test	ebx, ebx											; ebx = 0 implies list is only 1 entry long (worthless)
   687 00000449 7447                    	je		SHORT .error
   688                                  
   689 0000044B EB1F                    	jmp		SHORT .startLoop									; Jump into the loop
   690                                  
   691                                  .getEntryLoop:
   692 0000044D 66B820E80000            	mov		eax, $0E820											; Reset command (EAX, ECX are trashed)
   693 00000453 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   694 0000045C 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   695 00000462 CD15                    	int		$15
   696                                  
   697 00000464 722A                    	jc		SHORT .done											; If carry set, we are done
   698 00000466 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   699                                  
   700                                  .startLoop:
   701 0000046C E31D                    	jcxz	.skipEntry											; Skip any 0 length entries
   702                                  
   703 0000046E 80F914                  	cmp		cl, 20												; Did we get 24-byte ACPI 3.x data?
   704 00000471 7607                    	jbe		SHORT .notext
   705                                  
   706 00000473 26F6451401              	test	BYTE [es:di+20], 1									; If so, is the "ignore this data" bit clear?
   707 00000478 7411                    	je		SHORT .skipEntry
   708                                  
   709                                  .notext:
   710 0000047A 26668B4D08              	mov		ecx, [es:di+8]										; get lower dword of memory region length
   711 0000047F 26660B4D0C              	or		ecx, [es:di+12]										; Check if zero (OR with upper dword)
   712 00000484 7405                    	jz		.skipEntry											; If length qword is 0, skip entry
   713                                  
   714 00000486 45                      	inc		bp													; We got a good entry, increment count, go to next entry
   715                                  
   716 00000487 81C71800                	add		di, 24
   717                                  
   718                                  .skipEntry:
   719 0000048B 6685DB                  	test	ebx, ebx											; If EBX = 0, then the BIOS has given us all entries
   720 0000048E 75BD                    	jne		SHORT .getEntryLoop
   721                                  
   722                                  .done:
   723 00000490 F8                      	clc															; There is "jc" on end of list to this point, so the carry must be cleared
   724 00000491 C3                      	ret
   725                                  
   726                                  .error:
   727 00000492 F9                      	stc															; Set carry if this BIOS sucks ass and doesn't support this
   728 00000493 C3                      	ret
   729                                  
   730                                  ;========================================================================================
   731                                  ; Writes a register dump to the VGA hardware
   732                                  ;========================================================================================
   733                                  VGA_MISC_WRITE		EQU	$3C2
   734                                  VGA_SEQ_INDEX		EQU	$3C4
   735                                  VGA_SEQ_DATA		EQU	$3C5
   736                                  VGA_CRTC_INDEX		EQU	$3D4
   737                                  VGA_CRTC_DATA		EQU	$3D5
   738                                  VGA_INSTAT_READ		EQU	$3DA
   739                                  
   740                                  NUM_SEQ_REGS		EQU	5
   741                                  NUM_CRTC_REGS		EQU	25
   742                                  
   743                                  write_regs:
   744 00000494 56                      	push 	si
   745 00000495 52                      	push 	dx
   746 00000496 51                      	push 	cx
   747 00000497 50                      	push 	ax
   748 00000498 FC                      	cld
   749                                  
   750                                  ; write MISC register
   751 00000499 BAC203                  	mov 	dx, VGA_MISC_WRITE
   752 0000049C AC                      	lodsb
   753 0000049D EE                      	out 	dx, al
   754                                  
   755                                  ; write SEQuencer registers
   756 0000049E B90500                  	mov 	cx, NUM_SEQ_REGS
   757 000004A1 30E4                    	xor 	ah, ah
   758                                  
   759                                  write_seq:
   760 000004A3 BAC403                  	mov 	dx, VGA_SEQ_INDEX
   761 000004A6 88E0                    	mov 	al, ah
   762 000004A8 EE                      	out 	dx, al
   763                                  
   764 000004A9 BAC503                  	mov 	dx, VGA_SEQ_DATA
   765 000004AC AC                      	lodsb
   766 000004AD EE                      	out 	dx, al
   767                                  
   768 000004AE FEC4                    	inc 	ah
   769 000004B0 E2F1                    	loop 	write_seq
   770                                  
   771                                  ; write CRTC registers
   772                                  ; Unlock CRTC registers: enable writes to CRTC regs 0-7
   773 000004B2 BAD403                  	mov 	dx, VGA_CRTC_INDEX
   774 000004B5 B011                    	mov 	al, 17
   775 000004B7 EE                      	out 	dx, al
   776                                  
   777 000004B8 BAD503                  	mov 	dx, VGA_CRTC_DATA
   778 000004BB EC                      	in		al, dx
   779 000004BC 247F                    	and 	al, $7F
   780 000004BE EE                      	out 	dx, al
   781                                  
   782                                  ; Unlock CRTC registers: enable access to vertical retrace regs
   783 000004BF BAD403                  	mov 	dx, VGA_CRTC_INDEX
   784 000004C2 B003                    	mov 	al, 3
   785 000004C4 EE                      	out 	dx, al
   786                                  
   787 000004C5 BAD503                  	mov 	dx ,VGA_CRTC_DATA
   788 000004C8 EC                      	in		al, dx
   789 000004C9 0C80                    	or		al, $80
   790 000004CB EE                      	out		dx, al
   791                                  
   792                                  ; make sure CRTC registers remain unlocked
   793 000004CC 8A4411                  	mov		al,[si + 17]
   794 000004CF 247F                    	and 	al, $7F
   795 000004D1 884411                  	mov 	[si + 17],al
   796                                  
   797 000004D4 8A4403                  	mov 	al,[si + 3]
   798 000004D7 0C80                    	or		al, $80
   799 000004D9 884403                  	mov 	[si + 3], al
   800                                  
   801                                  ; now, finally, write them
   802 000004DC B91900                  	mov 	cx, NUM_CRTC_REGS
   803 000004DF B400                    	mov 	ah, 0
   804                                  
   805                                  write_crtc:
   806 000004E1 BAD403                  	mov 	dx, VGA_CRTC_INDEX
   807 000004E4 88E0                    	mov 	al, ah
   808 000004E6 EE                      	out 	dx, al
   809                                  
   810 000004E7 BAD503                  	mov 	dx, VGA_CRTC_DATA
   811 000004EA AC                      	lodsb
   812 000004EB EE                      	out 	dx, al
   813                                  
   814 000004EC FEC4                    	inc 	ah
   815 000004EE E2F1                    	loop write_crtc
   816                                  
   817 000004F0 58                      	pop 	ax
   818 000004F1 59                      	pop 	cx
   819 000004F2 5A                      	pop 	dx
   820 000004F3 5E                      	pop 	si
   821 000004F4 C3                      	ret
   822                                  
   823                                  ;========================================================================================
   824                                  ; DATA SECTION
   825                                  ;========================================================================================
   826                                  regs_90x60:
   827                                  ; MISC
   828 000004F5 E7                      	db	0E7h
   829                                  ; SEQuencer
   830 000004F6 0301030002              	db	03h, 01h, 03h, 00h, 02h
   831                                  ; CRTC
   832 000004FB 6B595A82608D0B3E        	db	6Bh, 59h,  5Ah, 82h, 60h,  8Dh, 0Bh,  3Eh,
   833 00000503 0047060700000000        	db	00h, 47h,  06h, 07h, 00h,  00h, 00h,  00h,
   834 0000050B EA0CDF2D08E805A3        	db	0EAh, 0Ch, 0DFh, 2Dh, 08h, 0E8h, 05h, 0A3h,
   835 00000513 FF                      	db 	0FFh
   836                                  ; GC (no)
   837                                  ; AC (no)
   838                                  
   839                                  str_stage2loaded:
   840 00000514 537461676520322042-     	db 	'Stage 2 Bootloader (boot2)', 0
   841 0000051D 6F6F746C6F61646572-
   842 00000526 2028626F6F74322900 
   843                                  
   844                                  str_errorDetectMem:
   845 0000052F 4572726F7220646574-     	db 	"Error detecting available memory, cannot continue", 0
   846 00000538 656374696E67206176-
   847 00000541 61696C61626C65206D-
   848 0000054A 656D6F72792C206361-
   849 00000553 6E6E6F7420636F6E74-
   850 0000055C 696E756500         
   851                                  
   852                                  str_floppyError:
   853 00000561 466C6F707079204572-     	db 	"Floppy Error, press any key to retry", $0A, 0
   854 0000056A 726F722C2070726573-
   855 00000573 7320616E79206B6579-
   856 0000057C 20746F207265747279-
   857 00000585 0A00               
   858                                  
   859                                  str_available_lomem:
   860 00000587 436F6E74696E756F75-     	db 	"Continuous 01K blocks below 0x01000000: 0x", 0
   861 00000590 732030314B20626C6F-
   862 00000599 636B732062656C6F77-
   863 000005A2 203078303130303030-
   864 000005AB 30303A20307800     
   865                                  
   866                                  str_available_himem:
   867 000005B2 436F6E74696E756F75-     	db 	"Continuous 64K blocks above 0x01000000: 0x", 0
   868 000005BB 732036344B20626C6F-
   869 000005C4 636B732061626F7665-
   870 000005CD 203078303130303030-
   871 000005D6 30303A20307800     
   872                                  
   873                                  str_select_partition:
   874 000005DD 557365207468652063-     	db 	"Use the cursor to select the partition to boot from.", 0
   875 000005E6 7572736F7220746F20-
   876 000005EF 73656C656374207468-
   877 000005F8 652070617274697469-
   878 00000601 6F6E20746F20626F6F-
   879 0000060A 742066726F6D2E00   
   880                                  
   881                                  str_err_not_bootable:
   882 00000612 546869732070617274-     	db 	"This partition is not marked as bootable!", 0
   883 0000061B 6974696F6E20697320-
   884 00000624 6E6F74206D61726B65-
   885 0000062D 6420617320626F6F74-
   886 00000636 61626C652100       
   887                                  
   888                                  str_err_kern_not_found:
   889 0000063C 436F756C64206E6F74-     	db	"Could not find KERNEL.BIN at the root of the drive!", 0
   890 00000645 2066696E64204B4552-
   891 0000064E 4E454C2E42494E2061-
   892 00000657 742074686520726F6F-
   893 00000660 74206F662074686520-
   894 00000669 64726976652100     
   895                                  
   896                                  str_err_clear_err:
   897 00000670 20<rept>                	times	0x40 db 0x20
   898 000006B0 00                      	db	0
   899                                  
   900                                  
   901                                  str_kernel_loading:
   902 000006B1 4C6F6164696E67206B-     	db 	"Loading kernel: ", 0
   903 000006BA 65726E656C3A2000   
   904                                  
   905                                  str_kernel_loaded_ok:
   906 000006C2 4B65726E656C206C6F-     	db 	"Kernel loaded. Transferring control now...", 0
   907 000006CB 616465642E20547261-
   908 000006D4 6E7366657272696E67-
   909 000006DD 20636F6E74726F6C20-
   910 000006E6 6E6F772E2E2E00     
   911                                  
   912                                  str_err_loadkernel:
   913 000006ED 436F756C64206E6F74-     	db 	"Could not load kernel: Fuck you", 0
   914 000006F6 206C6F6164206B6572-
   915 000006FF 6E656C3A204675636B-
   916 00000708 20796F7500         
   917                                  
   918                                  BootDevice:
   919 0000070D 00                      	db	0
   920                                  
   921                                  LastCursorPosition:
   922 0000070E 0000                    	dw	0
   923                                  
   924                                  MemBlocksAbove16M:
   925 00000710 0000                    	dw	0
   926                                  
   927                                  MemBlocksBelow16M:
   928 00000712 0000                    	dw	0
   929                                  
   930                                  MemMap_NumEntries:
   931 00000714 0000                    	dw	0
   932                                  
   933                                  HDD_BootablePartitions:
   934 00000716 00000000                	dd	0
   935                                  
   936                                  HDD_BootablePartitionsFATType:
   937 0000071A 00000000                	dd	0
   938                                  
   939                                  HDD_Selected:
   940 0000071E 00                      	db	0
   941                                  
   942                                  HDD_PartitionNames:
   943 0000071F 00<rept>                	times	(0xB+1)*4 db 0
   944                                  
   945                                  Temp_StrBuf:
   946 0000074F 00<rept>                	times	0x20 db 0
   947                                  
   948 0000076F 90                      	align 2
   949                                  ExtendedRead_Table:
   950 00000770 10                      	db	$10
   951 00000771 00                      	db	0
   952 00000772 0000                    	dw	0														; Num blocks
   953 00000774 0000                    	dw	0														; Dest
   954 00000776 0000                    	dw	0														; Memory page
   955 00000778 00000000                	dd	0														; Starting LBA
   956 0000077C 00000000                	dd	0	
   957                                  
   958                                  kernel_cluster:
   959 00000780 00000000                	dd	0
   960                                  
   961                                  kernel_filename:
   962 00000784 4B45524E454C202042-     	db	"KERNEL  BIN", 0
   963 0000078D 494E00             
   964                                  
   965                                  ;========================================================================================
   966                                  ; Global Descriptor Table
   967                                  ;========================================================================================
   968                                  	align	$10
   969                                  
   970                                  gdt_start:
   971 00000790 0000000000000000        	dd	$00, $00												; Null Descriptor
   972                                  
   973                                  	; Code segment
   974 00000798 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
   975 0000079A 0000                    	dw	$0000													; Base 0:15 = $0000
   976 0000079C 00                      	db	$00														; Base 16:23 = $00
   977 0000079D 9A                      	db	$9A														; Access byte: Present, ring 0, Exec, grow up, R/W
   978 0000079E CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
   979 0000079F 00                      	db	$00														; Base 24:31 = $00
   980                                  
   981                                  	; Data segment
   982 000007A0 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
   983 000007A2 0000                    	dw	$0000													; Base 0:15 = $0000
   984 000007A4 00                      	db	$00														; Base 16:23 = $00
   985 000007A5 92                      	db	$92														; Access byte: Present, ring 0, Not exec, grow up, R/W
   986 000007A6 CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
   987 000007A7 00                      	db	$00														; Base 24:31 = $00	
   988                                  
   989                                  gdt_table:
   990 000007A8 1700                    	dw	(gdt_table-gdt_start)-1									; Length
   991 000007AA [90070000]              	dd	gdt_start												; Physical address to GDT	
   992                                  
   993 000007AE 90<rept>                	align 4														; DWORD align
   994                                  	%include	"./fat.asm"
   995                              <1> ;========================================================================================
   996                              <1> ; FAT Filesystem Library v 0.1
   997                              <1> ; By Tristan Seifert
   998                              <1> ;
   999                              <1> ; All sector values returned by functions are "logical," i.e. they are relative to the
  1000                              <1> ; first sector of the filesystem.
  1001                              <1> ;
  1002                              <1> ; In addition, this library does not offer full support for FAT12 due to the uncommonality
  1003                              <1> ; of it on media besides floppy disks.
  1004                              <1> ;========================================================================================
  1005                              <1> ; Equates
  1006                              <1> ;========================================================================================
  1007                              <1> 
  1008                              <1> ;========================================================================================
  1009                              <1> ; Initialises the FAT filesystem library
  1010                              <1> ;========================================================================================
  1011                              <1> FAT_Init:
  1012 000007B0 B90001              <1> 	mov		cx, (1024/4)										; Clear 2 sectors worth
  1013 000007B3 66BA[400B0000]      <1> 	mov		edx, FAT_ReadBuffer									; Pointer to buffer
  1014 000007B9 6631C0              <1> 	xor		eax, eax											; Clear value ($00000000)
  1015                              <1> 
  1016                              <1> .clearLoop:
  1017 000007BC 66678902            <1> 	mov		DWORD [edx], eax									; Clear a DWORD
  1018 000007C0 6681C204000000      <1> 	add		edx, $04											; Increment pointer
  1019 000007C7 E2F3                <1> 	loop	.clearLoop											; Loop
  1020                              <1> 
  1021                              <1> .done:
  1022 000007C9 C3                  <1> 	ret
  1023                              <1>  
  1024                              <1> ;========================================================================================
  1025                              <1> ; Determines the type of FAT, give that the first logical sector of the partition is
  1026                              <1> ; pointed to by SI, and returns the FAT bit size in AL.
  1027                              <1> ;
  1028                              <1> ; This is how Microsoft recommends we determine FAT type:
  1029                              <1> ;
  1030                              <1> ; RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytesPerSec - 1)) / BPB_BytesPerSec
  1031                              <1> ; DataSectors = Total Sectors - (BPB_ReservedSectors + (BPB_NumFATs * FATSz) + RootDirSectors)
  1032                              <1> ; Count of clusters = DataSectors/BPB_SectorsPerCluster 
  1033                              <1> ;
  1034                              <1> ; FAT12: Total clusters < 4085
  1035                              <1> ; FAT16: Total clusters > 4085 && < 65525
  1036                              <1> ; FAT32: Total clusters > 65525
  1037                              <1> ;========================================================================================
  1038                              <1> FAT_DetermineType:
  1039 000007CA 60                  <1> 	pusha														; Push registers
  1040                              <1> 
  1041 000007CB E8EF00              <1> 	call	FAT_ReadBPB											; 
  1042                              <1> 
  1043                              <1> 	; Calculate RootDirSectors
  1044 000007CE 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1045 000007D1 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1046 000007D4 8B1E[FE0A]          <1> 	mov		bx,	WORD [FAT_BPB_RootEntCnt]						; Read root entries 
  1047 000007D8 66C1E305            <1> 	shl		ebx, 5												; Each root entry is 32 bytes
  1048                              <1> 
  1049 000007DC A1[EC0A]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1050 000007DF 48                  <1> 	dec		ax													; Subtract one
  1051 000007E0 6601D8              <1> 	add		eax, ebx											; Add root entry length to sector length
  1052                              <1> 
  1053 000007E3 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1054 000007E6 8B0E[EC0A]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1055 000007EA F7F1                <1> 	div		cx													; Divide by sector length (result = ax)
  1056 000007EC A3[080B]            <1> 	mov		WORD [FAT_RootDirSectors], ax						; Store result in memory
  1057                              <1> 
  1058                              <1> 	; Calculate number of data sectors
  1059 000007EF 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1060 000007F2 A0[FC0A]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1061                              <1> 
  1062 000007F5 668B0E[000B]        <1> 	mov		ecx, DWORD [FAT_BPB_FATSz]							; Read FAT size
  1063 000007FA 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in eax
  1064                              <1> 
  1065 000007FD 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1066 00000800 8B0E[FA0A]          <1> 	mov		cx, WORD [FAT_BPB_ReservedSectors]					; Read number of reserved sectors
  1067                              <1> 
  1068 00000804 6601C8              <1> 	add		eax, ecx											; Add count of reserved sectors to FAT size
  1069 00000807 668B0E[080B]        <1> 	mov		ecx, DWORD [FAT_RootDirSectors]						; Read RootDirSectors
  1070 0000080C 6601C8              <1> 	add		eax, ecx											; Add root directory sectors
  1071                              <1> 
  1072 0000080F 6691                <1> 	xchg	eax, ecx											; Subtract all of the above from total sectors
  1073                              <1> 
  1074 00000811 66A1[040B]          <1> 	mov		eax, DWORD [FAT_BPB_TotSec]							; Read total sector count
  1075 00000815 6629C8              <1> 	sub		eax, ecx											; Subtract from total sector count
  1076                              <1> 
  1077 00000818 66A3[0C0B]          <1> 	mov		DWORD [FAT_DataSectors], eax						; Store to memory
  1078                              <1> 
  1079                              <1> 	; Calculate cluster count
  1080 0000081C 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1081 0000081F 8A1E[F80A]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1082 00000823 66A1[0C0B]          <1> 	mov		eax, DWORD [FAT_DataSectors]						; Read number of data sectors
  1083 00000827 66F7F3              <1> 	div		ebx													; Divide by sectors/cluster value 
  1084                              <1> 
  1085 0000082A 66A3[180B]          <1> 	mov		DWORD [FAT_TotalClusters], eax						; Store result in EAX
  1086                              <1> 
  1087                              <1> 	; Now, do some comparisons!
  1088 0000082E 663DF50F0000        <1> 	cmp		eax, 4085											; Is the FS FAT12?
  1089 00000834 7F07                <1> 	jg		.notFAT12											; If not, branch
  1090                              <1> 
  1091 00000836 C606[200B]0C        <1> 	mov		BYTE [FAT_Type], 12									; FAT12
  1092 0000083B EB17                <1> 	jmp		SHORT .done											; Return
  1093                              <1> 
  1094                              <1> .notFAT12:
  1095 0000083D 663DF5FF0000        <1> 	cmp		eax, 65525											; Is the FS FAT16?
  1096 00000843 7F0A                <1> 	jg		.notFAT16											; If not, branch
  1097                              <1> 
  1098 00000845 E84C00              <1> 	call	FAT16_Calculate_RootDirSec							; Calculate location of root directory
  1099                              <1> 
  1100 00000848 C606[200B]10        <1> 	mov		BYTE [FAT_Type], 16									; FAT16
  1101 0000084D EB05                <1> 	jmp		SHORT .done											; Return
  1102                              <1> 
  1103                              <1> .notFAT16:
  1104                              <1> 	; Okay, if we get down here, it HAS to be FAT32 or a corrupt FS
  1105 0000084F C606[200B]20        <1> 	mov		BYTE [FAT_Type], 32									; FAT32
  1106                              <1> 
  1107                              <1> .done:
  1108 00000854 E80500              <1> 	call	FAT_Calculate_Misc									; Calculate miscellaneous stuff
  1109 00000857 61                  <1> 	popa														; Restore registers
  1110                              <1> 
  1111 00000858 A0[200B]            <1> 	mov		al, BYTE [FAT_Type]									; Store FAT type in AL
  1112                              <1> 
  1113 0000085B C3                  <1> 	ret
  1114                              <1> 
  1115                              <1> ;========================================================================================
  1116                              <1> ; Calculates miscellaneous values that the FAT driver uses later
  1117                              <1> ;========================================================================================
  1118                              <1> FAT_Calculate_Misc:
  1119 0000085C 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1120 0000085F 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1121 00000862 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1122                              <1> 
  1123 00000865 8B0E[080B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1124 00000869 8B1E[FA0A]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1125                              <1> 
  1126 0000086D 6601CB              <1> 	add		ebx, ecx											; Add to root dir sectors reserved sectors
  1127                              <1> 
  1128 00000870 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1129 00000873 8A0E[FC0A]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1130 00000877 66A1[000B]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1131 0000087B 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1132                              <1> 
  1133 0000087E 6601D8              <1> 	add		eax, ebx											; Add FAT sectors to root dir and reserved count
  1134                              <1> 
  1135 00000881 66A3[100B]          <1> 	mov		DWORD [FAT_FirstDataSector], eax					; Store first data sector
  1136                              <1> 
  1137 00000885 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1138 00000888 8B0E[080B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1139 0000088C 6629C8              <1> 	sub		eax, ecx											; Subtract ecx
  1140 0000088F 66A3[140B]          <1> 	mov		DWORD [FAT_FirstClusterLocation], eax				; Write shaften
  1141 00000893 C3                  <1> 	ret
  1142                              <1> 
  1143                              <1> ;========================================================================================
  1144                              <1> ; Calculates the sector for the root directory for FAT12 and FAT16.
  1145                              <1> ;========================================================================================
  1146                              <1> FAT16_Calculate_RootDirSec:
  1147 00000894 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1148 00000897 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1149 0000089A 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1150                              <1> 
  1151 0000089D 8B1E[FA0A]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1152                              <1> 
  1153 000008A1 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1154 000008A4 A0[FC0A]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1155                              <1> 
  1156 000008A7 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1157 000008AA 8A0E[FC0A]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1158 000008AE 66A1[000B]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1159 000008B2 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1160                              <1> 
  1161 000008B5 6601D8              <1> 	add		eax, ebx											; Add reserved sector count
  1162                              <1> 
  1163 000008B8 66A3[F40A]          <1> 	mov		DWORD [FAT_BPB_RootClus], eax						; Write location of root cluster
  1164                              <1> 
  1165                              <1> .done:
  1166 000008BC C3                  <1> 	ret
  1167                              <1> 
  1168                              <1> ;========================================================================================
  1169                              <1> ; Reads the BPB from the FAT 1st sector in SI.
  1170                              <1> ;========================================================================================
  1171                              <1> FAT_ReadBPB:
  1172 000008BD 8B440B              <1> 	mov		ax, WORD [si+11]									; Read Bytes/sector
  1173 000008C0 A3[EC0A]            <1> 	mov		WORD [FAT_BPB_BytesPerSec], ax						; ""
  1174                              <1> 
  1175 000008C3 8A440D              <1> 	mov		al, BYTE [si+13]									; Read sectors/cluster
  1176 000008C6 A2[F80A]            <1> 	mov		BYTE [FAT_BPB_SectorsPerCluster], al				; ""
  1177                              <1> 
  1178 000008C9 8B440E              <1> 	mov		ax, WORD [si+14]									; Read reserved sectors
  1179 000008CC A3[FA0A]            <1> 	mov		WORD [FAT_BPB_ReservedSectors], ax					; ""
  1180                              <1> 
  1181 000008CF 8A4410              <1> 	mov		al, BYTE [si+16]									; Read number of FATs
  1182 000008D2 A2[FC0A]            <1> 	mov		BYTE [FAT_BPB_NumFATs], al							; ""
  1183                              <1> 
  1184 000008D5 8B4411              <1> 	mov		ax, WORD [si+17]									; Read num root entries
  1185 000008D8 A3[FE0A]            <1> 	mov		WORD [FAT_BPB_RootEntCnt], ax						; ""
  1186                              <1> 
  1187 000008DB 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1188                              <1> 
  1189 000008DE 668B4420            <1> 	mov		eax, DWORD [si+32]									; Read BPB_TotSec32 first
  1190 000008E2 663D00000000        <1> 	cmp		eax, 0												; Is EAX zero?
  1191 000008E8 7503                <1> 	jne		.writeTotSec										; If not, branch
  1192                              <1> 
  1193 000008EA 8B4413              <1> 	mov		ax, WORD [si+19]									; Read BPB_TotSec16 first
  1194                              <1> 
  1195                              <1> .writeTotSec:
  1196 000008ED 66A3[040B]          <1> 	mov		DWORD [FAT_BPB_TotSec], eax							; ""
  1197                              <1> 
  1198 000008F1 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1199                              <1> 
  1200 000008F4 8B4416              <1> 	mov		ax, WORD [si+22]									; Read BPB_FATSz16
  1201 000008F7 3D0000              <1> 	cmp		ax, 0												; Is it zero?
  1202 000008FA 7507                <1> 	jne		.writeFATSz											; If not, branch.
  1203                              <1> 
  1204 000008FC 668B4424            <1> 	mov		eax, DWORD [si+36]									; Read BPB_FATSz32
  1205                              <1> 
  1206 00000900 E80500              <1> 	call	.readFAT32Specifics									; Read FAT32-specific data
  1207                              <1> 
  1208                              <1> .writeFATSz:
  1209 00000903 66A3[000B]          <1> 	mov		DWORD [FAT_BPB_FATSz], eax							; Write FAT size
  1210                              <1> 
  1211 00000907 C3                  <1> 	ret
  1212                              <1> 
  1213                              <1> ; All FAT32-specific stuff is read here
  1214                              <1> .readFAT32Specifics:
  1215 00000908 8B5C28              <1> 	mov		bx, WORD [si+40]									; Read BPB_ExtFlags
  1216 0000090B 891E[F00A]          <1> 	mov		WORD [FAT_BPB_ExtFlags], bx							; Write BPB_ExtFlags
  1217                              <1> 
  1218 0000090F 8B5C2A              <1> 	mov		bx, WORD [si+42]									; Read BPB_FSVer
  1219 00000912 891E[F20A]          <1> 	mov		WORD [FAT_BPB_FSVer], bx							; Write BPB_FSVer
  1220                              <1> 
  1221 00000916 668B5C2C            <1> 	mov		ebx, DWORD [si+44]									; Read BPB_RootClus
  1222 0000091A 66891E[F40A]        <1> 	mov		DWORD [FAT_BPB_RootClus], ebx						; Write BPB_RootClus
  1223                              <1> 
  1224 0000091F 8B5C30              <1> 	mov		bx, WORD [si+48]									; Read BPB_FSInfo
  1225 00000922 891E[EE0A]          <1> 	mov		WORD [FAT_BPB_FSInfo], bx							; Write BPB_FSInfo
  1226                              <1> 
  1227                              <1> 
  1228 00000926 C3                  <1> 	ret
  1229                              <1> 
  1230                              <1> ;========================================================================================
  1231                              <1> ; Calculates the entry location for cluster N in the FAT.
  1232                              <1> ; eax: Cluster number
  1233                              <1> ; eax: Sector number containing the cluster
  1234                              <1> ; ebx: Offset in sector
  1235                              <1> ;========================================================================================
  1236                              <1> FAT_FindClusterInTable:
  1237 00000927 60                  <1> 	pusha														; Back up regs
  1238                              <1> 
  1239 00000928 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1240 0000092B 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1241                              <1> 
  1242 0000092E 8A1E[200B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1243 00000932 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1244 00000935 7406                <1> 	je		.FAT32												; If so, jump
  1245                              <1> 
  1246 00000937 66D1E0              <1> 	shl		eax, 1												; Multiply cluster by 2
  1247 0000093A E90400              <1> 	jmp		.cont												; Skip over shift below
  1248                              <1> 
  1249                              <1> .FAT32:
  1250 0000093D 66C1E002            <1> 	shl		eax, 2												; Multiply cluster by 4
  1251                              <1> 
  1252                              <1> .cont:
  1253                              <1> 	; eax = Offset into FAT table
  1254                              <1> 
  1255 00000941 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1256 00000944 8B0E[EC0A]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1257 00000948 66F7F1              <1> 	div		ecx													; Divide offset by bytes/sector
  1258                              <1> 	; eax = quotient, edx = remainder
  1259                              <1> 
  1260 0000094B 8B1E[FA0A]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; BX = reserved sector count
  1261 0000094F 6601D8              <1> 	add		eax, ebx											; Add to FAT offset (sectors)
  1262                              <1> 
  1263 00000952 66A3[6709]          <1> 	mov		DWORD [.secNum], eax								; Store sector number
  1264 00000956 8916[6B09]          <1> 	mov		WORD [.secOff], dx									; Store offset into sector
  1265                              <1> 
  1266                              <1> .done:
  1267 0000095A 61                  <1> 	popa														; Restore regs
  1268                              <1> 
  1269 0000095B 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1270 0000095E 66A1[6709]          <1> 	mov		eax, DWORD [.secNum]								; Get sector number
  1271 00000962 8B1E[6B09]          <1> 	mov		bx, WORD [.secOff]									; Get offset into sector
  1272                              <1> 
  1273 00000966 C3                  <1> 	ret
  1274                              <1> 
  1275                              <1> .secNum:
  1276 00000967 00000000            <1> 	dd		0
  1277                              <1> 
  1278                              <1> .secOff:
  1279 0000096B 0000                <1> 	dw		0
  1280                              <1> 
  1281                              <1> ;========================================================================================
  1282                              <1> ; Converts the cluster number in eax into a sector number.
  1283                              <1> ;========================================================================================
  1284                              <1> FAT_ClusterToSector:
  1285 0000096D 6651                <1> 	push	ecx													; Back up EBX
  1286                              <1> 
  1287 0000096F 6648                <1> 	dec		eax													; Subtract 2 from cluster
  1288 00000971 6648                <1> 	dec		eax													; ""
  1289                              <1> 
  1290 00000973 6631C9              <1> 	xor		ecx, ecx											; Clear EBX
  1291 00000976 8A0E[F80A]          <1> 	mov		cl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1292 0000097A 66F7E1              <1> 	mul		ecx													; Multiply by number of sectors per cluster
  1293                              <1> 
  1294 0000097D 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1295 00000980 8B0E[080B]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Root directory sector
  1296 00000984 6601C8              <1> 	add		eax, ecx											; Add to sector count
  1297                              <1> 
  1298 00000987 668B0E[100B]        <1> 	mov		ecx, DWORD [FAT_FirstDataSector]					; Get first data sector
  1299 0000098C 6601C8              <1> 	add		eax, ecx											; Add data sector offset
  1300                              <1> 
  1301 0000098F 6659                <1> 	pop		ecx													; Restore EBX
  1302                              <1> 
  1303 00000991 C3                  <1> 	ret
  1304                              <1> 
  1305                              <1> ;========================================================================================
  1306                              <1> ; Reads the sector containing the FAT entry for the specified cluster, then returns the
  1307                              <1> ; FAT read from the sector.
  1308                              <1> ; eax: Cluster
  1309                              <1> ; Sets carry flag if error.
  1310                              <1> ;========================================================================================
  1311                              <1> FAT_ReadFAT:
  1312 00000992 E892FF              <1> 	call	FAT_FindClusterInTable								; Locate cluster
  1313 00000995 6653                <1> 	push	ebx													; Push offset into sector to stack
  1314                              <1> 
  1315                              <1> 	; Read sector to memory
  1316 00000997 E82500              <1> 	call	FAT_ReadSector										; Read sector
  1317 0000099A 665B                <1> 	pop		ebx													; Pop offset into sector
  1318 0000099C 721F                <1> 	jc 		SHORT .error										; If error, return
  1319                              <1> 
  1320                              <1> 	; Sector is now read to memory
  1321 0000099E 8A1E[200B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1322 000009A2 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1323 000009A5 740D                <1> 	je		.FAT32												; If so, jump
  1324                              <1> 
  1325 000009A7 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1326 000009AA 678B83[400B0000]    <1> 	mov		ax, WORD [FAT_ReadBuffer+ebx]						; Read FAT16 entry
  1327 000009B1 E90800              <1> 	jmp		.done												; Skip over read below
  1328                              <1> 
  1329                              <1> .FAT32:
  1330 000009B4 66678B83[400B0000]  <1> 	mov		eax, DWORD [FAT_ReadBuffer+ebx]						; Read FAT32 entry
  1331                              <1> 
  1332                              <1> .done:
  1333 000009BC C3                  <1> 	ret
  1334                              <1> 
  1335                              <1> .error:
  1336 000009BD F9                  <1> 	stc															; Set carry
  1337 000009BE C3                  <1> 	ret
  1338                              <1> 
  1339                              <1> ;========================================================================================
  1340                              <1> ; Reads a logical sector from the drive.
  1341                              <1> ; eax: Logical sector
  1342                              <1> ; Clears the carry flag if successful, set otherwise.
  1343                              <1> ;========================================================================================
  1344                              <1> FAT_ReadSector:
  1345 000009BF 660306[1C0B]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1346                              <1> 
  1347 000009C4 668B1E[240B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1348 000009C9 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1349 000009CC 7429                <1> 	je		.done												; If they are the same sector, branch
  1350                              <1> 
  1351 000009CE 66A3[300B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1352 000009D2 C706[2A0B]0100      <1> 	mov		WORD [FAT_ERTable+0x02], 0x01						; Read one sector
  1353 000009D8 C706[2C0B][400B]    <1> 	mov		WORD [FAT_ERTable+0x04], FAT_ReadBuffer				; Temporary sector buffer offset (seg 0)
  1354 000009DE C706[2E0B]0000      <1> 	mov		WORD [FAT_ERTable+0x06], 0x00						; Page 0
  1355                              <1> 
  1356 000009E4 66A3[240B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Store LBA we're loading
  1357                              <1> 
  1358 000009E8 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1359 000009E9 BE[280B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1360 000009EC B442                <1> 	mov 	ah, $42												; Extended Read
  1361 000009EE 8A16[210B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1362 000009F2 CD13                <1> 	int 	$13													; Perform read
  1363 000009F4 61                  <1> 	popa														; Pop registers
  1364 000009F5 7202                <1> 	jc 		SHORT .error										; If error, return
  1365                              <1> 
  1366                              <1> .done:
  1367 000009F7 F8                  <1> 	clc															; Clear carry
  1368 000009F8 C3                  <1> 	ret
  1369                              <1> 
  1370                              <1> .error:
  1371 000009F9 F9                  <1> 	stc															; Set carry
  1372 000009FA C3                  <1> 	ret
  1373                              <1> 
  1374                              <1> ;========================================================================================
  1375                              <1> ; Tries to locate a file with the name pointed to by in esi in the root directory of the
  1376                              <1> ; FAT. If found, returns the first cluster of the file in eax, filesize in ebx, and
  1377                              <1> ; clears carry. If not found, sets carry.
  1378                              <1> ;
  1379                              <1> ; Note that this only searches the short filename.
  1380                              <1> ;========================================================================================
  1381                              <1> FAT_FindFileAtRoot:
  1382 000009FB 60                  <1> 	pusha														; Push regs
  1383 000009FC 66A1[F40A]          <1> 	mov		eax, DWORD [FAT_BPB_RootClus]						; Read root sector location
  1384 00000A00 E86AFF              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1385 00000A03 E8B9FF              <1> 	call	FAT_ReadSector										; Read sector
  1386                              <1> 
  1387 00000A06 66BF[400B0000]      <1> 	mov		edi, FAT_ReadBuffer									; FAT read buffer
  1388 00000A0C B91000              <1> 	mov		cx, (512/32)										; Search the first 512/32 entries
  1389                              <1> 
  1390                              <1> .searchLoop:
  1391 00000A0F 678A07              <1> 	mov		al, BYTE [edi]										; Read first byte of string
  1392                              <1> 
  1393 00000A12 3CE5                <1> 	cmp		al, $0E5											; Is directory entry free?
  1394 00000A14 7426                <1> 	je		.fileEntryIgnore									; If so, branch
  1395 00000A16 3C00                <1> 	cmp		al, $00												; Is directory entry free and last one?
  1396 00000A18 7428                <1> 	je		.notFound											; If so, exit loop.
  1397                              <1> 
  1398                              <1> 	; Store pointers
  1399 00000A1A 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1400 00000A1D 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1401 00000A20 6689F8              <1> 	mov		eax, edi											; Copy read pointer to EAX
  1402 00000A23 6689F2              <1> 	mov		edx, esi											; Copy filename compare ptr to EDX
  1403                              <1> 
  1404                              <1> 	; Compare filename
  1405 00000A26 51                  <1> 	push	cx													; Push loop counter
  1406 00000A27 B90B00              <1> 	mov		cx, $0B												; Filename is 11 bytes
  1407                              <1> 
  1408                              <1> .comparison:
  1409 00000A2A 678A18              <1> 	mov		bl, BYTE [eax]										; Read soruce ptr
  1410 00000A2D 673A1A              <1> 	cmp		bl, BYTE [edx]										; Compare against target
  1411 00000A30 7509                <1> 	jne		.compareFailed										; If not equal, branch
  1412                              <1> 
  1413 00000A32 6640                <1> 	inc		eax													; Increment read pointer
  1414 00000A34 6642                <1> 	inc		edx													; Increment target pointer
  1415                              <1> 
  1416 00000A36 E2F2                <1> 	loop	.comparison											; Compare 11 bytes
  1417                              <1> 
  1418 00000A38 59                  <1> 	pop		cx													; Pop loop counter from stack
  1419 00000A39 EB0A                <1> 	jmp		SHORT .found										; File was found
  1420                              <1> 
  1421                              <1> .compareFailed:
  1422 00000A3B 59                  <1> 	pop		cx													; Pop loop counter
  1423                              <1> 
  1424                              <1> .fileEntryIgnore:
  1425 00000A3C 81C72000            <1> 	add		di, $20												; Read next entry
  1426 00000A40 E2CD                <1> 	loop	.searchLoop											; Loop through entries
  1427                              <1> 
  1428                              <1> ; Drop down here once loop finishes: file not found.
  1429                              <1> .notFound:
  1430 00000A42 61                  <1> 	popa														; Pop registers
  1431 00000A43 F9                  <1> 	stc															; Set carry
  1432 00000A44 C3                  <1> 	ret
  1433                              <1> 
  1434                              <1> ; We found the file
  1435                              <1> .found:
  1436 00000A45 678B471A            <1> 	mov		ax, WORD [edi+26]									; Read cluster low word
  1437 00000A49 A3[680A]            <1> 	mov		WORD [.clusterOfFile], ax							; ""
  1438 00000A4C 678B4714            <1> 	mov		ax, WORD [edi+20]									; Read cluster high word
  1439 00000A50 A3[6A0A]            <1> 	mov		WORD [.clusterOfFile+2], ax							; ""
  1440                              <1> 
  1441 00000A53 66678B471C          <1> 	mov		eax, DWORD [edi+28]									; Read filesize
  1442 00000A58 66A3[6C0A]          <1> 	mov		DWORD [.sizeOfFile], eax							; ""
  1443                              <1> 
  1444 00000A5C 61                  <1> 	popa														; Pop registers
  1445 00000A5D 66A1[680A]          <1> 	mov		eax, DWORD [.clusterOfFile]							; Read file's cluster
  1446 00000A61 668B1E[6C0A]        <1> 	mov		ebx, DWORD [.sizeOfFile]							; Read file's size
  1447 00000A66 F8                  <1> 	clc															; Clear carry bit
  1448 00000A67 C3                  <1> 	ret
  1449                              <1> 
  1450                              <1> 	align	4
  1451                              <1> .clusterOfFile:
  1452 00000A68 00000000            <1> 	dd		0
  1453                              <1> .sizeOfFile:
  1454 00000A6C 00000000            <1> 	dd		0
  1455                              <1> 
  1456                              <1> ;========================================================================================
  1457                              <1> ; Reads the file whose first cluster is in eax to es:di.
  1458                              <1> ;
  1459                              <1> ; Note that this function returns after reading a maximum of 256 chunks.
  1460                              <1> ;========================================================================================
  1461                              <1> FAT_ReadFile:
  1462 00000A70 60                  <1> 	pusha														; Push all regisers
  1463                              <1> 
  1464 00000A71 E80800              <1> 	call	FAT_ReadCluster										; Read cluster
  1465 00000A74 7203                <1> 	jc 		SHORT .error										; If error, return
  1466                              <1> 
  1467                              <1> ;	xor		cx, cx												; Clear CX
  1468                              <1> ;	mov		gs, cx												; Clear GS
  1469                              <1> ;
  1470                              <1> ;.readLoop:
  1471                              <1> ;	call	FAT_ReadFAT											; Read FAT entry for current cluster
  1472                              <1> ;	and		eax, $0FFFFFFF										; Ignore high nybble
  1473                              <1> ;	cmp		eax, $0FFFFFF8										; End of chain marker?
  1474                              <1> ;	jae		.done												; If so, branch (unsigned compare)
  1475                              <1> ;
  1476                              <1> ;	call	FAT_ReadCluster										; Read cluster
  1477                              <1> ;	jc 		SHORT .error										; If error, return
  1478                              <1> ;
  1479                              <1> ;	mov		cx, gs												; Read GS
  1480                              <1> ;	inc		cx													; Increment GS
  1481                              <1> ;	mov		gs, cx												; Move back to GS
  1482                              <1> ;
  1483                              <1> ;	cmp		cl, $0FF											; Is it max? ($FF)
  1484                              <1> ;	je		.error												; If so, we're done
  1485                              <1> ;
  1486                              <1> ;	jmp		.readLoop											; Loop until all sectors of the file are read
  1487                              <1> 
  1488                              <1> .done:
  1489 00000A76 61                  <1> 	popa														; Pop registers
  1490 00000A77 F8                  <1> 	clc															; Clear carry
  1491 00000A78 C3                  <1> 	ret
  1492                              <1> 
  1493                              <1> .error:
  1494 00000A79 61                  <1> 	popa														; Pop registers
  1495 00000A7A F9                  <1> 	stc															; Set carry
  1496 00000A7B C3                  <1> 	ret
  1497                              <1> 
  1498                              <1> ;========================================================================================
  1499                              <1> ; Reads a logical sector from the drive.
  1500                              <1> ; eax: Logical cluster
  1501                              <1> ; es:di: Memory location (Incremented after read)
  1502                              <1> ; Clears the carry flag if successful, set otherwise.
  1503                              <1> ;========================================================================================
  1504                              <1> FAT_ReadCluster:
  1505 00000A7C 66A3[E80A]          <1> 	mov		DWORD [.origCluster], eax							; Store original cluster
  1506 00000A80 E8EAFE              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1507                              <1> 
  1508 00000A83 660306[1C0B]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1509                              <1> 
  1510 00000A88 668B1E[240B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1511 00000A8D 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1512 00000A90 742E                <1> 	je		.done												; If they are the same sector, branch
  1513 00000A92 66A3[240B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Save sector we're reading
  1514                              <1> 
  1515 00000A96 31DB                <1> 	xor		bx, bx												; Clear BX
  1516 00000A98 8A1E[F80A]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1517 00000A9C C706[2A0B]7F00      <1> 	mov		WORD [FAT_ERTable+0x02], $7F							; Write sectors/cluster 
  1518 00000AA2 66A3[300B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1519 00000AA6 893E[2C0B]          <1> 	mov		WORD [FAT_ERTable+0x04], di							; Offset in segment
  1520 00000AAA 8C06[2E0B]          <1> 	mov		WORD [FAT_ERTable+0x06], es							; Segment
  1521                              <1> 
  1522 00000AAE 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1523 00000AAF BE[280B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1524 00000AB2 B442                <1> 	mov 	ah, $42												; Extended Read		
  1525 00000AB4 8A16[210B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1526 00000AB8 CD13                <1> 	int 	$13													; Perform read
  1527 00000ABA 61                  <1> 	popa														; Pop registers
  1528 00000ABB 7209                <1> 	jc 		SHORT .error										; If error, return
  1529                              <1> 
  1530 00000ABD E80C00              <1> 	call	.incrementReadPtr									; Increment read pointer
  1531                              <1> 
  1532                              <1> .done:	
  1533 00000AC0 66A1[E80A]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1534 00000AC4 F8                  <1> 	clc															; Clear carry
  1535 00000AC5 C3                  <1> 	ret
  1536                              <1> 
  1537                              <1> .error:
  1538 00000AC6 66A1[E80A]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1539 00000ACA F9                  <1> 	stc															; Set carry
  1540 00000ACB C3                  <1> 	ret
  1541                              <1> 
  1542                              <1> .incrementReadPtr:
  1543 00000ACC 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1544 00000ACF A1[EC0A]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1545 00000AD2 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1546 00000AD5 8A1E[F80A]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read bytes per sector
  1547                              <1> 
  1548 00000AD9 66F7E3              <1> 	mul		ebx													; EAX = value to add to write ptr
  1549 00000ADC 01C7                <1> 	add		di, ax												; Add cluster length to di
  1550 00000ADE 7107                <1> 	jno		.noOverflow											; If overflow bit isn't set, branch
  1551                              <1> 
  1552 00000AE0 8CC0                <1> 	mov		ax, es												; Read segment we're writing to
  1553 00000AE2 050010              <1> 	add		ax, $1000											; Write in next segment
  1554 00000AE5 8EC0                <1> 	mov		es, ax												; Write to segment register
  1555                              <1> 
  1556                              <1> .noOverflow:
  1557 00000AE7 C3                  <1> 	ret
  1558                              <1> 
  1559                              <1> 	align	4
  1560                              <1> .origCluster:
  1561 00000AE8 00000000            <1> 	dd		0
  1562                              <1> 
  1563                              <1> ;========================================================================================
  1564                              <1> ; Data section
  1565                              <1> ;========================================================================================
  1566                              <1> 	align	4
  1567                              <1> FAT_BPB_BytesPerSec: ; file offset 11
  1568 00000AEC 0000                <1> 	dw		0
  1569                              <1> FAT_BPB_FSInfo: ; file offset 48, FAT32 only
  1570 00000AEE 0000                <1> 	dw		0
  1571                              <1> FAT_BPB_ExtFlags: ; file offset 40, FAT32 only
  1572 00000AF0 0000                <1> 	dw		0
  1573                              <1> FAT_BPB_FSVer: ; file offset 42, FAT32 only
  1574 00000AF2 0000                <1> 	dw		0
  1575                              <1> 
  1576                              <1> 	align	4
  1577                              <1> FAT_BPB_RootClus: ; file offset 44, FAT32 only
  1578 00000AF4 00000000            <1> 	dd		0
  1579                              <1> FAT_BPB_SectorsPerCluster: ; file offset 13
  1580 00000AF8 00                  <1> 	db		0
  1581                              <1> 
  1582 00000AF9 90                  <1> 	align	2
  1583                              <1> FAT_BPB_ReservedSectors: ; file offset 14
  1584 00000AFA 0000                <1> 	dw		0
  1585                              <1> FAT_BPB_NumFATs: ; file offset 16
  1586 00000AFC 00                  <1> 	db		0
  1587                              <1> 
  1588 00000AFD 90                  <1> 	align	2
  1589                              <1> FAT_BPB_RootEntCnt:	; file offset 17
  1590 00000AFE 0000                <1> 	dw		0
  1591                              <1> 
  1592                              <1> 	align	4
  1593                              <1> FAT_BPB_FATSz: ; file offset 22 if FAT16, 36 if FAT32 and word at 22 is 0
  1594 00000B00 00000000            <1> 	dd		0
  1595                              <1> 
  1596                              <1> ; Works with FAT32
  1597                              <1> ; For the total sector count, try to read BPB_FATSz16 first (19), then the 32-bit at off 32
  1598                              <1> FAT_BPB_TotSec: ; file offset 32 if 19 = 0
  1599 00000B04 00000000            <1> 	dd		0
  1600                              <1> 
  1601                              <1> ; Calculated when identifying FS
  1602                              <1> FAT_RootDirSectors:
  1603 00000B08 0000                <1> 	dw		0
  1604                              <1> 
  1605 00000B0A 90<rept>            <1> 	align	4
  1606                              <1> FAT_DataSectors:
  1607 00000B0C 00000000            <1> 	dd		0
  1608                              <1> FAT_FirstDataSector:
  1609 00000B10 00000000            <1> 	dd		0
  1610                              <1> FAT_FirstClusterLocation:
  1611 00000B14 00000000            <1> 	dd		0
  1612                              <1> FAT_TotalClusters:
  1613 00000B18 00000000            <1> 	dd		0
  1614                              <1> 
  1615                              <1> ; Offset into drive in sectors to the start of the FAT partition
  1616                              <1> FAT_PartitionOffset:
  1617 00000B1C 00000000            <1> 	dd		0
  1618                              <1> FAT_Type:
  1619 00000B20 00                  <1> 	db		0
  1620                              <1> 
  1621                              <1> ; BIOS drive to read from
  1622                              <1> FAT_Drive:
  1623 00000B21 00                  <1> 	db		0
  1624                              <1> 
  1625 00000B22 90<rept>            <1> 	align	4
  1626                              <1> FAT_LastLoadedSector:
  1627 00000B24 00000000            <1> 	dd		0
  1628                              <1> 
  1629                              <1> 	align	4
  1630                              <1> FAT_ERTable:
  1631 00000B28 10                  <1> 	db	$10
  1632 00000B29 00                  <1> 	db	0
  1633 00000B2A 0000                <1> 	dw	0														; Num blocks
  1634 00000B2C 0000                <1> 	dw	0														; Dest
  1635 00000B2E 0000                <1> 	dw	0														; Memory page
  1636 00000B30 00000000            <1> 	dd	0														; Starting LBA
  1637 00000B34 00000000            <1> 	dd	0	
  1638                              <1> 
  1639 00000B38 90<rept>            <1> 	align	$10
  1640                              <1> FAT_ReadBuffer:
  1641                                  
  1642                                  	align 4
  1643                                  
  1644                                  SectorBuf:
  1645 00000B40 00<rept>                	times	512 db 0

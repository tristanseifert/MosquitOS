     1                                  	BITS	16
     2                                  	org		$0500
     3                                  
     4                                  ; Kernel will be loaded to segment $0300, or $003000 physical
     5                                  kern_loc:				EQU $0300
     6                                  kern_loc_phys:			EQU kern_loc<<4
     7                                  kern_start:				EQU 6
     8                                  kern_len:				EQU 32									; Length in sectors
     9                                  
    10                                  ; Location to store various BIOS info at
    11                                  Kern_Info_Struct:		EQU $0160								; $001600 phys (len = $400 max)
    12                                  Kern_Info_StructPhys:	EQU (Kern_Info_Struct<<4)
    13                                  VESA_SupportedModes:	EQU	$01A0								; $001A00 phys (len = $200)
    14                                  BIOS_MemMapSeg:			EQU	$0200								; $002000 phys (len = $800 max)
    15                                  
    16                                  ;	+$00 uint32_t munchieValue; // Should be "KERN"
    17                                  ;	+$04 uint16_t supportBits;
    18                                  ;	+$06 uint16_t high16Mem; // 64K blocks above 16M
    19                                  ;	+$08 uint16_t low16Mem; // 1k blocks below 16M
    20                                  ;	+$0A uint32_t memMap; // 32-bit ptr to list
    21                                  ;	+$0E uint16_t numMemMapEnt; // Number of entries in above map
    22                                  ;	+$10 uint8_t vesaSupport;
    23                                  ;	+$11 uint8_t bootDrive;
    24                                  ;	+$12 uint32_t vesaMap;
    25                                  
    26                                  stage2_start:
    27 00000000 B80080                  	mov		ax, $8000											; AX = stack segment value (Stack to go at $80000)
    28 00000003 8ED0                    	mov 	ss, ax
    29 00000005 BC0010                  	mov 	sp, 4096											; Set up SP
    30                                  
    31 00000008 8CC8                    	mov 	ax, cs												; Set data segment to where we're loaded
    32 0000000A 8ED8                    	mov 	ds, ax
    33                                  
    34 0000000C 8816[F906]              	mov		BYTE [BootDevice], dl								; Save boot device number
    35 00000010 8816[110B]              	mov		BYTE [FAT_Drive], dl								; Set FAT read drive
    36                                  
    37 00000014 66C70600164B45524E      	mov		DWORD [Kern_Info_StructPhys], "KERN"				; Set magic value for kern struct
    38                                  
    39 0000001D A0[F906]                	mov		al, [BootDevice]									; Set boot drive
    40 00000020 A21116                  	mov		BYTE [Kern_Info_StructPhys+$11], al					; ""
    41                                  
    42                                  	; Set up video
    43 00000023 B400                    	mov		ah, $00												; Change video mode
    44 00000025 B003                    	mov		al, $03												; 80x25 text mode
    45 00000027 CD10                    	int		$10													; Call video BIOS
    46                                  
    47 00000029 BE[0005]                	mov 	si, str_stage2loaded								; Put string position into SI
    48 0000002C 31D2                    	xor		dx, dx												; Cursor position
    49 0000002E BF2F00                  	mov		di, $2F												; Set colour
    50 00000031 E82603                  	call 	print_string										; Call string printing routine
    51                                  
    52                                  	; Call VESA BIOS routines to get supported video modes
    53 00000034 B8A001                  	mov		ax, VESA_SupportedModes								; Memory location of supported mode struct
    54 00000037 8EC0                    	mov		es, ax												; ""
    55 00000039 31FF                    	xor		di, di												; Offset 0 in segment
    56                                  
    57 0000003B 2666C70556424532        	mov		[es:di], DWORD "VBE2"								; Tell BIOS we want 512 bytes of data
    58                                  
    59 00000043 B8004F                  	mov		ax, $4F00											; VESA BIOS routines â€” get supported modes
    60 00000046 CD10                    	int		$10													; Perform lookup
    61                                  
    62 00000048 84E4                    	test	ah, ah												; Is AH not zero (i.e. error)
    63 0000004A 7400                    	je		.vesaDone											; If so, VESA is unsupported
    64                                  
    65                                  .vesaDone:
    66                                  	; Call BIOS to get memory information
    67 0000004C 31C9                    	xor 	cx, cx
    68 0000004E 31D2                    	xor 	dx, dx
    69 00000050 B801E8                  	mov 	ax, $0E801
    70 00000053 CD15                    	int 	$15													; Request upper memory size
    71 00000055 7250                    	jc 		error_memoryDetect
    72 00000057 80FC86                  	cmp 	ah, $86												; Unsupported function
    73 0000005A 744B                    	je		error_memoryDetect
    74 0000005C 80FC80                  	cmp		ah, $80												; Invalid command
    75 0000005F 7446                    	je		error_memoryDetect
    76 00000061 E304                    	jcxz 	.useax												; Was the CX result invalid?
    77                                   
    78 00000063 89C8                    	mov		ax, cx												; Number of continuous 1K blocks (1M-16M)
    79 00000065 89D3                    	mov		bx, dx												; Number of continuous 64K block above 16M
    80                                  
    81                                  .useax:
    82 00000067 31FF                    	xor		di, di												; Clear DI
    83 00000069 891E[FC06]              	mov		WORD [MemBlocksAbove16M], bx						; Store amount of memory available
    84 0000006D 891E0616                	mov		WORD [Kern_Info_StructPhys+$06], bx					; Highmem
    85 00000071 A3[FE06]                	mov		WORD [MemBlocksBelow16M], ax						; ""
    86 00000074 A30816                  	mov		WORD [Kern_Info_StructPhys+$08], ax					; Lowmem
    87                                  
    88 00000077 E8BB02                  	call	display_memsize										; Display the memory size
    89                                  
    90                                  	; Fetch memory map
    91 0000007A B80002                  	mov 	ax, BIOS_MemMapSeg									; Write mem map to $01800 in physical space
    92 0000007D 8EC0                    	mov 	es, ax
    93 0000007F 31FF                    	xor		di, di												; Start of segment
    94                                  
    95 00000081 E87F03                  	call	fetch_mem_map										; Fetch a memory map
    96 00000084 7221                    	jc 		SHORT error_memoryDetect							; Branch if error
    97                                  
    98 00000086 892E0E16                	mov		WORD [Kern_Info_StructPhys+$0E], bp					; ""
    99 0000008A 66C7060A1600200000      	mov		DWORD [Kern_Info_StructPhys+$0A], (BIOS_MemMapSeg<<4); Physical location of table
   100                                  
   101                                  	; Initialise FAT library
   102 00000093 E80A07                  	call	FAT_Init
   103                                  
   104                                  	; Check which partitions are bootable from MBR partition map
   105 00000096 E8EB01                  	call	find_bootable_partitions
   106 00000099 C606[0A07]00            	mov		BYTE [HDD_Selected], 0								; Clear HDD selection
   107                                  
   108                                  	; Set up the partition chooser UI
   109 0000009E E86900                  	call	render_partition_chooser
   110                                  
   111                                  	; Process keypresses, and loads kernel from FS if ENTER is pressed
   112 000000A1 E85C01                  	call	chooser_loop
   113 000000A4 E90800                  	jmp		boot
   114                                  
   115                                  ;========================================================================================
   116                                  ; Memory detection error handler
   117                                  ;========================================================================================
   118                                  error_memoryDetect:
   119 000000A7 BE[1B05]                	mov 	si, str_errorDetectMem								; Put string position into SI
   120 000000AA E8A702                  	call 	print_error											; Call string printing routine
   121 000000AD EBFE                    	jmp		$
   122                                  
   123                                  ;========================================================================================
   124                                  ; Code to boot the kernel
   125                                  ;========================================================================================
   126                                  boot:
   127                                  	; Hide cursor
   128 000000AF 31D2                    	xor		dx, dx												; Clear dx
   129 000000B1 F7D2                    	not		dx													; dx = $FFFF
   130 000000B3 B402                    	mov 	ah, $02												; Set cursor position
   131 000000B5 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   132 000000B7 CD10                    	int		$10													; Set cursor
   133                                  
   134                                  	; Set up GDT
   135 000000B9 FA                      	cli															; Disable ints
   136 000000BA 0F0116[9807]            	lgdt	[gdt_table]											; Set up GDTR
   137                                  
   138                                  	; Jump into protected mode, woot!
   139 000000BF 0F20C0                  	mov		eax, cr0											; Get control reg
   140 000000C2 0C01                    	or		al, 00000001b										; Set PE bit
   141 000000C4 0F22C0                  	mov		cr0, eax											; Write control reg
   142                                  
   143                                  	; Set up selectors
   144 000000C7 B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   145 000000CA 8ED8                    	mov		ds, ax												; Set data selector
   146                                  
   147 000000CC B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   148 000000CF 8EC0                    	mov		es, ax												; Update other selectors to point to data segment
   149 000000D1 8EE0                    	mov		fs, ax
   150 000000D3 8EE8                    	mov		gs, ax
   151 000000D5 8ED0                    	mov		ss, ax
   152                                  
   153                                  	; The kernel is loaded to $00003000 phys (segmented address 0300h:0000h)
   154 000000D7 66                      	db		$66													; 32-bit prefix
   155 000000D8 EA                      	db		$0EA												; Far jump opcode
   156 000000D9 [DF000000]              	dd		copy_kernel											; Jump to kernel copying routine
   157 000000DD 0800                    	dw		$08													; Selector for CODE32_DESCRIPTOR
   158                                  
   159                                  	BITS	32
   160                                  copy_kernel:
   161 000000DF BC00004000              	mov		esp, $400000										; Stackzors at $400000
   162                                  
   163 000000E4 B800300000              	mov		eax, kern_loc_phys									; Physical kernel location
   164 000000E9 BB00001000              	mov		ebx, $00100000										; Destination memory address
   165 000000EE B900400000              	mov		ecx, $4000											; Number of long-words to copy (64KB)
   166                                  
   167 000000F3 90                      	align	4													; DWORD align
   168                                  .copy:
   169 000000F4 8B10                    	mov		edx, DWORD [eax]									; Read a DWORD from lowmem
   170 000000F6 8913                    	mov		DWORD [ebx], edx									; Write DWORD to himem
   171                                  
   172 000000F8 0504000000              	add		eax, $04											; Increment read ptr
   173 000000FD 81C304000000            	add		ebx, $04											; Increment write ptr
   174                                  
   175 00000103 E2EF                    	loop	.copy												; Loop and copy everything
   176 00000105 E9(00001000)            	jmp		$100000												; Jump into relocated kernel
   177                                  
   178                                  	BITS	16
   179                                  
   180                                  ;========================================================================================
   181                                  ; Renders the partition chooser
   182                                  ;========================================================================================
   183                                  render_partition_chooser:
   184 0000010A BE[C905]                	mov 	si, str_select_partition							; Put string position into SI
   185 0000010D BA0105                  	mov		dx, $0501											; Cursor position
   186 00000110 BF0700                  	mov		di, $07												; Set colour
   187 00000113 E84402                  	call 	print_string										; Call string printing routine
   188                                  
   189 00000116 C706[FA06]0407          	mov		WORD [LastCursorPosition], 0x0704					; Read last cursor position
   190                                  
   191 0000011C 66BA[02070000]          	mov		edx, HDD_BootablePartitions							; EDX contains bootable partition ptr
   192 00000122 B90400                  	mov		cx, $04												; Loop 4x
   193                                  
   194                                  .disp_loop:
   195 00000125 678A02                  	mov		al, BYTE [edx]										; Read bootability
   196 00000128 2480                    	and		al, $80												; Get high bit only
   197 0000012A 3C80                    	cmp		al, $80												; Is it $80?
   198 0000012C 7505                    	jne		.not_bootable										; If not, it's not a bootable drive
   199                                  
   200 0000012E E81300                  	call	.render_boot										; Render bootable drive label
   201                                  
   202 00000131 EB03                    	jmp		SHORT .next											; Skip over non-bootable code
   203                                  
   204                                  .not_bootable:
   205 00000133 E87600                  	call	.render_noboot										; Render non-bootable drive label
   206                                  
   207                                  .next:
   208 00000136 6642                    	inc		edx													; Go to next item
   209 00000138 E2EB                    	loop	.disp_loop											; Loop over all 4 partitions
   210                                  
   211 0000013A BA010C                  	mov		dx, $0C01
   212 0000013D BE[5C06]                	mov		si, str_err_clear_err								; Clear error
   213 00000140 E81702                  	call	print_string										; Display
   214                                  
   215 00000143 C3                      	ret
   216                                  
   217                                  ;========================================================================================
   218                                  ; Renders an entry for a bootable drive
   219                                  ;========================================================================================
   220                                  .render_boot:
   221 00000144 B004                    	mov		al, $04												; Max drive num to al
   222 00000146 28C8                    	sub		al, cl												; Subtract loop counter
   223 00000148 A2[AB01]                	mov		BYTE [.index], al									; Write index
   224 0000014B 0430                    	add		al, $30												; ASCII numbers
   225                                  
   226 0000014D 66C706[3B07]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   227 00000155 2C                 
   228 00000156 A2[3F07]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   229 00000159 C706[4007]3A20          	mov		WORD [Temp_StrBuf+5], ": "							; Colon, space
   230                                  
   231 0000015F 60                      	pusha														; Push registers
   232 00000160 66BA[42070000]          	mov		edx, Temp_StrBuf+7									; String buffer write place
   233 00000166 66BB[0B070000]          	mov		ebx, HDD_PartitionNames								; Partition names
   234 0000016C B90C00                  	mov		cx, $0C												; $0C characters
   235                                  
   236                                  .copyNameLoop:
   237 0000016F 678A03                  	mov		al, BYTE [ebx]										; Copy a character
   238 00000172 678802                  	mov		BYTE [edx], al										; Write to temp buffer
   239 00000175 6643                    	inc		ebx													; Increment read pointer
   240 00000177 6642                    	inc		edx													; Increment write pointer
   241 00000179 E2F4                    	loop	.copyNameLoop
   242                                  
   243 0000017B 67C742FF0A00            	mov		WORD [edx-1], 0x000A								; Insert newline
   244                                  
   245 00000181 6631C0                  	xor		eax, eax											; Clear EAX
   246 00000184 66BA[06070000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type matrix
   247 0000018A 0216[AB01]              	add		dl, BYTE [.index]
   248 0000018E 678A02                  	mov		al, BYTE [edx]										; Read FAT type to AL
   249                                  
   250 00000191 8A1E[0A07]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   251 00000195 80E303                  	and		bl, $3												; Get low 2 bits only
   252 00000198 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   253 0000019A 7503                    	jne		.no_highlight										; If not, branch.
   254                                  
   255 0000019C BF7000                  	mov		di, $070											; Black text on white background
   256                                  
   257                                  .no_highlight:
   258 0000019F 8B16[FA06]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   259 000001A3 BE[3B07]                	mov		si, Temp_StrBuf										; Temporary string buffer
   260 000001A6 E8B101                  	call 	print_string										; Call string printing routine
   261 000001A9 61                      	popa														; Pop registers
   262                                  
   263 000001AA C3                      	ret
   264                                  
   265                                  .index:
   266 000001AB 00                      	db	0
   267                                  
   268                                  ;========================================================================================
   269                                  ; Renders an entry for a non-bootable drive.
   270                                  ;========================================================================================
   271                                  	align 4
   272                                  
   273                                  .render_noboot:
   274 000001AC B004                    	mov		al, $04												; Max drive num to al
   275 000001AE 28C8                    	sub		al, cl												; Subtract loop counter
   276 000001B0 0430                    	add		al, $30												; ASCII numbers
   277                                  
   278 000001B2 66C706[3B07]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   279 000001BA 2C                 
   280 000001BB A2[3F07]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   281 000001BE 66C706[4007]3A204E-     	mov		DWORD [Temp_StrBuf+5], ": No"						; "Not Bootable"
   282 000001C6 6F                 
   283 000001C7 66C706[4407]742042-     	mov		DWORD [Temp_StrBuf+9], "t Bo"
   284 000001CF 6F                 
   285 000001D0 66C706[4807]6F7461-     	mov		DWORD [Temp_StrBuf+13], "otab"
   286 000001D8 62                 
   287 000001D9 C706[4C07]6C65          	mov		WORD [Temp_StrBuf+17], "le"
   288 000001DF C706[4E07]0A00          	mov		WORD [Temp_StrBuf+19], 0x000A						; Newline, terminator
   289                                  
   290 000001E5 60                      	pusha														; Push registers
   291                                  
   292 000001E6 8A1E[0A07]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   293 000001EA 80E303                  	and		bl, $3												; Get low 2 bits only
   294 000001ED 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   295 000001EF 7503                    	jne		.no_highlight2										; If not, branch.
   296                                  
   297 000001F1 BF7000                  	mov		di, $070											; Black text on white background
   298                                  
   299                                  .no_highlight2:
   300 000001F4 8B16[FA06]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   301 000001F8 BE[3B07]                	mov		si, Temp_StrBuf										; Temporary string buffer
   302 000001FB E85C01                  	call 	print_string										; Call string printing routine
   303 000001FE 61                      	popa														; Pop registers
   304                                  
   305 000001FF C3                      	ret
   306                                  
   307                                  ;========================================================================================
   308                                  ; Handle keypresses for chooser
   309                                  ;========================================================================================
   310                                  chooser_loop:
   311 00000200 E91500                  	jmp		partition_chooser_enter
   312                                  
   313 00000203 30E4                    	xor		ah, ah												; Wait for keystroke
   314 00000205 CD16                    	int		$16													; Call into BIOS
   315                                  
   316 00000207 80FC50                  	cmp		ah, $50												; Down pressed?
   317 0000020A 7459                    	je		partition_chooser_dn
   318                                  
   319 0000020C 80FC48                  	cmp		ah, $48												; Up pressed?
   320 0000020F 7463                    	je		partition_chooser_up
   321                                  
   322 00000211 80FC1C                  	cmp		ah, $1C												; Enter pressed?
   323 00000214 7402                    	je		partition_chooser_enter
   324                                  
   325 00000216 EBE8                    	jmp		chooser_loop
   326                                  
   327                                  partition_chooser_enter:
   328 00000218 31DB                    	xor		bx, bx												; Clear BX
   329 0000021A 8A1E[0A07]              	mov		bl, BYTE [HDD_Selected]								; Get selection
   330                                  
   331 0000021E 8A87[0207]              	mov		al, BYTE [HDD_BootablePartitions+bx]				; Check bootability status
   332 00000222 2480                    	and		al, $80												; Get high bit only
   333 00000224 3C80                    	cmp		al, $80
   334 00000226 7527                    	jne		.noBootErr											; If not bootable, branch
   335                                  
   336 00000228 BE[7007]                	mov		si, kernel_filename									; Filename to find
   337 0000022B E8BD07                  	call	FAT_FindFileAtRoot									; Find file
   338 0000022E 722A                    	jc		.fileNotFound										; Carry set = KERNEL.BIN not found
   339                                  
   340 00000230 66A3[6C07]              	mov		DWORD [kernel_cluster], eax							; Store cluster
   341                                  
   342 00000234 31C0                    	xor		ax, ax												; Segment 0
   343 00000236 8EC0                    	mov		es, ax												; Write segment											
   344 00000238 BF0030                  	mov		di, kern_loc_phys									; Offset into segment
   345                                  
   346 0000023B 66A1[6C07]              	mov		eax, DWORD [kernel_cluster]							; Kernel's cluster location
   347 0000023F E81E08                  	call	FAT_ReadFile										; Read file
   348                                  
   349 00000242 BE[AE06]                	mov 	si, str_kernel_loaded_ok							; Put string position into SI
   350 00000245 BA010C                  	mov		dx, $0C01											; Cursor position
   351 00000248 BF0200                  	mov		di, $02												; Set colour
   352 0000024B E80C01                  	call 	print_string										; Call string printing routine
   353                                  
   354 0000024E C3                      	ret
   355                                  
   356                                  .noBootErr:
   357 0000024F BA010C                  	mov		dx, $0C01
   358 00000252 BE[FE05]                	mov		si, str_err_not_bootable							; Not bootable error
   359 00000255 E8FC00                  	call	print_error											; Display
   360 00000258 EBA6                    	jmp		chooser_loop
   361                                  
   362                                  .fileNotFound:
   363 0000025A BA010C                  	mov		dx, $0C01
   364 0000025D BE[2806]                	mov		si, str_err_kern_not_found							; Not found error
   365 00000260 E8F100                  	call	print_error											; Display
   366 00000263 EB9B                    	jmp		chooser_loop
   367                                  
   368                                  partition_chooser_dn:
   369 00000265 A0[0A07]                	mov		al, BYTE [HDD_Selected]								; Read selection
   370 00000268 FEC8                    	dec		al													; Move cursor up
   371 0000026A 2403                    	and		al, $03												; Get low 2 bits only
   372 0000026C A2[0A07]                	mov		BYTE [HDD_Selected], al								; Restore
   373                                  
   374 0000026F E898FE                  	call	render_partition_chooser							; Update display
   375 00000272 EB8C                    	jmp		chooser_loop
   376                                  
   377                                  partition_chooser_up:
   378 00000274 A0[0A07]                	mov		al, BYTE [HDD_Selected]								; Read selection
   379 00000277 FEC0                    	inc		al													; Move cursor down
   380 00000279 2403                    	and		al, $03												; Get low 2 bits only
   381 0000027B A2[0A07]                	mov		BYTE [HDD_Selected], al								; Restore
   382                                  
   383 0000027E E889FE                  	call	render_partition_chooser							; Update display
   384 00000281 E97CFF                  	jmp		chooser_loop
   385                                  
   386                                  ;========================================================================================
   387                                  ; Finds all partitions that are bootable.
   388                                  ;========================================================================================
   389                                  find_bootable_partitions:
   390 00000284 B90400                  	mov		cx, $4												; MBR contains 4 partition maps
   391                                  
   392 00000287 B8C007                  	mov		ax, $07C0											; Bootloader at 0x7C00
   393 0000028A 8EC0                    	mov		es, ax												; Set ES to the bootloader's place in memory
   394 0000028C BFBE01                  	mov		di, $1BE											; Start of partition map
   395                                  
   396 0000028F 8CD8                    	mov		ax, ds												; Fetch data segment
   397 00000291 8EE8                    	mov		gs, ax												; Set GS to data segment
   398                                  
   399 00000293 66BE[02070000]          	mov		esi, HDD_BootablePartitions							; ESI contains bootable partition ptr
   400 00000299 66BA[0B070000]          	mov		edx, HDD_PartitionNames								; Partition name ptr
   401                                  
   402                                  .loop:
   403 0000029F 268A05                  	mov		al, BYTE [es:di]									; Read bootable flag
   404 000002A2 2480                    	and		al, $80												; Get high bit only
   405 000002A4 3C80                    	cmp		al, $80												; Is it $80?
   406 000002A6 754B                    	jne		.not_bootable										; If not, it's not a bootable drive
   407                                  
   408 000002A8 678806                  	mov		BYTE [esi], al										; Write bootability flag
   409                                  
   410 000002AB 880E[0A07]              	mov		BYTE [HDD_Selected], cl								; Write index
   411                                  
   412                                  	; Try to read the LBA of the partition
   413 000002AF 26668B4508              	mov		eax, DWORD [es:di+8]								; Read partition LBA
   414 000002B4 663D00000000            	cmp		eax, $00											; Is it zero?
   415 000002BA 7437                    	je		.no_valid_lba										; If so, fuck off
   416                                  
   417 000002BC 66A3[6407]              	mov		DWORD [ExtendedRead_Table+0x08], eax				; Write LBA
   418 000002C0 C706[5E07]0100          	mov		WORD [ExtendedRead_Table+0x02], 0x01				; Read one sector
   419 000002C6 C706[6007][300B]        	mov		WORD [ExtendedRead_Table+0x04], SectorBuf			; Temporary sector buffer offset (seg 0)
   420                                  
   421 000002CC 66A3[0C0B]              	mov		DWORD [FAT_PartitionOffset], eax					; Write offset into FAT
   422                                  
   423 000002D0 60                      	pusha														; Push registers (BIOS may clobber them)
   424 000002D1 BE[5C07]                	mov 	si, ExtendedRead_Table								; address of "disk address packet"
   425 000002D4 B442                    	mov 	ah, $42												; Extended Read
   426 000002D6 8A16[F906]              	mov		dl, BYTE [BootDevice]								; Device number
   427 000002DA CD13                    	int 	$13
   428 000002DC 61                      	popa														; Pop registers
   429 000002DD 7214                    	jc 		SHORT .no_valid_lba									; If error, fuck off
   430                                  
   431 000002DF E82100                  	call	.typeDetermine										; Determine type and label loc
   432                                  
   433 000002E2 51                      	push	cx													; Back up original loop counter
   434                                  
   435 000002E3 B90B00                  	mov		cx, $0B												; Copy 0xB bytes
   436                                  .copy_str_loop:
   437 000002E6 678A18                  	mov		bl, BYTE [eax]										; Copy from source
   438 000002E9 67881A                  	mov		BYTE [edx], bl										; Write to target buffer
   439 000002EC 6640                    	inc		eax													; Increment read pointer
   440 000002EE 6642                    	inc		edx													; Increment write pointer
   441 000002F0 E2F4                    	loop	.copy_str_loop										; Copy all bytes.
   442                                  
   443 000002F2 59                      	pop		cx													; Restore original loop counter.
   444                                  
   445                                  .no_valid_lba:
   446                                  
   447                                  .not_bootable:
   448 000002F3 81C71000                	add		di, $10												; Go to next entry in bootsector
   449 000002F7 6646                    	inc		esi													; Write next bootability flag
   450 000002F9 6681C20C000000          	add		edx, $0C											; Each entry of partition names is 0x0C in length
   451 00000300 E29D                    	loop	.loop												; Loop through all partitions
   452                                  
   453                                  .done:
   454 00000302 C3                      	ret
   455                                  
   456                                  ; Determines FAT type and stores pointer to read volume label in eax
   457                                  .typeDetermine:
   458 00000303 6656                    	push	esi													; Push old ESI
   459 00000305 BE[300B]                	mov		si, SectorBuf										; Sector buffer
   460 00000308 E8AF04                  	call	FAT_DetermineType									; Determine type of FS
   461 0000030B 665E                    	pop		esi													; Pop ESI
   462                                  
   463 0000030D 6652                    	push	edx													; Back up EDX
   464 0000030F B304                    	mov		bl, $04												; Max drive num to al
   465 00000311 28CB                    	sub		bl, cl												; Subtract loop counter
   466                                  
   467 00000313 66BA[06070000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type ptr
   468 00000319 28DA                    	sub		dl, bl												; Subtract index
   469 0000031B 678802                  	mov		BYTE [edx], al										; Write FAT size
   470 0000031E 665A                    	pop		edx													; Restore EDX
   471                                  
   472 00000320 3C20                    	cmp		al, $20												; Is it a FAT32 volume?
   473 00000322 7509                    	jne		.fat16_label										; If so, branch
   474                                  
   475 00000324 66B8[770B0000]          	mov		eax, SectorBuf+$47									; FAT32 has volume label at 0x47
   476                                  
   477 0000032A E90600                  	jmp		.copy												; Copy label
   478                                  
   479                                  	; Extract volume label from sector buffer
   480                                  .fat16_label:
   481 0000032D 66B8[5B0B0000]          	mov		eax, SectorBuf+$2B									; FAT16 has volume label at 0x2B
   482                                  
   483                                  .copy:
   484 00000333 C3                      	ret
   485                                  
   486                                  .index:
   487 00000334 00                      	db		0
   488                                  
   489                                  ;========================================================================================
   490                                  ; Displays the memory size on the screen 
   491                                  ;========================================================================================
   492                                  display_memsize:
   493 00000335 BE[7305]                	mov 	si, str_available_lomem								; Put string position into SI
   494 00000338 BA0002                  	mov		dx, $0200
   495 0000033B E81C00                  	call 	print_string										; Call string printing routine
   496 0000033E A1[FE06]                	mov		ax, WORD [MemBlocksBelow16M]						; Get total of memory blocks to EDX
   497 00000341 E88100                  	call	hex_to_ascii
   498                                  
   499 00000344 BE[9E05]                	mov 	si, str_available_himem								; Put string position into SI
   500 00000347 BA0003                  	mov		dx, $0300
   501 0000034A E80D00                  	call 	print_string										; Call string printing routine
   502 0000034D A1[FC06]                	mov		ax, WORD [MemBlocksAbove16M]						; Get total of memory blocks to EDX
   503 00000350 E87200                  	call	hex_to_ascii
   504                                  
   505 00000353 C3                      	ret
   506                                  
   507                                  ;========================================================================================
   508                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h with the styling
   509                                  ; required for an error string.
   510                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   511                                  ;========================================================================================
   512                                  print_error:
   513 00000354 BF4F00                  	mov		di, $04F											; White text on red background
   514 00000357 E90000                  	jmp 	print_string										; Call string printing routine
   515                                  
   516                                  ;========================================================================================
   517                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h.
   518                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   519                                  ;========================================================================================
   520                                  print_string:
   521 0000035A 52                      	push	dx													; Push column
   522                                  
   523 0000035B 85FF                    	test	di, di												; Check if DI is set
   524 0000035D 7406                    	jz		.useDefaultColour									; If so, branch
   525                                  
   526 0000035F 89F8                    	mov		ax, di												; Set colour
   527 00000361 88C3                    	mov		bl, al												; Get low byte only
   528 00000363 EB02                    	jmp		SHORT .setCursor
   529                                  
   530                                  .useDefaultColour:
   531 00000365 B307                    	mov		bl, $007											; Light gray text on black background
   532                                  
   533                                  .setCursor:
   534 00000367 B402                    	mov 	ah, $02												; Set cursor position
   535 00000369 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   536 0000036B CD10                    	int		$10													; Set cursor
   537                                  
   538                                  .repeat:
   539 0000036D AC                      	lodsb														; Get character from string
   540 0000036E 3C00                    	cmp 	al, 0
   541 00000370 7417                    	je		.done												; If char is zero, end of string
   542                                  	
   543 00000372 3C0A                    	cmp 	al, $0A												; Process newline
   544 00000374 741B                    	je		.newline
   545                                  
   546 00000376 B90100                  	mov		cx, $01												; Write one ASCII character
   547 00000379 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   548 0000037B B409                    	mov 	ah, $09												; Write character
   549 0000037D CD10                    	int		$10													; Print character
   550                                  
   551 0000037F B402                    	mov 	ah, $02												; Set cursor position
   552 00000381 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   553 00000383 FEC2                    	inc		dl													; Increment column
   554 00000385 CD10                    	int		$10													; Set cursor
   555                                  
   556 00000387 EBE4                    	jmp		.repeat
   557                                  
   558                                  .done:
   559 00000389 8916[FA06]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   560 0000038D 5A                      	pop		dx													; Pop position
   561 0000038E 31FF                    	xor		di, di												; Clear colour
   562 00000390 C3                      	ret
   563                                  
   564                                  .newline:
   565 00000391 5A                      	pop		dx													; Get original column
   566 00000392 FEC6                    	inc		dh													; Increment row
   567 00000394 52                      	push	dx													; Push it back to stack
   568 00000395 EBD6                    	jmp		.repeat
   569                                  
   570                                  ;========================================================================================
   571                                  ; Prints the character in al to the screen at the current cursor position, using the
   572                                  ; colour in di.
   573                                  ;========================================================================================
   574                                  putc:
   575 00000397 85FF                    	test	di, di												; Check if DI is set
   576 00000399 7406                    	jz		.useDefaultColour									; If so, branch
   577                                  
   578 0000039B 89F8                    	mov		ax, di												; Set colour
   579 0000039D 88C3                    	mov		bl, al												; Get low byte only
   580 0000039F EB02                    	jmp		SHORT .setCursor
   581                                  
   582                                  .useDefaultColour:
   583 000003A1 B307                    	mov		bl, $007											; Light gray text on black background
   584                                  
   585                                  .setCursor:
   586 000003A3 8B16[FA06]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   587 000003A7 B402                    	mov 	ah, $02												; Set cursor position
   588 000003A9 B700                    	mov		bh, $0												; Video page 0
   589 000003AB CD10                    	int		$10													; Set cursor
   590                                  
   591 000003AD B90100                  	mov		cx, $01												; Write one ASCII character
   592 000003B0 B700                    	mov		bh, $0												; Video page 0
   593 000003B2 B409                    	mov 	ah, $09												; Write character
   594 000003B4 CD10                    	int		$10													; Print character
   595                                  
   596 000003B6 FEC2                    	inc		dl													; Increment column
   597                                  
   598 000003B8 B402                    	mov 	ah, $02												; Set cursor position
   599 000003BA B700                    	mov		bh, $0												; Video page 0
   600 000003BC CD10                    	int		$10													; Set cursor
   601                                  
   602 000003BE 8916[FA06]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   603 000003C2 31FF                    	xor		di, di												; Clear colour
   604 000003C4 C3                      	ret
   605                                  
   606                                  ;========================================================================================
   607                                  ; Prints the value in eax to the screen.
   608                                  ;========================================================================================
   609                                  hex_to_ascii:
   610 000003C5 31C9                    	xor 	cx, cx
   611                                  
   612 000003C7 88E1                    	mov 	cl, ah												; Move high byte of ax to cl
   613 000003C9 E81000                  	call 	.nibble_high										; Print low nibble to ASCII
   614 000003CC 88E1                    	mov 	cl, ah
   615 000003CE E81100                  	call 	.nibble_low
   616 000003D1 88C1                    	mov 	cl, al
   617 000003D3 E80600                  	call 	.nibble_high
   618 000003D6 88C1                    	mov 	cl, al
   619 000003D8 E80700                  	call 	.nibble_low
   620 000003DB C3                      	ret
   621                                  
   622                                  .nibble_high:
   623 000003DC C0E904                  	shr 	cl, $04
   624 000003DF E90600                  	jmp 	.convert_check
   625                                  
   626                                  .nibble_low:
   627 000003E2 80E10F                  	and 	cl, $0F
   628 000003E5 E90000                  	jmp 	.convert_check
   629                                  
   630                                  .convert_check:
   631 000003E8 80F90A                  	cmp 	cl, $0A
   632 000003EB 7D0B                    	jge 	.letter
   633 000003ED 80C130                  	add 	cl, $30
   634 000003F0 50                      	push 	ax
   635 000003F1 88C8                    	mov 	al, cl
   636 000003F3 E8A1FF                  	call 	putc
   637 000003F6 58                      	pop 	ax
   638 000003F7 C3                      	ret
   639                                  
   640                                  .letter:
   641 000003F8 80C137                  	add 	cl, $37
   642 000003FB 50                      	push	ax
   643 000003FC 88C8                    	mov 	al, cl
   644 000003FE E896FF                  	call	putc
   645 00000401 58                      	pop 	ax
   646 00000402 C3                      	ret
   647                                  
   648                                  ;========================================================================================
   649                                  ; Uses BIOS INT $15, EAX $E820 function to get the memory map of the system
   650                                  ; input: 	es:di = destination buffer for 24 byte entries
   651                                  ; output: 	bp = entry count, trashes all registers except esi
   652                                  ;========================================================================================
   653                                  fetch_mem_map:
   654 00000403 6631DB                  	xor		ebx, ebx											; Clear EBX
   655 00000406 31ED                    	xor		bp, bp												; Use BP as an entry count
   656 00000408 66BA50414D53            	mov		edx, $0534D4150										; Place "SMAP" into edx (magic value)
   657 0000040E 66B820E80000            	mov		eax, $0E820											; Function call
   658                                  
   659 00000414 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   660 0000041D 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   661 00000423 CD15                    	int		$15
   662                                  
   663 00000425 7257                    	jc		SHORT .error										; If carry set, the function is unsupported
   664                                  
   665 00000427 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   666 0000042D 6639D0                  	cmp		eax, edx											; On success, EAX = "SMAP"
   667 00000430 754C                    	jne		SHORT .error
   668                                  
   669 00000432 6685DB                  	test	ebx, ebx											; ebx = 0 implies list is only 1 entry long (worthless)
   670 00000435 7447                    	je		SHORT .error
   671                                  
   672 00000437 EB1F                    	jmp		SHORT .startLoop									; Jump into the loop
   673                                  
   674                                  .getEntryLoop:
   675 00000439 66B820E80000            	mov		eax, $0E820											; Reset command (EAX, ECX are trashed)
   676 0000043F 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   677 00000448 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   678 0000044E CD15                    	int		$15
   679                                  
   680 00000450 722A                    	jc		SHORT .done											; If carry set, we are done
   681 00000452 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   682                                  
   683                                  .startLoop:
   684 00000458 E31D                    	jcxz	.skipEntry											; Skip any 0 length entries
   685                                  
   686 0000045A 80F914                  	cmp		cl, 20												; Did we get 24-byte ACPI 3.x data?
   687 0000045D 7607                    	jbe		SHORT .notext
   688                                  
   689 0000045F 26F6451401              	test	BYTE [es:di+20], 1									; If so, is the "ignore this data" bit clear?
   690 00000464 7411                    	je		SHORT .skipEntry
   691                                  
   692                                  .notext:
   693 00000466 26668B4D08              	mov		ecx, [es:di+8]										; get lower dword of memory region length
   694 0000046B 26660B4D0C              	or		ecx, [es:di+12]										; Check if zero (OR with upper dword)
   695 00000470 7405                    	jz		.skipEntry											; If length qword is 0, skip entry
   696                                  
   697 00000472 45                      	inc		bp													; We got a good entry, increment count, go to next entry
   698                                  
   699 00000473 81C71800                	add		di, 24
   700                                  
   701                                  .skipEntry:
   702 00000477 6685DB                  	test	ebx, ebx											; If EBX = 0, then the BIOS has given us all entries
   703 0000047A 75BD                    	jne		SHORT .getEntryLoop
   704                                  
   705                                  .done:
   706 0000047C F8                      	clc															; There is "jc" on end of list to this point, so the carry must be cleared
   707 0000047D C3                      	ret
   708                                  
   709                                  .error:
   710 0000047E F9                      	stc															; Set carry if this BIOS sucks ass and doesn't support this
   711 0000047F C3                      	ret
   712                                  
   713                                  ;========================================================================================
   714                                  ; Writes a register dump to the VGA hardware
   715                                  ;========================================================================================
   716                                  VGA_MISC_WRITE		EQU	$3C2
   717                                  VGA_SEQ_INDEX		EQU	$3C4
   718                                  VGA_SEQ_DATA		EQU	$3C5
   719                                  VGA_CRTC_INDEX		EQU	$3D4
   720                                  VGA_CRTC_DATA		EQU	$3D5
   721                                  VGA_INSTAT_READ		EQU	$3DA
   722                                  
   723                                  NUM_SEQ_REGS		EQU	5
   724                                  NUM_CRTC_REGS		EQU	25
   725                                  
   726                                  write_regs:
   727 00000480 56                      	push 	si
   728 00000481 52                      	push 	dx
   729 00000482 51                      	push 	cx
   730 00000483 50                      	push 	ax
   731 00000484 FC                      	cld
   732                                  
   733                                  ; write MISC register
   734 00000485 BAC203                  	mov 	dx, VGA_MISC_WRITE
   735 00000488 AC                      	lodsb
   736 00000489 EE                      	out 	dx, al
   737                                  
   738                                  ; write SEQuencer registers
   739 0000048A B90500                  	mov 	cx, NUM_SEQ_REGS
   740 0000048D 30E4                    	xor 	ah, ah
   741                                  
   742                                  write_seq:
   743 0000048F BAC403                  	mov 	dx, VGA_SEQ_INDEX
   744 00000492 88E0                    	mov 	al, ah
   745 00000494 EE                      	out 	dx, al
   746                                  
   747 00000495 BAC503                  	mov 	dx, VGA_SEQ_DATA
   748 00000498 AC                      	lodsb
   749 00000499 EE                      	out 	dx, al
   750                                  
   751 0000049A FEC4                    	inc 	ah
   752 0000049C E2F1                    	loop 	write_seq
   753                                  
   754                                  ; write CRTC registers
   755                                  ; Unlock CRTC registers: enable writes to CRTC regs 0-7
   756 0000049E BAD403                  	mov 	dx, VGA_CRTC_INDEX
   757 000004A1 B011                    	mov 	al, 17
   758 000004A3 EE                      	out 	dx, al
   759                                  
   760 000004A4 BAD503                  	mov 	dx, VGA_CRTC_DATA
   761 000004A7 EC                      	in		al, dx
   762 000004A8 247F                    	and 	al, $7F
   763 000004AA EE                      	out 	dx, al
   764                                  
   765                                  ; Unlock CRTC registers: enable access to vertical retrace regs
   766 000004AB BAD403                  	mov 	dx, VGA_CRTC_INDEX
   767 000004AE B003                    	mov 	al, 3
   768 000004B0 EE                      	out 	dx, al
   769                                  
   770 000004B1 BAD503                  	mov 	dx ,VGA_CRTC_DATA
   771 000004B4 EC                      	in		al, dx
   772 000004B5 0C80                    	or		al, $80
   773 000004B7 EE                      	out		dx, al
   774                                  
   775                                  ; make sure CRTC registers remain unlocked
   776 000004B8 8A4411                  	mov		al,[si + 17]
   777 000004BB 247F                    	and 	al, $7F
   778 000004BD 884411                  	mov 	[si + 17],al
   779                                  
   780 000004C0 8A4403                  	mov 	al,[si + 3]
   781 000004C3 0C80                    	or		al, $80
   782 000004C5 884403                  	mov 	[si + 3], al
   783                                  
   784                                  ; now, finally, write them
   785 000004C8 B91900                  	mov 	cx, NUM_CRTC_REGS
   786 000004CB B400                    	mov 	ah, 0
   787                                  
   788                                  write_crtc:
   789 000004CD BAD403                  	mov 	dx, VGA_CRTC_INDEX
   790 000004D0 88E0                    	mov 	al, ah
   791 000004D2 EE                      	out 	dx, al
   792                                  
   793 000004D3 BAD503                  	mov 	dx, VGA_CRTC_DATA
   794 000004D6 AC                      	lodsb
   795 000004D7 EE                      	out 	dx, al
   796                                  
   797 000004D8 FEC4                    	inc 	ah
   798 000004DA E2F1                    	loop write_crtc
   799                                  
   800 000004DC 58                      	pop 	ax
   801 000004DD 59                      	pop 	cx
   802 000004DE 5A                      	pop 	dx
   803 000004DF 5E                      	pop 	si
   804 000004E0 C3                      	ret
   805                                  
   806                                  ;========================================================================================
   807                                  ; DATA SECTION
   808                                  ;========================================================================================
   809                                  regs_90x60:
   810                                  ; MISC
   811 000004E1 E7                      	db	0E7h
   812                                  ; SEQuencer
   813 000004E2 0301030002              	db	03h, 01h, 03h, 00h, 02h
   814                                  ; CRTC
   815 000004E7 6B595A82608D0B3E        	db	6Bh, 59h,  5Ah, 82h, 60h,  8Dh, 0Bh,  3Eh,
   816 000004EF 0047060700000000        	db	00h, 47h,  06h, 07h, 00h,  00h, 00h,  00h,
   817 000004F7 EA0CDF2D08E805A3        	db	0EAh, 0Ch, 0DFh, 2Dh, 08h, 0E8h, 05h, 0A3h,
   818 000004FF FF                      	db 	0FFh
   819                                  ; GC (no)
   820                                  ; AC (no)
   821                                  
   822                                  str_stage2loaded:
   823 00000500 537461676520322042-     	db 	'Stage 2 Bootloader (boot2)', 0
   824 00000509 6F6F746C6F61646572-
   825 00000512 2028626F6F74322900 
   826                                  
   827                                  str_errorDetectMem:
   828 0000051B 4572726F7220646574-     	db 	"Error detecting available memory, cannot continue", 0
   829 00000524 656374696E67206176-
   830 0000052D 61696C61626C65206D-
   831 00000536 656D6F72792C206361-
   832 0000053F 6E6E6F7420636F6E74-
   833 00000548 696E756500         
   834                                  
   835                                  str_floppyError:
   836 0000054D 466C6F707079204572-     	db 	"Floppy Error, press any key to retry", $0A, 0
   837 00000556 726F722C2070726573-
   838 0000055F 7320616E79206B6579-
   839 00000568 20746F207265747279-
   840 00000571 0A00               
   841                                  
   842                                  str_available_lomem:
   843 00000573 436F6E74696E756F75-     	db 	"Continuous 01K blocks below 0x01000000: 0x", 0
   844 0000057C 732030314B20626C6F-
   845 00000585 636B732062656C6F77-
   846 0000058E 203078303130303030-
   847 00000597 30303A20307800     
   848                                  
   849                                  str_available_himem:
   850 0000059E 436F6E74696E756F75-     	db 	"Continuous 64K blocks above 0x01000000: 0x", 0
   851 000005A7 732036344B20626C6F-
   852 000005B0 636B732061626F7665-
   853 000005B9 203078303130303030-
   854 000005C2 30303A20307800     
   855                                  
   856                                  str_select_partition:
   857 000005C9 557365207468652063-     	db 	"Use the cursor to select the partition to boot from.", 0
   858 000005D2 7572736F7220746F20-
   859 000005DB 73656C656374207468-
   860 000005E4 652070617274697469-
   861 000005ED 6F6E20746F20626F6F-
   862 000005F6 742066726F6D2E00   
   863                                  
   864                                  str_err_not_bootable:
   865 000005FE 546869732070617274-     	db 	"This partition is not marked as bootable!", 0
   866 00000607 6974696F6E20697320-
   867 00000610 6E6F74206D61726B65-
   868 00000619 6420617320626F6F74-
   869 00000622 61626C652100       
   870                                  
   871                                  str_err_kern_not_found:
   872 00000628 436F756C64206E6F74-     	db	"Could not find KERNEL.BIN at the root of the drive!", 0
   873 00000631 2066696E64204B4552-
   874 0000063A 4E454C2E42494E2061-
   875 00000643 742074686520726F6F-
   876 0000064C 74206F662074686520-
   877 00000655 64726976652100     
   878                                  
   879                                  str_err_clear_err:
   880 0000065C 20<rept>                	times	0x40 db 0x20
   881 0000069C 00                      	db	0
   882                                  
   883                                  
   884                                  str_kernel_loading:
   885 0000069D 4C6F6164696E67206B-     	db 	"Loading kernel: ", 0
   886 000006A6 65726E656C3A2000   
   887                                  
   888                                  str_kernel_loaded_ok:
   889 000006AE 4B65726E656C206C6F-     	db 	"Kernel loaded. Transferring control now...", 0
   890 000006B7 616465642E20547261-
   891 000006C0 6E7366657272696E67-
   892 000006C9 20636F6E74726F6C20-
   893 000006D2 6E6F772E2E2E00     
   894                                  
   895                                  str_err_loadkernel:
   896 000006D9 436F756C64206E6F74-     	db 	"Could not load kernel: Fuck you", 0
   897 000006E2 206C6F6164206B6572-
   898 000006EB 6E656C3A204675636B-
   899 000006F4 20796F7500         
   900                                  
   901                                  BootDevice:
   902 000006F9 00                      	db	0
   903                                  
   904                                  LastCursorPosition:
   905 000006FA 0000                    	dw	0
   906                                  
   907                                  MemBlocksAbove16M:
   908 000006FC 0000                    	dw	0
   909                                  
   910                                  MemBlocksBelow16M:
   911 000006FE 0000                    	dw	0
   912                                  
   913                                  MemMap_NumEntries:
   914 00000700 0000                    	dw	0
   915                                  
   916                                  HDD_BootablePartitions:
   917 00000702 00000000                	dd	0
   918                                  
   919                                  HDD_BootablePartitionsFATType:
   920 00000706 00000000                	dd	0
   921                                  
   922                                  HDD_Selected:
   923 0000070A 00                      	db	0
   924                                  
   925                                  HDD_PartitionNames:
   926 0000070B 00<rept>                	times	(0xB+1)*4 db 0
   927                                  
   928                                  Temp_StrBuf:
   929 0000073B 00<rept>                	times	0x20 db 0
   930                                  
   931 0000075B 90                      	align 2
   932                                  ExtendedRead_Table:
   933 0000075C 10                      	db	$10
   934 0000075D 00                      	db	0
   935 0000075E 0000                    	dw	0														; Num blocks
   936 00000760 0000                    	dw	0														; Dest
   937 00000762 0000                    	dw	0														; Memory page
   938 00000764 00000000                	dd	0														; Starting LBA
   939 00000768 00000000                	dd	0	
   940                                  
   941                                  kernel_cluster:
   942 0000076C 00000000                	dd	0
   943                                  
   944                                  kernel_filename:
   945 00000770 4B45524E454C202042-     	db	"KERNEL  BIN", 0
   946 00000779 494E00             
   947                                  
   948                                  ;========================================================================================
   949                                  ; Global Descriptor Table
   950                                  ;========================================================================================
   951 0000077C 90<rept>                	align	$10
   952                                  
   953                                  gdt_start:
   954 00000780 0000000000000000        	dd	$00, $00												; Null Descriptor
   955                                  
   956                                  	; Code segment
   957 00000788 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
   958 0000078A 0000                    	dw	$0000													; Base 0:15 = $0000
   959 0000078C 00                      	db	$00														; Base 16:23 = $00
   960 0000078D 9A                      	db	$9A														; Access byte: Present, ring 0, Exec, grow up, R/W
   961 0000078E CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
   962 0000078F 00                      	db	$00														; Base 24:31 = $00
   963                                  
   964                                  	; Data segment
   965 00000790 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
   966 00000792 0000                    	dw	$0000													; Base 0:15 = $0000
   967 00000794 00                      	db	$00														; Base 16:23 = $00
   968 00000795 92                      	db	$92														; Access byte: Present, ring 0, Not exec, grow up, R/W
   969 00000796 CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
   970 00000797 00                      	db	$00														; Base 24:31 = $00	
   971                                  
   972                                  gdt_table:
   973 00000798 1700                    	dw	(gdt_table-gdt_start)-1									; Length
   974 0000079A [80070000]              	dd	gdt_start												; Physical address to GDT	
   975                                  
   976 0000079E 90<rept>                	align 4														; DWORD align
   977                                  	%include	"./fat.asm"
   978                              <1> ;========================================================================================
   979                              <1> ; FAT Filesystem Library v 0.1
   980                              <1> ; By Tristan Seifert
   981                              <1> ;
   982                              <1> ; All sector values returned by functions are "logical," i.e. they are relative to the
   983                              <1> ; first sector of the filesystem.
   984                              <1> ;
   985                              <1> ; In addition, this library does not offer full support for FAT12 due to the uncommonality
   986                              <1> ; of it on media besides floppy disks.
   987                              <1> ;========================================================================================
   988                              <1> ; Equates
   989                              <1> ;========================================================================================
   990                              <1> 
   991                              <1> ;========================================================================================
   992                              <1> ; Initialises the FAT filesystem library
   993                              <1> ;========================================================================================
   994                              <1> FAT_Init:
   995 000007A0 B90001              <1> 	mov		cx, (1024/4)										; Clear 2 sectors worth
   996 000007A3 66BA[300B0000]      <1> 	mov		edx, FAT_ReadBuffer									; Pointer to buffer
   997 000007A9 6631C0              <1> 	xor		eax, eax											; Clear value ($00000000)
   998                              <1> 
   999                              <1> .clearLoop:
  1000 000007AC 66678902            <1> 	mov		DWORD [edx], eax									; Clear a DWORD
  1001 000007B0 6681C204000000      <1> 	add		edx, $04											; Increment pointer
  1002 000007B7 E2F3                <1> 	loop	.clearLoop											; Loop
  1003                              <1> 
  1004                              <1> .done:
  1005 000007B9 C3                  <1> 	ret
  1006                              <1>  
  1007                              <1> ;========================================================================================
  1008                              <1> ; Determines the type of FAT, give that the first logical sector of the partition is
  1009                              <1> ; pointed to by SI, and returns the FAT bit size in AL.
  1010                              <1> ;
  1011                              <1> ; This is how Microsoft recommends we determine FAT type:
  1012                              <1> ;
  1013                              <1> ; RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytesPerSec - 1)) / BPB_BytesPerSec
  1014                              <1> ; DataSectors = Total Sectors - (BPB_ReservedSectors + (BPB_NumFATs * FATSz) + RootDirSectors)
  1015                              <1> ; Count of clusters = DataSectors/BPB_SectorsPerCluster 
  1016                              <1> ;
  1017                              <1> ; FAT12: Total clusters < 4085
  1018                              <1> ; FAT16: Total clusters > 4085 && < 65525
  1019                              <1> ; FAT32: Total clusters > 65525
  1020                              <1> ;========================================================================================
  1021                              <1> FAT_DetermineType:
  1022 000007BA 60                  <1> 	pusha														; Push registers
  1023                              <1> 
  1024 000007BB E8EF00              <1> 	call	FAT_ReadBPB											; 
  1025                              <1> 
  1026                              <1> 	; Calculate RootDirSectors
  1027 000007BE 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1028 000007C1 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1029 000007C4 8B1E[EE0A]          <1> 	mov		bx,	WORD [FAT_BPB_RootEntCnt]						; Read root entries 
  1030 000007C8 66C1E305            <1> 	shl		ebx, 5												; Each root entry is 32 bytes
  1031                              <1> 
  1032 000007CC A1[DC0A]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1033 000007CF 48                  <1> 	dec		ax													; Subtract one
  1034 000007D0 6601D8              <1> 	add		eax, ebx											; Add root entry length to sector length
  1035                              <1> 
  1036 000007D3 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1037 000007D6 8B0E[DC0A]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1038 000007DA F7F1                <1> 	div		cx													; Divide by sector length (result = ax)
  1039 000007DC A3[F80A]            <1> 	mov		WORD [FAT_RootDirSectors], ax						; Store result in memory
  1040                              <1> 
  1041                              <1> 	; Calculate number of data sectors
  1042 000007DF 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1043 000007E2 A0[EC0A]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1044                              <1> 
  1045 000007E5 668B0E[F00A]        <1> 	mov		ecx, DWORD [FAT_BPB_FATSz]							; Read FAT size
  1046 000007EA 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in eax
  1047                              <1> 
  1048 000007ED 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1049 000007F0 8B0E[EA0A]          <1> 	mov		cx, WORD [FAT_BPB_ReservedSectors]					; Read number of reserved sectors
  1050                              <1> 
  1051 000007F4 6601C8              <1> 	add		eax, ecx											; Add count of reserved sectors to FAT size
  1052 000007F7 668B0E[F80A]        <1> 	mov		ecx, DWORD [FAT_RootDirSectors]						; Read RootDirSectors
  1053 000007FC 6601C8              <1> 	add		eax, ecx											; Add root directory sectors
  1054                              <1> 
  1055 000007FF 6691                <1> 	xchg	eax, ecx											; Subtract all of the above from total sectors
  1056                              <1> 
  1057 00000801 66A1[F40A]          <1> 	mov		eax, DWORD [FAT_BPB_TotSec]							; Read total sector count
  1058 00000805 6629C8              <1> 	sub		eax, ecx											; Subtract from total sector count
  1059                              <1> 
  1060 00000808 66A3[FC0A]          <1> 	mov		DWORD [FAT_DataSectors], eax						; Store to memory
  1061                              <1> 
  1062                              <1> 	; Calculate cluster count
  1063 0000080C 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1064 0000080F 8A1E[E80A]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1065 00000813 66A1[FC0A]          <1> 	mov		eax, DWORD [FAT_DataSectors]						; Read number of data sectors
  1066 00000817 66F7F3              <1> 	div		ebx													; Divide by sectors/cluster value 
  1067                              <1> 
  1068 0000081A 66A3[080B]          <1> 	mov		DWORD [FAT_TotalClusters], eax						; Store result in EAX
  1069                              <1> 
  1070                              <1> 	; Now, do some comparisons!
  1071 0000081E 663DF50F0000        <1> 	cmp		eax, 4085											; Is the FS FAT12?
  1072 00000824 7F07                <1> 	jg		.notFAT12											; If not, branch
  1073                              <1> 
  1074 00000826 C606[100B]0C        <1> 	mov		BYTE [FAT_Type], 12									; FAT12
  1075 0000082B EB17                <1> 	jmp		SHORT .done											; Return
  1076                              <1> 
  1077                              <1> .notFAT12:
  1078 0000082D 663DF5FF0000        <1> 	cmp		eax, 65525											; Is the FS FAT16?
  1079 00000833 7F0A                <1> 	jg		.notFAT16											; If not, branch
  1080                              <1> 
  1081 00000835 E84C00              <1> 	call	FAT16_Calculate_RootDirSec							; Calculate location of root directory
  1082                              <1> 
  1083 00000838 C606[100B]10        <1> 	mov		BYTE [FAT_Type], 16									; FAT16
  1084 0000083D EB05                <1> 	jmp		SHORT .done											; Return
  1085                              <1> 
  1086                              <1> .notFAT16:
  1087                              <1> 	; Okay, if we get down here, it HAS to be FAT32 or a corrupt FS
  1088 0000083F C606[100B]20        <1> 	mov		BYTE [FAT_Type], 32									; FAT32
  1089                              <1> 
  1090                              <1> .done:
  1091 00000844 E80500              <1> 	call	FAT_Calculate_Misc									; Calculate miscellaneous stuff
  1092 00000847 61                  <1> 	popa														; Restore registers
  1093                              <1> 
  1094 00000848 A0[100B]            <1> 	mov		al, BYTE [FAT_Type]									; Store FAT type in AL
  1095                              <1> 
  1096 0000084B C3                  <1> 	ret
  1097                              <1> 
  1098                              <1> ;========================================================================================
  1099                              <1> ; Calculates miscellaneous values that the FAT driver uses later
  1100                              <1> ;========================================================================================
  1101                              <1> FAT_Calculate_Misc:
  1102 0000084C 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1103 0000084F 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1104 00000852 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1105                              <1> 
  1106 00000855 8B0E[F80A]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1107 00000859 8B1E[EA0A]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1108                              <1> 
  1109 0000085D 6601CB              <1> 	add		ebx, ecx											; Add to root dir sectors reserved sectors
  1110                              <1> 
  1111 00000860 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1112 00000863 8A0E[EC0A]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1113 00000867 66A1[F00A]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1114 0000086B 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1115                              <1> 
  1116 0000086E 6601D8              <1> 	add		eax, ebx											; Add FAT sectors to root dir and reserved count
  1117                              <1> 
  1118 00000871 66A3[000B]          <1> 	mov		DWORD [FAT_FirstDataSector], eax					; Store first data sector
  1119                              <1> 
  1120 00000875 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1121 00000878 8B0E[F80A]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1122 0000087C 6629C8              <1> 	sub		eax, ecx											; Subtract ecx
  1123 0000087F 66A3[040B]          <1> 	mov		DWORD [FAT_FirstClusterLocation], eax				; Write shaften
  1124 00000883 C3                  <1> 	ret
  1125                              <1> 
  1126                              <1> ;========================================================================================
  1127                              <1> ; Calculates the sector for the root directory for FAT12 and FAT16.
  1128                              <1> ;========================================================================================
  1129                              <1> FAT16_Calculate_RootDirSec:
  1130 00000884 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1131 00000887 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1132 0000088A 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1133                              <1> 
  1134 0000088D 8B1E[EA0A]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1135                              <1> 
  1136 00000891 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1137 00000894 A0[EC0A]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1138                              <1> 
  1139 00000897 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1140 0000089A 8A0E[EC0A]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1141 0000089E 66A1[F00A]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1142 000008A2 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1143                              <1> 
  1144 000008A5 6601D8              <1> 	add		eax, ebx											; Add reserved sector count
  1145                              <1> 
  1146 000008A8 66A3[E40A]          <1> 	mov		DWORD [FAT_BPB_RootClus], eax						; Write location of root cluster
  1147                              <1> 
  1148                              <1> .done:
  1149 000008AC C3                  <1> 	ret
  1150                              <1> 
  1151                              <1> ;========================================================================================
  1152                              <1> ; Reads the BPB from the FAT 1st sector in SI.
  1153                              <1> ;========================================================================================
  1154                              <1> FAT_ReadBPB:
  1155 000008AD 8B440B              <1> 	mov		ax, WORD [si+11]									; Read Bytes/sector
  1156 000008B0 A3[DC0A]            <1> 	mov		WORD [FAT_BPB_BytesPerSec], ax						; ""
  1157                              <1> 
  1158 000008B3 8A440D              <1> 	mov		al, BYTE [si+13]									; Read sectors/cluster
  1159 000008B6 A2[E80A]            <1> 	mov		BYTE [FAT_BPB_SectorsPerCluster], al				; ""
  1160                              <1> 
  1161 000008B9 8B440E              <1> 	mov		ax, WORD [si+14]									; Read reserved sectors
  1162 000008BC A3[EA0A]            <1> 	mov		WORD [FAT_BPB_ReservedSectors], ax					; ""
  1163                              <1> 
  1164 000008BF 8A4410              <1> 	mov		al, BYTE [si+16]									; Read number of FATs
  1165 000008C2 A2[EC0A]            <1> 	mov		BYTE [FAT_BPB_NumFATs], al							; ""
  1166                              <1> 
  1167 000008C5 8B4411              <1> 	mov		ax, WORD [si+17]									; Read num root entries
  1168 000008C8 A3[EE0A]            <1> 	mov		WORD [FAT_BPB_RootEntCnt], ax						; ""
  1169                              <1> 
  1170 000008CB 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1171                              <1> 
  1172 000008CE 668B4420            <1> 	mov		eax, DWORD [si+32]									; Read BPB_TotSec32 first
  1173 000008D2 663D00000000        <1> 	cmp		eax, 0												; Is EAX zero?
  1174 000008D8 7503                <1> 	jne		.writeTotSec										; If not, branch
  1175                              <1> 
  1176 000008DA 8B4413              <1> 	mov		ax, WORD [si+19]									; Read BPB_TotSec16 first
  1177                              <1> 
  1178                              <1> .writeTotSec:
  1179 000008DD 66A3[F40A]          <1> 	mov		DWORD [FAT_BPB_TotSec], eax							; ""
  1180                              <1> 
  1181 000008E1 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1182                              <1> 
  1183 000008E4 8B4416              <1> 	mov		ax, WORD [si+22]									; Read BPB_FATSz16
  1184 000008E7 3D0000              <1> 	cmp		ax, 0												; Is it zero?
  1185 000008EA 7507                <1> 	jne		.writeFATSz											; If not, branch.
  1186                              <1> 
  1187 000008EC 668B4424            <1> 	mov		eax, DWORD [si+36]									; Read BPB_FATSz32
  1188                              <1> 
  1189 000008F0 E80500              <1> 	call	.readFAT32Specifics									; Read FAT32-specific data
  1190                              <1> 
  1191                              <1> .writeFATSz:
  1192 000008F3 66A3[F00A]          <1> 	mov		DWORD [FAT_BPB_FATSz], eax							; Write FAT size
  1193                              <1> 
  1194 000008F7 C3                  <1> 	ret
  1195                              <1> 
  1196                              <1> ; All FAT32-specific stuff is read here
  1197                              <1> .readFAT32Specifics:
  1198 000008F8 8B5C28              <1> 	mov		bx, WORD [si+40]									; Read BPB_ExtFlags
  1199 000008FB 891E[E00A]          <1> 	mov		WORD [FAT_BPB_ExtFlags], bx							; Write BPB_ExtFlags
  1200                              <1> 
  1201 000008FF 8B5C2A              <1> 	mov		bx, WORD [si+42]									; Read BPB_FSVer
  1202 00000902 891E[E20A]          <1> 	mov		WORD [FAT_BPB_FSVer], bx							; Write BPB_FSVer
  1203                              <1> 
  1204 00000906 668B5C2C            <1> 	mov		ebx, DWORD [si+44]									; Read BPB_RootClus
  1205 0000090A 66891E[E40A]        <1> 	mov		DWORD [FAT_BPB_RootClus], ebx						; Write BPB_RootClus
  1206                              <1> 
  1207 0000090F 8B5C30              <1> 	mov		bx, WORD [si+48]									; Read BPB_FSInfo
  1208 00000912 891E[DE0A]          <1> 	mov		WORD [FAT_BPB_FSInfo], bx							; Write BPB_FSInfo
  1209                              <1> 
  1210                              <1> 
  1211 00000916 C3                  <1> 	ret
  1212                              <1> 
  1213                              <1> ;========================================================================================
  1214                              <1> ; Calculates the entry location for cluster N in the FAT.
  1215                              <1> ; eax: Cluster number
  1216                              <1> ; eax: Sector number containing the cluster
  1217                              <1> ; ebx: Offset in sector
  1218                              <1> ;========================================================================================
  1219                              <1> FAT_FindClusterInTable:
  1220 00000917 60                  <1> 	pusha														; Back up regs
  1221                              <1> 
  1222 00000918 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1223 0000091B 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1224                              <1> 
  1225 0000091E 8A1E[100B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1226 00000922 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1227 00000925 7406                <1> 	je		.FAT32												; If so, jump
  1228                              <1> 
  1229 00000927 66D1E0              <1> 	shl		eax, 1												; Multiply cluster by 2
  1230 0000092A E90400              <1> 	jmp		.cont												; Skip over shift below
  1231                              <1> 
  1232                              <1> .FAT32:
  1233 0000092D 66C1E002            <1> 	shl		eax, 2												; Multiply cluster by 4
  1234                              <1> 
  1235                              <1> .cont:
  1236                              <1> 	; eax = Offset into FAT table
  1237                              <1> 
  1238 00000931 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1239 00000934 8B0E[DC0A]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1240 00000938 66F7F1              <1> 	div		ecx													; Divide offset by bytes/sector
  1241                              <1> 	; eax = quotient, edx = remainder
  1242                              <1> 
  1243 0000093B 8B1E[EA0A]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; BX = reserved sector count
  1244 0000093F 6601D8              <1> 	add		eax, ebx											; Add to FAT offset (sectors)
  1245                              <1> 
  1246 00000942 66A3[5709]          <1> 	mov		DWORD [.secNum], eax								; Store sector number
  1247 00000946 8916[5B09]          <1> 	mov		WORD [.secOff], dx									; Store offset into sector
  1248                              <1> 
  1249                              <1> .done:
  1250 0000094A 61                  <1> 	popa														; Restore regs
  1251                              <1> 
  1252 0000094B 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1253 0000094E 66A1[5709]          <1> 	mov		eax, DWORD [.secNum]								; Get sector number
  1254 00000952 8B1E[5B09]          <1> 	mov		bx, WORD [.secOff]									; Get offset into sector
  1255                              <1> 
  1256 00000956 C3                  <1> 	ret
  1257                              <1> 
  1258                              <1> .secNum:
  1259 00000957 00000000            <1> 	dd		0
  1260                              <1> 
  1261                              <1> .secOff:
  1262 0000095B 0000                <1> 	dw		0
  1263                              <1> 
  1264                              <1> ;========================================================================================
  1265                              <1> ; Converts the cluster number in eax into a sector number.
  1266                              <1> ;========================================================================================
  1267                              <1> FAT_ClusterToSector:
  1268 0000095D 6651                <1> 	push	ecx													; Back up EBX
  1269                              <1> 
  1270 0000095F 6648                <1> 	dec		eax													; Subtract 2 from cluster
  1271 00000961 6648                <1> 	dec		eax													; ""
  1272                              <1> 
  1273 00000963 6631C9              <1> 	xor		ecx, ecx											; Clear EBX
  1274 00000966 8A0E[E80A]          <1> 	mov		cl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1275 0000096A 66F7E1              <1> 	mul		ecx													; Multiply by number of sectors per cluster
  1276                              <1> 
  1277 0000096D 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1278 00000970 8B0E[F80A]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Root directory sector
  1279 00000974 6601C8              <1> 	add		eax, ecx											; Add to sector count
  1280                              <1> 
  1281 00000977 668B0E[000B]        <1> 	mov		ecx, DWORD [FAT_FirstDataSector]					; Get first data sector
  1282 0000097C 6601C8              <1> 	add		eax, ecx											; Add data sector offset
  1283                              <1> 
  1284 0000097F 6659                <1> 	pop		ecx													; Restore EBX
  1285                              <1> 
  1286 00000981 C3                  <1> 	ret
  1287                              <1> 
  1288                              <1> ;========================================================================================
  1289                              <1> ; Reads the sector containing the FAT entry for the specified cluster, then returns the
  1290                              <1> ; FAT read from the sector.
  1291                              <1> ; eax: Cluster
  1292                              <1> ; Sets carry flag if error.
  1293                              <1> ;========================================================================================
  1294                              <1> FAT_ReadFAT:
  1295 00000982 E892FF              <1> 	call	FAT_FindClusterInTable								; Locate cluster
  1296 00000985 6653                <1> 	push	ebx													; Push offset into sector to stack
  1297                              <1> 
  1298                              <1> 	; Read sector to memory
  1299 00000987 E82500              <1> 	call	FAT_ReadSector										; Read sector
  1300 0000098A 665B                <1> 	pop		ebx													; Pop offset into sector
  1301 0000098C 721F                <1> 	jc 		SHORT .error										; If error, return
  1302                              <1> 
  1303                              <1> 	; Sector is now read to memory
  1304 0000098E 8A1E[100B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1305 00000992 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1306 00000995 740D                <1> 	je		.FAT32												; If so, jump
  1307                              <1> 
  1308 00000997 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1309 0000099A 678B83[300B0000]    <1> 	mov		ax, WORD [FAT_ReadBuffer+ebx]						; Read FAT16 entry
  1310 000009A1 E90800              <1> 	jmp		.done												; Skip over read below
  1311                              <1> 
  1312                              <1> .FAT32:
  1313 000009A4 66678B83[300B0000]  <1> 	mov		eax, DWORD [FAT_ReadBuffer+ebx]						; Read FAT32 entry
  1314                              <1> 
  1315                              <1> .done:
  1316 000009AC C3                  <1> 	ret
  1317                              <1> 
  1318                              <1> .error:
  1319 000009AD F9                  <1> 	stc															; Set carry
  1320 000009AE C3                  <1> 	ret
  1321                              <1> 
  1322                              <1> ;========================================================================================
  1323                              <1> ; Reads a logical sector from the drive.
  1324                              <1> ; eax: Logical sector
  1325                              <1> ; Clears the carry flag if successful, set otherwise.
  1326                              <1> ;========================================================================================
  1327                              <1> FAT_ReadSector:
  1328 000009AF 660306[0C0B]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1329                              <1> 
  1330 000009B4 668B1E[140B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1331 000009B9 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1332 000009BC 7429                <1> 	je		.done												; If they are the same sector, branch
  1333                              <1> 
  1334 000009BE 66A3[200B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1335 000009C2 C706[1A0B]0100      <1> 	mov		WORD [FAT_ERTable+0x02], 0x01						; Read one sector
  1336 000009C8 C706[1C0B][300B]    <1> 	mov		WORD [FAT_ERTable+0x04], FAT_ReadBuffer				; Temporary sector buffer offset (seg 0)
  1337 000009CE C706[1E0B]0000      <1> 	mov		WORD [FAT_ERTable+0x06], 0x00						; Page 0
  1338                              <1> 
  1339 000009D4 66A3[140B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Store LBA we're loading
  1340                              <1> 
  1341 000009D8 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1342 000009D9 BE[180B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1343 000009DC B442                <1> 	mov 	ah, $42												; Extended Read
  1344 000009DE 8A16[110B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1345 000009E2 CD13                <1> 	int 	$13													; Perform read
  1346 000009E4 61                  <1> 	popa														; Pop registers
  1347 000009E5 7202                <1> 	jc 		SHORT .error										; If error, return
  1348                              <1> 
  1349                              <1> .done:
  1350 000009E7 F8                  <1> 	clc															; Clear carry
  1351 000009E8 C3                  <1> 	ret
  1352                              <1> 
  1353                              <1> .error:
  1354 000009E9 F9                  <1> 	stc															; Set carry
  1355 000009EA C3                  <1> 	ret
  1356                              <1> 
  1357                              <1> ;========================================================================================
  1358                              <1> ; Tries to locate a file with the name pointed to by in esi in the root directory of the
  1359                              <1> ; FAT. If found, returns the first cluster of the file in eax, filesize in ebx, and
  1360                              <1> ; clears carry. If not found, sets carry.
  1361                              <1> ;
  1362                              <1> ; Note that this only searches the short filename.
  1363                              <1> ;========================================================================================
  1364                              <1> FAT_FindFileAtRoot:
  1365 000009EB 60                  <1> 	pusha														; Push regs
  1366 000009EC 66A1[E40A]          <1> 	mov		eax, DWORD [FAT_BPB_RootClus]						; Read root sector location
  1367 000009F0 E86AFF              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1368 000009F3 E8B9FF              <1> 	call	FAT_ReadSector										; Read sector
  1369                              <1> 
  1370 000009F6 66BF[300B0000]      <1> 	mov		edi, FAT_ReadBuffer									; FAT read buffer
  1371 000009FC B91000              <1> 	mov		cx, (512/32)										; Search the first 512/32 entries
  1372                              <1> 
  1373                              <1> .searchLoop:
  1374 000009FF 678A07              <1> 	mov		al, BYTE [edi]										; Read first byte of string
  1375                              <1> 
  1376 00000A02 3CE5                <1> 	cmp		al, $0E5											; Is directory entry free?
  1377 00000A04 7426                <1> 	je		.fileEntryIgnore									; If so, branch
  1378 00000A06 3C00                <1> 	cmp		al, $00												; Is directory entry free and last one?
  1379 00000A08 7428                <1> 	je		.notFound											; If so, exit loop.
  1380                              <1> 
  1381                              <1> 	; Store pointers
  1382 00000A0A 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1383 00000A0D 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1384 00000A10 6689F8              <1> 	mov		eax, edi											; Copy read pointer to EAX
  1385 00000A13 6689F2              <1> 	mov		edx, esi											; Copy filename compare ptr to EDX
  1386                              <1> 
  1387                              <1> 	; Compare filename
  1388 00000A16 51                  <1> 	push	cx													; Push loop counter
  1389 00000A17 B90B00              <1> 	mov		cx, $0B												; Filename is 11 bytes
  1390                              <1> 
  1391                              <1> .comparison:
  1392 00000A1A 678A18              <1> 	mov		bl, BYTE [eax]										; Read soruce ptr
  1393 00000A1D 673A1A              <1> 	cmp		bl, BYTE [edx]										; Compare against target
  1394 00000A20 7509                <1> 	jne		.compareFailed										; If not equal, branch
  1395                              <1> 
  1396 00000A22 6640                <1> 	inc		eax													; Increment read pointer
  1397 00000A24 6642                <1> 	inc		edx													; Increment target pointer
  1398                              <1> 
  1399 00000A26 E2F2                <1> 	loop	.comparison											; Compare 11 bytes
  1400                              <1> 
  1401 00000A28 59                  <1> 	pop		cx													; Pop loop counter from stack
  1402 00000A29 EB0A                <1> 	jmp		SHORT .found										; File was found
  1403                              <1> 
  1404                              <1> .compareFailed:
  1405 00000A2B 59                  <1> 	pop		cx													; Pop loop counter
  1406                              <1> 
  1407                              <1> .fileEntryIgnore:
  1408 00000A2C 81C72000            <1> 	add		di, $20												; Read next entry
  1409 00000A30 E2CD                <1> 	loop	.searchLoop											; Loop through entries
  1410                              <1> 
  1411                              <1> ; Drop down here once loop finishes: file not found.
  1412                              <1> .notFound:
  1413 00000A32 61                  <1> 	popa														; Pop registers
  1414 00000A33 F9                  <1> 	stc															; Set carry
  1415 00000A34 C3                  <1> 	ret
  1416                              <1> 
  1417                              <1> ; We found the file
  1418                              <1> .found:
  1419 00000A35 678B471A            <1> 	mov		ax, WORD [edi+26]									; Read cluster low word
  1420 00000A39 A3[580A]            <1> 	mov		WORD [.clusterOfFile], ax							; ""
  1421 00000A3C 678B4714            <1> 	mov		ax, WORD [edi+20]									; Read cluster high word
  1422 00000A40 A3[5A0A]            <1> 	mov		WORD [.clusterOfFile+2], ax							; ""
  1423                              <1> 
  1424 00000A43 66678B471C          <1> 	mov		eax, DWORD [edi+28]									; Read filesize
  1425 00000A48 66A3[5C0A]          <1> 	mov		DWORD [.sizeOfFile], eax							; ""
  1426                              <1> 
  1427 00000A4C 61                  <1> 	popa														; Pop registers
  1428 00000A4D 66A1[580A]          <1> 	mov		eax, DWORD [.clusterOfFile]							; Read file's cluster
  1429 00000A51 668B1E[5C0A]        <1> 	mov		ebx, DWORD [.sizeOfFile]							; Read file's size
  1430 00000A56 F8                  <1> 	clc															; Clear carry bit
  1431 00000A57 C3                  <1> 	ret
  1432                              <1> 
  1433                              <1> 	align	4
  1434                              <1> .clusterOfFile:
  1435 00000A58 00000000            <1> 	dd		0
  1436                              <1> .sizeOfFile:
  1437 00000A5C 00000000            <1> 	dd		0
  1438                              <1> 
  1439                              <1> ;========================================================================================
  1440                              <1> ; Reads the file whose first cluster is in eax to es:di.
  1441                              <1> ;
  1442                              <1> ; Note that this function returns after reading a maximum of 256 chunks.
  1443                              <1> ;========================================================================================
  1444                              <1> FAT_ReadFile:
  1445 00000A60 60                  <1> 	pusha														; Push all regisers
  1446                              <1> 
  1447 00000A61 E80800              <1> 	call	FAT_ReadCluster										; Read cluster
  1448 00000A64 7203                <1> 	jc 		SHORT .error										; If error, return
  1449                              <1> 
  1450                              <1> ;	xor		cx, cx												; Clear CX
  1451                              <1> ;	mov		gs, cx												; Clear GS
  1452                              <1> ;
  1453                              <1> ;.readLoop:
  1454                              <1> ;	call	FAT_ReadFAT											; Read FAT entry for current cluster
  1455                              <1> ;	and		eax, $0FFFFFFF										; Ignore high nybble
  1456                              <1> ;	cmp		eax, $0FFFFFF8										; End of chain marker?
  1457                              <1> ;	jae		.done												; If so, branch (unsigned compare)
  1458                              <1> ;
  1459                              <1> ;	call	FAT_ReadCluster										; Read cluster
  1460                              <1> ;	jc 		SHORT .error										; If error, return
  1461                              <1> ;
  1462                              <1> ;	mov		cx, gs												; Read GS
  1463                              <1> ;	inc		cx													; Increment GS
  1464                              <1> ;	mov		gs, cx												; Move back to GS
  1465                              <1> ;
  1466                              <1> ;	cmp		cl, $0FF											; Is it max? ($FF)
  1467                              <1> ;	je		.error												; If so, we're done
  1468                              <1> ;
  1469                              <1> ;	jmp		.readLoop											; Loop until all sectors of the file are read
  1470                              <1> 
  1471                              <1> .done:
  1472 00000A66 61                  <1> 	popa														; Pop registers
  1473 00000A67 F8                  <1> 	clc															; Clear carry
  1474 00000A68 C3                  <1> 	ret
  1475                              <1> 
  1476                              <1> .error:
  1477 00000A69 61                  <1> 	popa														; Pop registers
  1478 00000A6A F9                  <1> 	stc															; Set carry
  1479 00000A6B C3                  <1> 	ret
  1480                              <1> 
  1481                              <1> ;========================================================================================
  1482                              <1> ; Reads a logical sector from the drive.
  1483                              <1> ; eax: Logical cluster
  1484                              <1> ; es:di: Memory location (Incremented after read)
  1485                              <1> ; Clears the carry flag if successful, set otherwise.
  1486                              <1> ;========================================================================================
  1487                              <1> FAT_ReadCluster:
  1488 00000A6C 66A3[D80A]          <1> 	mov		DWORD [.origCluster], eax							; Store original cluster
  1489 00000A70 E8EAFE              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1490                              <1> 
  1491 00000A73 660306[0C0B]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1492                              <1> 
  1493 00000A78 668B1E[140B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1494 00000A7D 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1495 00000A80 742E                <1> 	je		.done												; If they are the same sector, branch
  1496 00000A82 66A3[140B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Save sector we're reading
  1497                              <1> 
  1498 00000A86 31DB                <1> 	xor		bx, bx												; Clear BX
  1499 00000A88 8A1E[E80A]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1500 00000A8C C706[1A0B]7F00      <1> 	mov		WORD [FAT_ERTable+0x02], $7F							; Write sectors/cluster 
  1501 00000A92 66A3[200B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1502 00000A96 893E[1C0B]          <1> 	mov		WORD [FAT_ERTable+0x04], di							; Offset in segment
  1503 00000A9A 8C06[1E0B]          <1> 	mov		WORD [FAT_ERTable+0x06], es							; Segment
  1504                              <1> 
  1505 00000A9E 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1506 00000A9F BE[180B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1507 00000AA2 B442                <1> 	mov 	ah, $42												; Extended Read		
  1508 00000AA4 8A16[110B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1509 00000AA8 CD13                <1> 	int 	$13													; Perform read
  1510 00000AAA 61                  <1> 	popa														; Pop registers
  1511 00000AAB 7209                <1> 	jc 		SHORT .error										; If error, return
  1512                              <1> 
  1513 00000AAD E80C00              <1> 	call	.incrementReadPtr									; Increment read pointer
  1514                              <1> 
  1515                              <1> .done:	
  1516 00000AB0 66A1[D80A]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1517 00000AB4 F8                  <1> 	clc															; Clear carry
  1518 00000AB5 C3                  <1> 	ret
  1519                              <1> 
  1520                              <1> .error:
  1521 00000AB6 66A1[D80A]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1522 00000ABA F9                  <1> 	stc															; Set carry
  1523 00000ABB C3                  <1> 	ret
  1524                              <1> 
  1525                              <1> .incrementReadPtr:
  1526 00000ABC 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1527 00000ABF A1[DC0A]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1528 00000AC2 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1529 00000AC5 8A1E[E80A]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read bytes per sector
  1530                              <1> 
  1531 00000AC9 66F7E3              <1> 	mul		ebx													; EAX = value to add to write ptr
  1532 00000ACC 01C7                <1> 	add		di, ax												; Add cluster length to di
  1533 00000ACE 7107                <1> 	jno		.noOverflow											; If overflow bit isn't set, branch
  1534                              <1> 
  1535 00000AD0 8CC0                <1> 	mov		ax, es												; Read segment we're writing to
  1536 00000AD2 050010              <1> 	add		ax, $1000											; Write in next segment
  1537 00000AD5 8EC0                <1> 	mov		es, ax												; Write to segment register
  1538                              <1> 
  1539                              <1> .noOverflow:
  1540 00000AD7 C3                  <1> 	ret
  1541                              <1> 
  1542                              <1> 	align	4
  1543                              <1> .origCluster:
  1544 00000AD8 00000000            <1> 	dd		0
  1545                              <1> 
  1546                              <1> ;========================================================================================
  1547                              <1> ; Data section
  1548                              <1> ;========================================================================================
  1549                              <1> 	align	4
  1550                              <1> FAT_BPB_BytesPerSec: ; file offset 11
  1551 00000ADC 0000                <1> 	dw		0
  1552                              <1> FAT_BPB_FSInfo: ; file offset 48, FAT32 only
  1553 00000ADE 0000                <1> 	dw		0
  1554                              <1> FAT_BPB_ExtFlags: ; file offset 40, FAT32 only
  1555 00000AE0 0000                <1> 	dw		0
  1556                              <1> FAT_BPB_FSVer: ; file offset 42, FAT32 only
  1557 00000AE2 0000                <1> 	dw		0
  1558                              <1> 
  1559                              <1> 	align	4
  1560                              <1> FAT_BPB_RootClus: ; file offset 44, FAT32 only
  1561 00000AE4 00000000            <1> 	dd		0
  1562                              <1> FAT_BPB_SectorsPerCluster: ; file offset 13
  1563 00000AE8 00                  <1> 	db		0
  1564                              <1> 
  1565 00000AE9 90                  <1> 	align	2
  1566                              <1> FAT_BPB_ReservedSectors: ; file offset 14
  1567 00000AEA 0000                <1> 	dw		0
  1568                              <1> FAT_BPB_NumFATs: ; file offset 16
  1569 00000AEC 00                  <1> 	db		0
  1570                              <1> 
  1571 00000AED 90                  <1> 	align	2
  1572                              <1> FAT_BPB_RootEntCnt:	; file offset 17
  1573 00000AEE 0000                <1> 	dw		0
  1574                              <1> 
  1575                              <1> 	align	4
  1576                              <1> FAT_BPB_FATSz: ; file offset 22 if FAT16, 36 if FAT32 and word at 22 is 0
  1577 00000AF0 00000000            <1> 	dd		0
  1578                              <1> 
  1579                              <1> ; Works with FAT32
  1580                              <1> ; For the total sector count, try to read BPB_FATSz16 first (19), then the 32-bit at off 32
  1581                              <1> FAT_BPB_TotSec: ; file offset 32 if 19 = 0
  1582 00000AF4 00000000            <1> 	dd		0
  1583                              <1> 
  1584                              <1> ; Calculated when identifying FS
  1585                              <1> FAT_RootDirSectors:
  1586 00000AF8 0000                <1> 	dw		0
  1587                              <1> 
  1588 00000AFA 90<rept>            <1> 	align	4
  1589                              <1> FAT_DataSectors:
  1590 00000AFC 00000000            <1> 	dd		0
  1591                              <1> FAT_FirstDataSector:
  1592 00000B00 00000000            <1> 	dd		0
  1593                              <1> FAT_FirstClusterLocation:
  1594 00000B04 00000000            <1> 	dd		0
  1595                              <1> FAT_TotalClusters:
  1596 00000B08 00000000            <1> 	dd		0
  1597                              <1> 
  1598                              <1> ; Offset into drive in sectors to the start of the FAT partition
  1599                              <1> FAT_PartitionOffset:
  1600 00000B0C 00000000            <1> 	dd		0
  1601                              <1> FAT_Type:
  1602 00000B10 00                  <1> 	db		0
  1603                              <1> 
  1604                              <1> ; BIOS drive to read from
  1605                              <1> FAT_Drive:
  1606 00000B11 00                  <1> 	db		0
  1607                              <1> 
  1608 00000B12 90<rept>            <1> 	align	4
  1609                              <1> FAT_LastLoadedSector:
  1610 00000B14 00000000            <1> 	dd		0
  1611                              <1> 
  1612                              <1> 	align	4
  1613                              <1> FAT_ERTable:
  1614 00000B18 10                  <1> 	db	$10
  1615 00000B19 00                  <1> 	db	0
  1616 00000B1A 0000                <1> 	dw	0														; Num blocks
  1617 00000B1C 0000                <1> 	dw	0														; Dest
  1618 00000B1E 0000                <1> 	dw	0														; Memory page
  1619 00000B20 00000000            <1> 	dd	0														; Starting LBA
  1620 00000B24 00000000            <1> 	dd	0	
  1621                              <1> 
  1622 00000B28 90<rept>            <1> 	align	$10
  1623                              <1> FAT_ReadBuffer:
  1624                                  
  1625                                  	align 4
  1626                                  
  1627                                  SectorBuf:
  1628 00000B30 00<rept>                	times	512 db 0

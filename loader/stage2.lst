     1                                  	BITS	16
     2                                  	org		$0500
     3                                  
     4                                  ; Kernel will be loaded to segment $0300, or $003000 physical
     5                                  kern_loc:				EQU $0300
     6                                  kern_loc_phys:			EQU kern_loc<<4
     7                                  kern_start:				EQU 6
     8                                  kern_len:				EQU 32									; Length in sectors
     9                                  
    10                                  ; Location to store various BIOS info at
    11                                  Kern_Info_Struct:		EQU $0160								; $001600 phys (len = $400 max)
    12                                  VESA_SupportedModes:	EQU	$01A0								; $001A00 phys (len = $200)
    13                                  BIOS_MemMapSeg:			EQU	$0200								; $002000 phys (len = $800 max)
    14                                  
    15                                  struc KernInfoStruct
    16                                  	.munchieValue	resd	0									; X Munchie value
    17                                  	.supportBits	resw	0									; Support Bitfield
    18                                  	.high16Mem		resw	0									; X 64K blocks above 16M
    19                                  	.low16Mem		resw	0									; X 1K blocks below 16M
    20                                  	.memMap			resd	0									; X Physical pointer to memory map
    21                                  	.numMemMapEnt	resw	0									; X Number of entries in memory map
    22                                  	.vesaSupport	resb	0									; VESA support byte
    23                                  	.bootDrive		resb	0									; X Boot drive
    24                                  	.vesaMap		resd	0									; Physical pointer to VESA mode map
    25                                  endstruc
    26                                  
    27                                  %define KINFO(x)  (Kern_Info_Struct<<4) + KernInfoStruct. %+ x
    28                                  
    29                                  stage2_start:
    30 00000000 B80080                  	mov		ax, $8000											; AX = stack segment value (Stack to go at $80000)
    31 00000003 8ED0                    	mov 	ss, ax
    32 00000005 BC0010                  	mov 	sp, 4096											; Set up SP
    33                                  
    34 00000008 8CC8                    	mov 	ax, cs												; Set data segment to where we're loaded
    35 0000000A 8ED8                    	mov 	ds, ax
    36                                  
    37 0000000C 8816[E106]              	mov		BYTE [BootDevice], dl								; Save boot device number
    38 00000010 8816[010B]              	mov		BYTE [FAT_Drive], dl								; Set FAT read drive
    39                                  
    40                                  	; Set up GS to point to a place in memory that houses the kernel info structure
    41 00000014 B86001                  	mov		ax, Kern_Info_Struct								; Place that houses the struct
    42 00000017 8EE8                    	mov		gs, ax												; Set up register
    43                                  
    44 00000019 31FF                    	xor		di, di												; Clear DI
    45 0000001B 66C70600164B45524E      	mov		[KINFO(munchieValue)], DWORD "KERN"					; Set magic value for kern struct
    46                                  
    47 00000024 A0[E106]                	mov		al, [BootDevice]									; Set boot drive
    48 00000027 A20016                  	mov		[KINFO(bootDrive)], al								; ""
    49                                  
    50                                  	; Set up video
    51 0000002A B400                    	mov		ah, $00												; Change video mode
    52 0000002C B003                    	mov		al, $03												; 80x25 text mode
    53 0000002E CD10                    	int		$10													; Call video BIOS
    54                                  
    55 00000030 BE[E804]                	mov 	si, str_stage2loaded								; Put string position into SI
    56 00000033 31D2                    	xor		dx, dx												; Cursor position
    57 00000035 BF2F00                  	mov		di, $2F												; Set colour
    58 00000038 E80703                  	call 	print_string										; Call string printing routine
    59                                  
    60                                  	; Call VESA BIOS routines to get supported video modes
    61 0000003B B8A001                  	mov		ax, VESA_SupportedModes								; Memory location of supported mode struct
    62 0000003E 8EC0                    	mov		es, ax												; ""
    63 00000040 31FF                    	xor		di, di												; Offset 0 in segment
    64                                  
    65 00000042 2666C70556424532        	mov		[es:di], DWORD "VBE2"								; Tell BIOS we want 512 bytes of data
    66                                  
    67 0000004A B8004F                  	mov		ax, $4F00											; VESA BIOS routines â€” get supported modes
    68 0000004D CD10                    	int		$10													; Perform lookup
    69                                  
    70 0000004F 84E4                    	test	ah, ah												; Is AH not zero (i.e. error)
    71 00000051 7400                    	je		.vesaDone											; If so, VESA is unsupported
    72                                  
    73                                  .vesaDone:
    74                                  	; Call BIOS to get memory information
    75 00000053 31C9                    	xor 	cx, cx
    76 00000055 31D2                    	xor 	dx, dx
    77 00000057 B801E8                  	mov 	ax, $0E801
    78 0000005A CD15                    	int 	$15													; Request upper memory size
    79 0000005C 7257                    	jc 		error_memoryDetect
    80 0000005E 80FC86                  	cmp 	ah, $86												; Unsupported function
    81 00000061 7452                    	je		error_memoryDetect
    82 00000063 80FC80                  	cmp		ah, $80												; Invalid command
    83 00000066 744D                    	je		error_memoryDetect
    84 00000068 E304                    	jcxz 	.useax												; Was the CX result invalid?
    85                                   
    86 0000006A 89C8                    	mov		ax, cx												; Number of continuous 1K blocks (1M-16M)
    87 0000006C 89D3                    	mov		bx, dx												; Number of continuous 64K block above 16M
    88                                  
    89                                  .useax:
    90 0000006E 31FF                    	xor		di, di												; Clear DI
    91 00000070 891E[E406]              	mov		WORD [MemBlocksAbove16M], bx						; Store amount of memory available
    92                                  
    93 00000074 B86001                  	mov		ax, Kern_Info_Struct								; Place that houses the struct
    94 00000077 8EE8                    	mov		gs, ax												; Set up register
    95                                  
    96 00000079 891E0016                	mov		[KINFO(high16Mem)], bx								; ""
    97 0000007D A3[E606]                	mov		WORD [MemBlocksBelow16M], ax						; ""
    98 00000080 A30016                  	mov		[KINFO(low16Mem)], ax								; ""
    99                                  
   100 00000083 E89702                  	call	display_memsize										; Display the memory size
   101                                  
   102                                  	; Fetch memory map
   103 00000086 B80002                  	mov 	ax, BIOS_MemMapSeg									; Write mem map to $01800 in physical space
   104 00000089 8EC0                    	mov 	es, ax
   105 0000008B 31FF                    	xor		di, di												; Start of segment
   106                                  
   107 0000008D E85B03                  	call	fetch_mem_map										; Fetch a memory map
   108 00000090 7223                    	jc 		SHORT error_memoryDetect							; Branch if error
   109                                  
   110 00000092 B86001                  	mov		ax, Kern_Info_Struct								; Place that houses the struct
   111 00000095 8EE8                    	mov		gs, ax												; Set up register
   112                                  
   113 00000097 892E0016                	mov		WORD [KINFO(numMemMapEnt)], bp						; ""
   114 0000009B C70600160020            	mov		WORD [KINFO(memMap)], (BIOS_MemMapSeg<<4)			; Physical location of table
   115                                  
   116                                  	; Initialise FAT library
   117 000000A1 E8EC06                  	call	FAT_Init
   118                                  
   119                                  	; Check which partitions are bootable from MBR partition map
   120 000000A4 E8C501                  	call	find_bootable_partitions
   121 000000A7 C606[F206]00            	mov		BYTE [HDD_Selected], 0								; Clear HDD selection
   122                                  
   123                                  	; Set up the partition chooser UI
   124 000000AC E84200                  	call	render_partition_chooser
   125                                  
   126                                  	; Process keypresses, and loads kernel from FS if ENTER is pressed
   127 000000AF E83601                  	call	chooser_loop
   128 000000B2 E90800                  	jmp		boot
   129                                  
   130                                  ;========================================================================================
   131                                  ; Memory detection error handler
   132                                  ;========================================================================================
   133                                  error_memoryDetect:
   134 000000B5 BE[0305]                	mov 	si, str_errorDetectMem								; Put string position into SI
   135 000000B8 E88102                  	call 	print_error											; Call string printing routine
   136 000000BB EBFE                    	jmp		$
   137                                  
   138                                  ;========================================================================================
   139                                  ; Code to boot the kernel
   140                                  ;========================================================================================
   141                                  boot:
   142                                  	; Hide cursor
   143 000000BD 31D2                    	xor		dx, dx												; Clear dx
   144 000000BF F7D2                    	not		dx													; dx = $FFFF
   145 000000C1 B402                    	mov 	ah, $02												; Set cursor position
   146 000000C3 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   147 000000C5 CD10                    	int		$10													; Set cursor
   148                                  
   149                                  	; Set up GDT
   150 000000C7 FA                      	cli															; Disable ints
   151 000000C8 0F0116[8807]            	lgdt	[gdt_table]											; Set up GDTR
   152                                  
   153 000000CD 8B360000                	mov		si, [KernInfoStruct]								; Load address to kernel info struct in SI
   154                                  
   155                                  	; Jump into protected mode, woot!
   156 000000D1 0F20C0                  	mov		eax, cr0											; Get control reg
   157 000000D4 0C01                    	or		al, 00000001b										; Set PE bit
   158 000000D6 0F22C0                  	mov		cr0, eax											; Write control reg
   159                                  
   160                                  	; Set up selectors
   161 000000D9 B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   162 000000DC 8ED8                    	mov		ds, ax												; Set data selector
   163                                  
   164 000000DE B81000                  	mov		ax, $10												; DATA32_DESCRIPTOR
   165 000000E1 8EC0                    	mov		es, ax												; Update other selectors to point to data segment
   166 000000E3 8EE0                    	mov		fs, ax
   167 000000E5 8EE8                    	mov		gs, ax
   168 000000E7 8ED0                    	mov		ss, ax
   169                                  
   170                                  	; The kernel is loaded to $00003000 phys (segmented address 0300h:0000h)
   171 000000E9 66                      	db		$66													; 32-bit prefix
   172 000000EA EA                      	db		$0EA												; Far jump opcode
   173 000000EB 00300000                	dd		kern_loc_phys										; Physical kernel lcoation
   174 000000EF 0800                    	dw		$08													; Selector for CODE32_DESCRIPTOR
   175                                  
   176                                  ;========================================================================================
   177                                  ; Renders the partition chooser
   178                                  ;========================================================================================
   179                                  render_partition_chooser:
   180 000000F1 BE[B105]                	mov 	si, str_select_partition							; Put string position into SI
   181 000000F4 BA0105                  	mov		dx, $0501											; Cursor position
   182 000000F7 BF0700                  	mov		di, $07												; Set colour
   183 000000FA E84502                  	call 	print_string										; Call string printing routine
   184                                  
   185 000000FD C706[E206]0407          	mov		WORD [LastCursorPosition], 0x0704					; Read last cursor position
   186                                  
   187 00000103 66BA[EA060000]          	mov		edx, HDD_BootablePartitions							; EDX contains bootable partition ptr
   188 00000109 B90400                  	mov		cx, $04												; Loop 4x
   189                                  
   190                                  .disp_loop:
   191 0000010C 678A02                  	mov		al, BYTE [edx]										; Read bootability
   192 0000010F 2480                    	and		al, $80												; Get high bit only
   193 00000111 3C80                    	cmp		al, $80												; Is it $80?
   194 00000113 7505                    	jne		.not_bootable										; If not, it's not a bootable drive
   195                                  
   196 00000115 E81300                  	call	.render_boot										; Render bootable drive label
   197                                  
   198 00000118 EB03                    	jmp		SHORT .next											; Skip over non-bootable code
   199                                  
   200                                  .not_bootable:
   201 0000011A E87700                  	call	.render_noboot										; Render non-bootable drive label
   202                                  
   203                                  .next:
   204 0000011D 6642                    	inc		edx													; Go to next item
   205 0000011F E2EB                    	loop	.disp_loop											; Loop over all 4 partitions
   206                                  
   207 00000121 BA010C                  	mov		dx, $0C01
   208 00000124 BE[4406]                	mov		si, str_err_clear_err								; Clear error
   209 00000127 E81802                  	call	print_string										; Display
   210                                  
   211 0000012A C3                      	ret
   212                                  
   213                                  ;========================================================================================
   214                                  ; Renders an entry for a bootable drive
   215                                  ;========================================================================================
   216                                  .render_boot:
   217 0000012B B004                    	mov		al, $04												; Max drive num to al
   218 0000012D 28C8                    	sub		al, cl												; Subtract loop counter
   219 0000012F A2[9201]                	mov		BYTE [.index], al									; Write index
   220 00000132 0430                    	add		al, $30												; ASCII numbers
   221                                  
   222 00000134 66C706[2307]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   223 0000013C 2C                 
   224 0000013D A2[2707]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   225 00000140 C706[2807]3A20          	mov		WORD [Temp_StrBuf+5], ": "							; Colon, space
   226                                  
   227 00000146 60                      	pusha														; Push registers
   228 00000147 66BA[2A070000]          	mov		edx, Temp_StrBuf+7									; String buffer write place
   229 0000014D 66BB[F3060000]          	mov		ebx, HDD_PartitionNames								; Partition names
   230 00000153 B90C00                  	mov		cx, $0C												; $0C characters
   231                                  
   232                                  .copyNameLoop:
   233 00000156 678A03                  	mov		al, BYTE [ebx]										; Copy a character
   234 00000159 678802                  	mov		BYTE [edx], al										; Write to temp buffer
   235 0000015C 6643                    	inc		ebx													; Increment read pointer
   236 0000015E 6642                    	inc		edx													; Increment write pointer
   237 00000160 E2F4                    	loop	.copyNameLoop
   238                                  
   239 00000162 67C742FF0A00            	mov		WORD [edx-1], 0x000A								; Insert newline
   240                                  
   241 00000168 6631C0                  	xor		eax, eax											; Clear EAX
   242 0000016B 66BA[EE060000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type matrix
   243 00000171 0216[9201]              	add		dl, BYTE [.index]
   244 00000175 678A02                  	mov		al, BYTE [edx]										; Read FAT type to AL
   245                                  
   246 00000178 8A1E[F206]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   247 0000017C 80E303                  	and		bl, $3												; Get low 2 bits only
   248 0000017F 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   249 00000181 7503                    	jne		.no_highlight										; If not, branch.
   250                                  
   251 00000183 BF7000                  	mov		di, $070											; Black text on white background
   252                                  
   253                                  .no_highlight:
   254 00000186 8B16[E206]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   255 0000018A BE[2307]                	mov		si, Temp_StrBuf										; Temporary string buffer
   256 0000018D E8B201                  	call 	print_string										; Call string printing routine
   257 00000190 61                      	popa														; Pop registers
   258                                  
   259 00000191 C3                      	ret
   260                                  
   261                                  .index:
   262 00000192 00                      	db	0
   263                                  
   264                                  ;========================================================================================
   265                                  ; Renders an entry for a non-bootable drive.
   266                                  ;========================================================================================
   267 00000193 90                      	align 4
   268                                  
   269                                  .render_noboot:
   270 00000194 B004                    	mov		al, $04												; Max drive num to al
   271 00000196 28C8                    	sub		al, cl												; Subtract loop counter
   272 00000198 0430                    	add		al, $30												; ASCII numbers
   273                                  
   274 0000019A 66C706[2307]686430-     	mov		DWORD [Temp_StrBuf], "hd0,"							; "hd0," text
   275 000001A2 2C                 
   276 000001A3 A2[2707]                	mov		BYTE [Temp_StrBuf+4], al							; Drive number converted to ascii
   277 000001A6 66C706[2807]3A204E-     	mov		DWORD [Temp_StrBuf+5], ": No"						; "Not Bootable"
   278 000001AE 6F                 
   279 000001AF 66C706[2C07]742042-     	mov		DWORD [Temp_StrBuf+9], "t Bo"
   280 000001B7 6F                 
   281 000001B8 66C706[3007]6F7461-     	mov		DWORD [Temp_StrBuf+13], "otab"
   282 000001C0 62                 
   283 000001C1 C706[3407]6C65          	mov		WORD [Temp_StrBuf+17], "le"
   284 000001C7 C706[3607]0A00          	mov		WORD [Temp_StrBuf+19], 0x000A						; Newline, terminator
   285                                  
   286 000001CD 60                      	pusha														; Push registers
   287                                  
   288 000001CE 8A1E[F206]              	mov		bl, BYTE [HDD_Selected]								; Read index of selected HDD
   289 000001D2 80E303                  	and		bl, $3												; Get low 2 bits only
   290 000001D5 38D9                    	cmp		cl, bl												; Is current drive equal to selection?
   291 000001D7 7503                    	jne		.no_highlight2										; If not, branch.
   292                                  
   293 000001D9 BF7000                  	mov		di, $070											; Black text on white background
   294                                  
   295                                  .no_highlight2:
   296 000001DC 8B16[E206]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   297 000001E0 BE[2307]                	mov		si, Temp_StrBuf										; Temporary string buffer
   298 000001E3 E85C01                  	call 	print_string										; Call string printing routine
   299 000001E6 61                      	popa														; Pop registers
   300                                  
   301 000001E7 C3                      	ret
   302                                  
   303                                  ;========================================================================================
   304                                  ; Handle keypresses for chooser
   305                                  ;========================================================================================
   306                                  chooser_loop:
   307 000001E8 E91500                  	jmp		partition_chooser_enter
   308                                  
   309 000001EB 30E4                    	xor		ah, ah												; Wait for keystroke
   310 000001ED CD16                    	int		$16													; Call into BIOS
   311                                  
   312 000001EF 80FC50                  	cmp		ah, $50												; Down pressed?
   313 000001F2 7459                    	je		partition_chooser_dn
   314                                  
   315 000001F4 80FC48                  	cmp		ah, $48												; Up pressed?
   316 000001F7 7463                    	je		partition_chooser_up
   317                                  
   318 000001F9 80FC1C                  	cmp		ah, $1C												; Enter pressed?
   319 000001FC 7402                    	je		partition_chooser_enter
   320                                  
   321 000001FE EBE8                    	jmp		chooser_loop
   322                                  
   323                                  partition_chooser_enter:
   324 00000200 31DB                    	xor		bx, bx												; Clear BX
   325 00000202 8A1E[F206]              	mov		bl, BYTE [HDD_Selected]								; Get selection
   326                                  
   327 00000206 8A87[EA06]              	mov		al, BYTE [HDD_BootablePartitions+bx]				; Check bootability status
   328 0000020A 2480                    	and		al, $80												; Get high bit only
   329 0000020C 3C80                    	cmp		al, $80
   330 0000020E 7527                    	jne		.noBootErr											; If not bootable, branch
   331                                  
   332 00000210 BE[5807]                	mov		si, kernel_filename									; Filename to find
   333 00000213 E8C507                  	call	FAT_FindFileAtRoot									; Find file
   334 00000216 722A                    	jc		.fileNotFound										; Carry set = KERNEL.BIN not found
   335                                  
   336 00000218 66A3[5407]              	mov		DWORD [kernel_cluster], eax							; Store cluster
   337                                  
   338 0000021C 31C0                    	xor		ax, ax												; Segment 0
   339 0000021E 8EC0                    	mov		es, ax												; Write segment											
   340 00000220 BF0030                  	mov		di, kern_loc_phys									; Offset into segment
   341                                  
   342 00000223 66A1[5407]              	mov		eax, DWORD [kernel_cluster]							; Kernel's cluster location
   343 00000227 E82608                  	call	FAT_ReadFile										; Read file
   344                                  
   345 0000022A BE[9606]                	mov 	si, str_kernel_loaded_ok							; Put string position into SI
   346 0000022D BA010C                  	mov		dx, $0C01											; Cursor position
   347 00000230 BF0200                  	mov		di, $02												; Set colour
   348 00000233 E80C01                  	call 	print_string										; Call string printing routine
   349                                  
   350 00000236 C3                      	ret
   351                                  
   352                                  .noBootErr:
   353 00000237 BA010C                  	mov		dx, $0C01
   354 0000023A BE[E605]                	mov		si, str_err_not_bootable							; Not bootable error
   355 0000023D E8FC00                  	call	print_error											; Display
   356 00000240 EBA6                    	jmp		chooser_loop
   357                                  
   358                                  .fileNotFound:
   359 00000242 BA010C                  	mov		dx, $0C01
   360 00000245 BE[1006]                	mov		si, str_err_kern_not_found							; Not found error
   361 00000248 E8F100                  	call	print_error											; Display
   362 0000024B EB9B                    	jmp		chooser_loop
   363                                  
   364                                  partition_chooser_dn:
   365 0000024D A0[F206]                	mov		al, BYTE [HDD_Selected]								; Read selection
   366 00000250 FEC8                    	dec		al													; Move cursor up
   367 00000252 2403                    	and		al, $03												; Get low 2 bits only
   368 00000254 A2[F206]                	mov		BYTE [HDD_Selected], al								; Restore
   369                                  
   370 00000257 E897FE                  	call	render_partition_chooser							; Update display
   371 0000025A EB8C                    	jmp		chooser_loop
   372                                  
   373                                  partition_chooser_up:
   374 0000025C A0[F206]                	mov		al, BYTE [HDD_Selected]								; Read selection
   375 0000025F FEC0                    	inc		al													; Move cursor down
   376 00000261 2403                    	and		al, $03												; Get low 2 bits only
   377 00000263 A2[F206]                	mov		BYTE [HDD_Selected], al								; Restore
   378                                  
   379 00000266 E888FE                  	call	render_partition_chooser							; Update display
   380 00000269 E97CFF                  	jmp		chooser_loop
   381                                  
   382                                  ;========================================================================================
   383                                  ; Finds all partitions that are bootable.
   384                                  ;========================================================================================
   385                                  find_bootable_partitions:
   386 0000026C B90400                  	mov		cx, $4												; MBR contains 4 partition maps
   387                                  
   388 0000026F B8C007                  	mov		ax, $07C0											; Bootloader at 0x7C00
   389 00000272 8EC0                    	mov		es, ax												; Set ES to the bootloader's place in memory
   390 00000274 BFBE01                  	mov		di, $1BE											; Start of partition map
   391                                  
   392 00000277 8CD8                    	mov		ax, ds												; Fetch data segment
   393 00000279 8EE8                    	mov		gs, ax												; Set GS to data segment
   394                                  
   395 0000027B 66BE[EA060000]          	mov		esi, HDD_BootablePartitions							; ESI contains bootable partition ptr
   396 00000281 66BA[F3060000]          	mov		edx, HDD_PartitionNames								; Partition name ptr
   397                                  
   398                                  .loop:
   399 00000287 268A05                  	mov		al, BYTE [es:di]									; Read bootable flag
   400 0000028A 2480                    	and		al, $80												; Get high bit only
   401 0000028C 3C80                    	cmp		al, $80												; Is it $80?
   402 0000028E 754B                    	jne		.not_bootable										; If not, it's not a bootable drive
   403                                  
   404 00000290 678806                  	mov		BYTE [esi], al										; Write bootability flag
   405                                  
   406 00000293 880E[F206]              	mov		BYTE [HDD_Selected], cl								; Write index
   407                                  
   408                                  	; Try to read the LBA of the partition
   409 00000297 26668B4508              	mov		eax, DWORD [es:di+8]								; Read partition LBA
   410 0000029C 663D00000000            	cmp		eax, $00											; Is it zero?
   411 000002A2 7437                    	je		.no_valid_lba										; If so, fuck off
   412                                  
   413 000002A4 66A3[4C07]              	mov		DWORD [ExtendedRead_Table+0x08], eax				; Write LBA
   414 000002A8 C706[4607]0100          	mov		WORD [ExtendedRead_Table+0x02], 0x01				; Read one sector
   415 000002AE C706[4807][200B]        	mov		WORD [ExtendedRead_Table+0x04], SectorBuf			; Temporary sector buffer offset (seg 0)
   416                                  
   417 000002B4 66A3[FC0A]              	mov		DWORD [FAT_PartitionOffset], eax					; Write offset into FAT
   418                                  
   419 000002B8 60                      	pusha														; Push registers (BIOS may clobber them)
   420 000002B9 BE[4407]                	mov 	si, ExtendedRead_Table								; address of "disk address packet"
   421 000002BC B442                    	mov 	ah, $42												; Extended Read
   422 000002BE 8A16[E106]              	mov		dl, BYTE [BootDevice]								; Device number
   423 000002C2 CD13                    	int 	$13
   424 000002C4 61                      	popa														; Pop registers
   425 000002C5 7214                    	jc 		SHORT .no_valid_lba									; If error, fuck off
   426                                  
   427 000002C7 E82100                  	call	.typeDetermine										; Determine type and label loc
   428                                  
   429 000002CA 51                      	push	cx													; Back up original loop counter
   430                                  
   431 000002CB B90B00                  	mov		cx, $0B												; Copy 0xB bytes
   432                                  .copy_str_loop:
   433 000002CE 678A18                  	mov		bl, BYTE [eax]										; Copy from source
   434 000002D1 67881A                  	mov		BYTE [edx], bl										; Write to target buffer
   435 000002D4 6640                    	inc		eax													; Increment read pointer
   436 000002D6 6642                    	inc		edx													; Increment write pointer
   437 000002D8 E2F4                    	loop	.copy_str_loop										; Copy all bytes.
   438                                  
   439 000002DA 59                      	pop		cx													; Restore original loop counter.
   440                                  
   441                                  .no_valid_lba:
   442                                  
   443                                  .not_bootable:
   444 000002DB 81C71000                	add		di, $10												; Go to next entry in bootsector
   445 000002DF 6646                    	inc		esi													; Write next bootability flag
   446 000002E1 6681C20C000000          	add		edx, $0C											; Each entry of partition names is 0x0C in length
   447 000002E8 E29D                    	loop	.loop												; Loop through all partitions
   448                                  
   449                                  .done:
   450 000002EA C3                      	ret
   451                                  
   452                                  ; Determines FAT type and stores pointer to read volume label in eax
   453                                  .typeDetermine:
   454 000002EB 6656                    	push	esi													; Push old ESI
   455 000002ED BE[200B]                	mov		si, SectorBuf										; Sector buffer
   456 000002F0 E8B704                  	call	FAT_DetermineType									; Determine type of FS
   457 000002F3 665E                    	pop		esi													; Pop ESI
   458                                  
   459 000002F5 6652                    	push	edx													; Back up EDX
   460 000002F7 B304                    	mov		bl, $04												; Max drive num to al
   461 000002F9 28CB                    	sub		bl, cl												; Subtract loop counter
   462                                  
   463 000002FB 66BA[EE060000]          	mov		edx, HDD_BootablePartitionsFATType					; FAT type ptr
   464 00000301 28DA                    	sub		dl, bl												; Subtract index
   465 00000303 678802                  	mov		BYTE [edx], al										; Write FAT size
   466 00000306 665A                    	pop		edx													; Restore EDX
   467                                  
   468 00000308 3C20                    	cmp		al, $20												; Is it a FAT32 volume?
   469 0000030A 7509                    	jne		.fat16_label										; If so, branch
   470                                  
   471 0000030C 66B8[670B0000]          	mov		eax, SectorBuf+$47									; FAT32 has volume label at 0x47
   472                                  
   473 00000312 E90600                  	jmp		.copy												; Copy label
   474                                  
   475                                  	; Extract volume label from sector buffer
   476                                  .fat16_label:
   477 00000315 66B8[4B0B0000]          	mov		eax, SectorBuf+$2B									; FAT16 has volume label at 0x2B
   478                                  
   479                                  .copy:
   480 0000031B C3                      	ret
   481                                  
   482                                  .index:
   483 0000031C 00                      	db		0
   484                                  
   485                                  ;========================================================================================
   486                                  ; Displays the memory size on the screen 
   487                                  ;========================================================================================
   488                                  display_memsize:
   489 0000031D BE[5B05]                	mov 	si, str_available_lomem								; Put string position into SI
   490 00000320 BA0002                  	mov		dx, $0200
   491 00000323 E81C00                  	call 	print_string										; Call string printing routine
   492 00000326 A1[E606]                	mov		ax, WORD [MemBlocksBelow16M]						; Get total of memory blocks to EDX
   493 00000329 E88100                  	call	hex_to_ascii
   494                                  
   495 0000032C BE[8605]                	mov 	si, str_available_himem								; Put string position into SI
   496 0000032F BA0003                  	mov		dx, $0300
   497 00000332 E80D00                  	call 	print_string										; Call string printing routine
   498 00000335 A1[E406]                	mov		ax, WORD [MemBlocksAbove16M]						; Get total of memory blocks to EDX
   499 00000338 E87200                  	call	hex_to_ascii
   500                                  
   501 0000033B C3                      	ret
   502                                  
   503                                  ;========================================================================================
   504                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h with the styling
   505                                  ; required for an error string.
   506                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   507                                  ;========================================================================================
   508                                  print_error:
   509 0000033C BF4F00                  	mov		di, $04F											; White text on red background
   510 0000033F E90000                  	jmp 	print_string										; Call string printing routine
   511                                  
   512                                  ;========================================================================================
   513                                  ; Outputs the string in SI to the VGA adapter in text mode using INT10h.
   514                                  ; Note that the start position of the string on-screen (row, col) is in EDX.
   515                                  ;========================================================================================
   516                                  print_string:
   517 00000342 52                      	push	dx													; Push column
   518                                  
   519 00000343 85FF                    	test	di, di												; Check if DI is set
   520 00000345 7406                    	jz		.useDefaultColour									; If so, branch
   521                                  
   522 00000347 89F8                    	mov		ax, di												; Set colour
   523 00000349 88C3                    	mov		bl, al												; Get low byte only
   524 0000034B EB02                    	jmp		SHORT .setCursor
   525                                  
   526                                  .useDefaultColour:
   527 0000034D B307                    	mov		bl, $007											; Light gray text on black background
   528                                  
   529                                  .setCursor:
   530 0000034F B402                    	mov 	ah, $02												; Set cursor position
   531 00000351 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   532 00000353 CD10                    	int		$10													; Set cursor
   533                                  
   534                                  .repeat:
   535 00000355 AC                      	lodsb														; Get character from string
   536 00000356 3C00                    	cmp 	al, 0
   537 00000358 7417                    	je		.done												; If char is zero, end of string
   538                                  	
   539 0000035A 3C0A                    	cmp 	al, $0A												; Process newline
   540 0000035C 741B                    	je		.newline
   541                                  
   542 0000035E B90100                  	mov		cx, $01												; Write one ASCII character
   543 00000361 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   544 00000363 B409                    	mov 	ah, $09												; Write character
   545 00000365 CD10                    	int		$10													; Print character
   546                                  
   547 00000367 B402                    	mov 	ah, $02												; Set cursor position
   548 00000369 30FF                    	xor		bh, bh												; Video page 0 (BH = 0)
   549 0000036B FEC2                    	inc		dl													; Increment column
   550 0000036D CD10                    	int		$10													; Set cursor
   551                                  
   552 0000036F EBE4                    	jmp		.repeat
   553                                  
   554                                  .done:
   555 00000371 8916[E206]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   556 00000375 5A                      	pop		dx													; Pop position
   557 00000376 31FF                    	xor		di, di												; Clear colour
   558 00000378 C3                      	ret
   559                                  
   560                                  .newline:
   561 00000379 5A                      	pop		dx													; Get original column
   562 0000037A FEC6                    	inc		dh													; Increment row
   563 0000037C 52                      	push	dx													; Push it back to stack
   564 0000037D EBD6                    	jmp		.repeat
   565                                  
   566                                  ;========================================================================================
   567                                  ; Prints the character in al to the screen at the current cursor position, using the
   568                                  ; colour in di.
   569                                  ;========================================================================================
   570                                  putc:
   571 0000037F 85FF                    	test	di, di												; Check if DI is set
   572 00000381 7406                    	jz		.useDefaultColour									; If so, branch
   573                                  
   574 00000383 89F8                    	mov		ax, di												; Set colour
   575 00000385 88C3                    	mov		bl, al												; Get low byte only
   576 00000387 EB02                    	jmp		SHORT .setCursor
   577                                  
   578                                  .useDefaultColour:
   579 00000389 B307                    	mov		bl, $007											; Light gray text on black background
   580                                  
   581                                  .setCursor:
   582 0000038B 8B16[E206]              	mov		dx, WORD [LastCursorPosition]						; Read last cursor position
   583 0000038F B402                    	mov 	ah, $02												; Set cursor position
   584 00000391 B700                    	mov		bh, $0												; Video page 0
   585 00000393 CD10                    	int		$10													; Set cursor
   586                                  
   587 00000395 B90100                  	mov		cx, $01												; Write one ASCII character
   588 00000398 B700                    	mov		bh, $0												; Video page 0
   589 0000039A B409                    	mov 	ah, $09												; Write character
   590 0000039C CD10                    	int		$10													; Print character
   591                                  
   592 0000039E FEC2                    	inc		dl													; Increment column
   593                                  
   594 000003A0 B402                    	mov 	ah, $02												; Set cursor position
   595 000003A2 B700                    	mov		bh, $0												; Video page 0
   596 000003A4 CD10                    	int		$10													; Set cursor
   597                                  
   598 000003A6 8916[E206]              	mov		WORD [LastCursorPosition], dx						; Write last cursor position
   599 000003AA 31FF                    	xor		di, di												; Clear colour
   600 000003AC C3                      	ret
   601                                  
   602                                  ;========================================================================================
   603                                  ; Prints the value in eax to the screen.
   604                                  ;========================================================================================
   605                                  hex_to_ascii:
   606 000003AD 31C9                    	xor 	cx, cx
   607                                  
   608 000003AF 88E1                    	mov 	cl, ah												; Move high byte of ax to cl
   609 000003B1 E81000                  	call 	.nibble_high										; Print low nibble to ASCII
   610 000003B4 88E1                    	mov 	cl, ah
   611 000003B6 E81100                  	call 	.nibble_low
   612 000003B9 88C1                    	mov 	cl, al
   613 000003BB E80600                  	call 	.nibble_high
   614 000003BE 88C1                    	mov 	cl, al
   615 000003C0 E80700                  	call 	.nibble_low
   616 000003C3 C3                      	ret
   617                                  
   618                                  .nibble_high:
   619 000003C4 C0E904                  	shr 	cl, $04
   620 000003C7 E90600                  	jmp 	.convert_check
   621                                  
   622                                  .nibble_low:
   623 000003CA 80E10F                  	and 	cl, $0F
   624 000003CD E90000                  	jmp 	.convert_check
   625                                  
   626                                  .convert_check:
   627 000003D0 80F90A                  	cmp 	cl, $0A
   628 000003D3 7D0B                    	jge 	.letter
   629 000003D5 80C130                  	add 	cl, $30
   630 000003D8 50                      	push 	ax
   631 000003D9 88C8                    	mov 	al, cl
   632 000003DB E8A1FF                  	call 	putc
   633 000003DE 58                      	pop 	ax
   634 000003DF C3                      	ret
   635                                  
   636                                  .letter:
   637 000003E0 80C137                  	add 	cl, $37
   638 000003E3 50                      	push	ax
   639 000003E4 88C8                    	mov 	al, cl
   640 000003E6 E896FF                  	call	putc
   641 000003E9 58                      	pop 	ax
   642 000003EA C3                      	ret
   643                                  
   644                                  ;========================================================================================
   645                                  ; Uses BIOS INT $15, EAX $E820 function to get the memory map of the system
   646                                  ; input: 	es:di = destination buffer for 24 byte entries
   647                                  ; output: 	bp = entry count, trashes all registers except esi
   648                                  ;========================================================================================
   649                                  fetch_mem_map:
   650 000003EB 6631DB                  	xor		ebx, ebx											; Clear EBX
   651 000003EE 31ED                    	xor		bp, bp												; Use BP as an entry count
   652 000003F0 66BA50414D53            	mov		edx, $0534D4150										; Place "SMAP" into edx (magic value)
   653 000003F6 66B820E80000            	mov		eax, $0E820											; Function call
   654                                  
   655 000003FC 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   656 00000405 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   657 0000040B CD15                    	int		$15
   658                                  
   659 0000040D 7257                    	jc		SHORT .error										; If carry set, the function is unsupported
   660                                  
   661 0000040F 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   662 00000415 6639D0                  	cmp		eax, edx											; On success, EAX = "SMAP"
   663 00000418 754C                    	jne		SHORT .error
   664                                  
   665 0000041A 6685DB                  	test	ebx, ebx											; ebx = 0 implies list is only 1 entry long (worthless)
   666 0000041D 7447                    	je		SHORT .error
   667                                  
   668 0000041F EB1F                    	jmp		SHORT .startLoop									; Jump into the loop
   669                                  
   670                                  .getEntryLoop:
   671 00000421 66B820E80000            	mov		eax, $0E820											; Reset command (EAX, ECX are trashed)
   672 00000427 2666C7451401000000      	mov		[es:di+20], dword 1									; Write to the array so we have a valid ACPI 3.x entry
   673 00000430 66B918000000            	mov		ecx, 24												; Ask BIOS for 24 bytes of data
   674 00000436 CD15                    	int		$15
   675                                  
   676 00000438 722A                    	jc		SHORT .done											; If carry set, we are done
   677 0000043A 66BA50414D53            	mov		edx, $0534D4150										; Restore EDX in case trashed by BIOS
   678                                  
   679                                  .startLoop:
   680 00000440 E31D                    	jcxz	.skipEntry											; Skip any 0 length entries
   681                                  
   682 00000442 80F914                  	cmp		cl, 20												; Did we get 24-byte ACPI 3.x data?
   683 00000445 7607                    	jbe		SHORT .notext
   684                                  
   685 00000447 26F6451401              	test	BYTE [es:di+20], 1									; If so, is the "ignore this data" bit clear?
   686 0000044C 7411                    	je		SHORT .skipEntry
   687                                  
   688                                  .notext:
   689 0000044E 26668B4D08              	mov		ecx, [es:di+8]										; get lower dword of memory region length
   690 00000453 26660B4D0C              	or		ecx, [es:di+12]										; Check if zero (OR with upper dword)
   691 00000458 7405                    	jz		.skipEntry											; If length qword is 0, skip entry
   692                                  
   693 0000045A 45                      	inc		bp													; We got a good entry, increment count, go to next entry
   694                                  
   695 0000045B 81C71800                	add		di, 24
   696                                  
   697                                  .skipEntry:
   698 0000045F 6685DB                  	test	ebx, ebx											; If EBX = 0, then the BIOS has given us all entries
   699 00000462 75BD                    	jne		SHORT .getEntryLoop
   700                                  
   701                                  .done:
   702 00000464 F8                      	clc															; There is "jc" on end of list to this point, so the carry must be cleared
   703 00000465 C3                      	ret
   704                                  
   705                                  .error:
   706 00000466 F9                      	stc															; Set carry if this BIOS sucks ass and doesn't support this
   707 00000467 C3                      	ret
   708                                  
   709                                  ;========================================================================================
   710                                  ; Writes a register dump to the VGA hardware
   711                                  ;========================================================================================
   712                                  VGA_MISC_WRITE		EQU	$3C2
   713                                  VGA_SEQ_INDEX		EQU	$3C4
   714                                  VGA_SEQ_DATA		EQU	$3C5
   715                                  VGA_CRTC_INDEX		EQU	$3D4
   716                                  VGA_CRTC_DATA		EQU	$3D5
   717                                  VGA_INSTAT_READ		EQU	$3DA
   718                                  
   719                                  NUM_SEQ_REGS		EQU	5
   720                                  NUM_CRTC_REGS		EQU	25
   721                                  
   722                                  write_regs:
   723 00000468 56                      	push 	si
   724 00000469 52                      	push 	dx
   725 0000046A 51                      	push 	cx
   726 0000046B 50                      	push 	ax
   727 0000046C FC                      	cld
   728                                  
   729                                  ; write MISC register
   730 0000046D BAC203                  	mov 	dx, VGA_MISC_WRITE
   731 00000470 AC                      	lodsb
   732 00000471 EE                      	out 	dx, al
   733                                  
   734                                  ; write SEQuencer registers
   735 00000472 B90500                  	mov 	cx, NUM_SEQ_REGS
   736 00000475 30E4                    	xor 	ah, ah
   737                                  
   738                                  write_seq:
   739 00000477 BAC403                  	mov 	dx, VGA_SEQ_INDEX
   740 0000047A 88E0                    	mov 	al, ah
   741 0000047C EE                      	out 	dx, al
   742                                  
   743 0000047D BAC503                  	mov 	dx, VGA_SEQ_DATA
   744 00000480 AC                      	lodsb
   745 00000481 EE                      	out 	dx, al
   746                                  
   747 00000482 FEC4                    	inc 	ah
   748 00000484 E2F1                    	loop 	write_seq
   749                                  
   750                                  ; write CRTC registers
   751                                  ; Unlock CRTC registers: enable writes to CRTC regs 0-7
   752 00000486 BAD403                  	mov 	dx, VGA_CRTC_INDEX
   753 00000489 B011                    	mov 	al, 17
   754 0000048B EE                      	out 	dx, al
   755                                  
   756 0000048C BAD503                  	mov 	dx, VGA_CRTC_DATA
   757 0000048F EC                      	in		al, dx
   758 00000490 247F                    	and 	al, $7F
   759 00000492 EE                      	out 	dx, al
   760                                  
   761                                  ; Unlock CRTC registers: enable access to vertical retrace regs
   762 00000493 BAD403                  	mov 	dx, VGA_CRTC_INDEX
   763 00000496 B003                    	mov 	al, 3
   764 00000498 EE                      	out 	dx, al
   765                                  
   766 00000499 BAD503                  	mov 	dx ,VGA_CRTC_DATA
   767 0000049C EC                      	in		al, dx
   768 0000049D 0C80                    	or		al, $80
   769 0000049F EE                      	out		dx, al
   770                                  
   771                                  ; make sure CRTC registers remain unlocked
   772 000004A0 8A4411                  	mov		al,[si + 17]
   773 000004A3 247F                    	and 	al, $7F
   774 000004A5 884411                  	mov 	[si + 17],al
   775                                  
   776 000004A8 8A4403                  	mov 	al,[si + 3]
   777 000004AB 0C80                    	or		al, $80
   778 000004AD 884403                  	mov 	[si + 3], al
   779                                  
   780                                  ; now, finally, write them
   781 000004B0 B91900                  	mov 	cx, NUM_CRTC_REGS
   782 000004B3 B400                    	mov 	ah, 0
   783                                  
   784                                  write_crtc:
   785 000004B5 BAD403                  	mov 	dx, VGA_CRTC_INDEX
   786 000004B8 88E0                    	mov 	al, ah
   787 000004BA EE                      	out 	dx, al
   788                                  
   789 000004BB BAD503                  	mov 	dx, VGA_CRTC_DATA
   790 000004BE AC                      	lodsb
   791 000004BF EE                      	out 	dx, al
   792                                  
   793 000004C0 FEC4                    	inc 	ah
   794 000004C2 E2F1                    	loop write_crtc
   795                                  
   796 000004C4 58                      	pop 	ax
   797 000004C5 59                      	pop 	cx
   798 000004C6 5A                      	pop 	dx
   799 000004C7 5E                      	pop 	si
   800 000004C8 C3                      	ret
   801                                  
   802                                  ;========================================================================================
   803                                  ; DATA SECTION
   804                                  ;========================================================================================
   805                                  regs_90x60:
   806                                  ; MISC
   807 000004C9 E7                      	db	0E7h
   808                                  ; SEQuencer
   809 000004CA 0301030002              	db	03h, 01h, 03h, 00h, 02h
   810                                  ; CRTC
   811 000004CF 6B595A82608D0B3E        	db	6Bh, 59h,  5Ah, 82h, 60h,  8Dh, 0Bh,  3Eh,
   812 000004D7 0047060700000000        	db	00h, 47h,  06h, 07h, 00h,  00h, 00h,  00h,
   813 000004DF EA0CDF2D08E805A3        	db	0EAh, 0Ch, 0DFh, 2Dh, 08h, 0E8h, 05h, 0A3h,
   814 000004E7 FF                      	db 	0FFh
   815                                  ; GC (no)
   816                                  ; AC (no)
   817                                  
   818                                  str_stage2loaded:
   819 000004E8 537461676520322042-     	db 	'Stage 2 Bootloader (boot2)', 0
   820 000004F1 6F6F746C6F61646572-
   821 000004FA 2028626F6F74322900 
   822                                  
   823                                  str_errorDetectMem:
   824 00000503 4572726F7220646574-     	db 	"Error detecting available memory, cannot continue", 0
   825 0000050C 656374696E67206176-
   826 00000515 61696C61626C65206D-
   827 0000051E 656D6F72792C206361-
   828 00000527 6E6E6F7420636F6E74-
   829 00000530 696E756500         
   830                                  
   831                                  str_floppyError:
   832 00000535 466C6F707079204572-     	db 	"Floppy Error, press any key to retry", $0A, 0
   833 0000053E 726F722C2070726573-
   834 00000547 7320616E79206B6579-
   835 00000550 20746F207265747279-
   836 00000559 0A00               
   837                                  
   838                                  str_available_lomem:
   839 0000055B 436F6E74696E756F75-     	db 	"Continuous 01K blocks below 0x01000000: 0x", 0
   840 00000564 732030314B20626C6F-
   841 0000056D 636B732062656C6F77-
   842 00000576 203078303130303030-
   843 0000057F 30303A20307800     
   844                                  
   845                                  str_available_himem:
   846 00000586 436F6E74696E756F75-     	db 	"Continuous 64K blocks above 0x01000000: 0x", 0
   847 0000058F 732036344B20626C6F-
   848 00000598 636B732061626F7665-
   849 000005A1 203078303130303030-
   850 000005AA 30303A20307800     
   851                                  
   852                                  str_select_partition:
   853 000005B1 557365207468652063-     	db 	"Use the cursor to select the partition to boot from.", 0
   854 000005BA 7572736F7220746F20-
   855 000005C3 73656C656374207468-
   856 000005CC 652070617274697469-
   857 000005D5 6F6E20746F20626F6F-
   858 000005DE 742066726F6D2E00   
   859                                  
   860                                  str_err_not_bootable:
   861 000005E6 546869732070617274-     	db 	"This partition is not marked as bootable!", 0
   862 000005EF 6974696F6E20697320-
   863 000005F8 6E6F74206D61726B65-
   864 00000601 6420617320626F6F74-
   865 0000060A 61626C652100       
   866                                  
   867                                  str_err_kern_not_found:
   868 00000610 436F756C64206E6F74-     	db	"Could not find KERNEL.BIN at the root of the drive!", 0
   869 00000619 2066696E64204B4552-
   870 00000622 4E454C2E42494E2061-
   871 0000062B 742074686520726F6F-
   872 00000634 74206F662074686520-
   873 0000063D 64726976652100     
   874                                  
   875                                  str_err_clear_err:
   876 00000644 20<rept>                	times	0x40 db 0x20
   877 00000684 00                      	db	0
   878                                  
   879                                  
   880                                  str_kernel_loading:
   881 00000685 4C6F6164696E67206B-     	db 	"Loading kernel: ", 0
   882 0000068E 65726E656C3A2000   
   883                                  
   884                                  str_kernel_loaded_ok:
   885 00000696 4B65726E656C206C6F-     	db 	"Kernel loaded. Transferring control now...", 0
   886 0000069F 616465642E20547261-
   887 000006A8 6E7366657272696E67-
   888 000006B1 20636F6E74726F6C20-
   889 000006BA 6E6F772E2E2E00     
   890                                  
   891                                  str_err_loadkernel:
   892 000006C1 436F756C64206E6F74-     	db 	"Could not load kernel: Fuck you", 0
   893 000006CA 206C6F6164206B6572-
   894 000006D3 6E656C3A204675636B-
   895 000006DC 20796F7500         
   896                                  
   897                                  BootDevice:
   898 000006E1 00                      	db	0
   899                                  
   900                                  LastCursorPosition:
   901 000006E2 0000                    	dw	0
   902                                  
   903                                  MemBlocksAbove16M:
   904 000006E4 0000                    	dw	0
   905                                  
   906                                  MemBlocksBelow16M:
   907 000006E6 0000                    	dw	0
   908                                  
   909                                  MemMap_NumEntries:
   910 000006E8 0000                    	dw	0
   911                                  
   912                                  HDD_BootablePartitions:
   913 000006EA 00000000                	dd	0
   914                                  
   915                                  HDD_BootablePartitionsFATType:
   916 000006EE 00000000                	dd	0
   917                                  
   918                                  HDD_Selected:
   919 000006F2 00                      	db	0
   920                                  
   921                                  HDD_PartitionNames:
   922 000006F3 00<rept>                	times	(0xB+1)*4 db 0
   923                                  
   924                                  Temp_StrBuf:
   925 00000723 00<rept>                	times	0x20 db 0
   926                                  
   927 00000743 90                      	align 2
   928                                  ExtendedRead_Table:
   929 00000744 10                      	db	$10
   930 00000745 00                      	db	0
   931 00000746 0000                    	dw	0														; Num blocks
   932 00000748 0000                    	dw	0														; Dest
   933 0000074A 0000                    	dw	0														; Memory page
   934 0000074C 00000000                	dd	0														; Starting LBA
   935 00000750 00000000                	dd	0	
   936                                  
   937                                  kernel_cluster:
   938 00000754 00000000                	dd	0
   939                                  
   940                                  kernel_filename:
   941 00000758 4B45524E454C202042-     	db	"KERNEL  BIN", 0
   942 00000761 494E00             
   943                                  
   944                                  ;========================================================================================
   945                                  ; Global Descriptor Table
   946                                  ;========================================================================================
   947 00000764 90<rept>                	align	$10
   948                                  
   949                                  gdt_start:
   950 00000770 0000000000000000        	dd	$00, $00												; Null Descriptor
   951                                  
   952                                  	; Code segment
   953 00000778 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
   954 0000077A 0000                    	dw	$0000													; Base 0:15 = $0000
   955 0000077C 00                      	db	$00														; Base 16:23 = $00
   956 0000077D 9A                      	db	$9A														; Access byte: Present, ring 0, Exec, grow up, R/W
   957 0000077E CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
   958 0000077F 00                      	db	$00														; Base 24:31 = $00
   959                                  
   960                                  	; Data segment
   961 00000780 FFFF                    	dw	$0FFFF													; Limit 0:15 = $0FFFF
   962 00000782 0000                    	dw	$0000													; Base 0:15 = $0000
   963 00000784 00                      	db	$00														; Base 16:23 = $00
   964 00000785 92                      	db	$92														; Access byte: Present, ring 0, Not exec, grow up, R/W
   965 00000786 CF                      	db	$0CF													; 4K pages, 32-bit, limit 16:19 = $F
   966 00000787 00                      	db	$00														; Base 24:31 = $00	
   967                                  
   968                                  gdt_table:
   969 00000788 1700                    	dw	(gdt_table-gdt_start)-1									; Length
   970 0000078A [70070000]              	dd	gdt_start												; Physical address to GDT	
   971                                  
   972 0000078E 90<rept>                	align 4														; DWORD align
   973                                  	%include	"./fat.asm"
   974                              <1> ;========================================================================================
   975                              <1> ; FAT Filesystem Library v 0.1
   976                              <1> ; By Tristan Seifert
   977                              <1> ;
   978                              <1> ; All sector values returned by functions are "logical," i.e. they are relative to the
   979                              <1> ; first sector of the filesystem.
   980                              <1> ;
   981                              <1> ; In addition, this library does not offer full support for FAT12 due to the uncommonality
   982                              <1> ; of it on media besides floppy disks.
   983                              <1> ;========================================================================================
   984                              <1> ; Equates
   985                              <1> ;========================================================================================
   986                              <1> 
   987                              <1> ;========================================================================================
   988                              <1> ; Initialises the FAT filesystem library
   989                              <1> ;========================================================================================
   990                              <1> FAT_Init:
   991 00000790 B90001              <1> 	mov		cx, (1024/4)										; Clear 2 sectors worth
   992 00000793 66BA[200B0000]      <1> 	mov		edx, FAT_ReadBuffer									; Pointer to buffer
   993 00000799 6631C0              <1> 	xor		eax, eax											; Clear value ($00000000)
   994                              <1> 
   995                              <1> .clearLoop:
   996 0000079C 66678902            <1> 	mov		DWORD [edx], eax									; Clear a DWORD
   997 000007A0 6681C204000000      <1> 	add		edx, $04											; Increment pointer
   998 000007A7 E2F3                <1> 	loop	.clearLoop											; Loop
   999                              <1> 
  1000                              <1> .done:
  1001 000007A9 C3                  <1> 	ret
  1002                              <1>  
  1003                              <1> ;========================================================================================
  1004                              <1> ; Determines the type of FAT, give that the first logical sector of the partition is
  1005                              <1> ; pointed to by SI, and returns the FAT bit size in AL.
  1006                              <1> ;
  1007                              <1> ; This is how Microsoft recommends we determine FAT type:
  1008                              <1> ;
  1009                              <1> ; RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytesPerSec - 1)) / BPB_BytesPerSec
  1010                              <1> ; DataSectors = Total Sectors - (BPB_ReservedSectors + (BPB_NumFATs * FATSz) + RootDirSectors)
  1011                              <1> ; Count of clusters = DataSectors/BPB_SectorsPerCluster 
  1012                              <1> ;
  1013                              <1> ; FAT12: Total clusters < 4085
  1014                              <1> ; FAT16: Total clusters > 4085 && < 65525
  1015                              <1> ; FAT32: Total clusters > 65525
  1016                              <1> ;========================================================================================
  1017                              <1> FAT_DetermineType:
  1018 000007AA 60                  <1> 	pusha														; Push registers
  1019                              <1> 
  1020 000007AB E8EF00              <1> 	call	FAT_ReadBPB											; 
  1021                              <1> 
  1022                              <1> 	; Calculate RootDirSectors
  1023 000007AE 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1024 000007B1 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1025 000007B4 8B1E[DE0A]          <1> 	mov		bx,	WORD [FAT_BPB_RootEntCnt]						; Read root entries 
  1026 000007B8 66C1E305            <1> 	shl		ebx, 5												; Each root entry is 32 bytes
  1027                              <1> 
  1028 000007BC A1[CC0A]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1029 000007BF 48                  <1> 	dec		ax													; Subtract one
  1030 000007C0 6601D8              <1> 	add		eax, ebx											; Add root entry length to sector length
  1031                              <1> 
  1032 000007C3 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1033 000007C6 8B0E[CC0A]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1034 000007CA F7F1                <1> 	div		cx													; Divide by sector length (result = ax)
  1035 000007CC A3[E80A]            <1> 	mov		WORD [FAT_RootDirSectors], ax						; Store result in memory
  1036                              <1> 
  1037                              <1> 	; Calculate number of data sectors
  1038 000007CF 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1039 000007D2 A0[DC0A]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1040                              <1> 
  1041 000007D5 668B0E[E00A]        <1> 	mov		ecx, DWORD [FAT_BPB_FATSz]							; Read FAT size
  1042 000007DA 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in eax
  1043                              <1> 
  1044 000007DD 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1045 000007E0 8B0E[DA0A]          <1> 	mov		cx, WORD [FAT_BPB_ReservedSectors]					; Read number of reserved sectors
  1046                              <1> 
  1047 000007E4 6601C8              <1> 	add		eax, ecx											; Add count of reserved sectors to FAT size
  1048 000007E7 668B0E[E80A]        <1> 	mov		ecx, DWORD [FAT_RootDirSectors]						; Read RootDirSectors
  1049 000007EC 6601C8              <1> 	add		eax, ecx											; Add root directory sectors
  1050                              <1> 
  1051 000007EF 6691                <1> 	xchg	eax, ecx											; Subtract all of the above from total sectors
  1052                              <1> 
  1053 000007F1 66A1[E40A]          <1> 	mov		eax, DWORD [FAT_BPB_TotSec]							; Read total sector count
  1054 000007F5 6629C8              <1> 	sub		eax, ecx											; Subtract from total sector count
  1055                              <1> 
  1056 000007F8 66A3[EC0A]          <1> 	mov		DWORD [FAT_DataSectors], eax						; Store to memory
  1057                              <1> 
  1058                              <1> 	; Calculate cluster count
  1059 000007FC 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1060 000007FF 8A1E[D80A]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1061 00000803 66A1[EC0A]          <1> 	mov		eax, DWORD [FAT_DataSectors]						; Read number of data sectors
  1062 00000807 66F7F3              <1> 	div		ebx													; Divide by sectors/cluster value 
  1063                              <1> 
  1064 0000080A 66A3[F80A]          <1> 	mov		DWORD [FAT_TotalClusters], eax						; Store result in EAX
  1065                              <1> 
  1066                              <1> 	; Now, do some comparisons!
  1067 0000080E 663DF50F0000        <1> 	cmp		eax, 4085											; Is the FS FAT12?
  1068 00000814 7F07                <1> 	jg		.notFAT12											; If not, branch
  1069                              <1> 
  1070 00000816 C606[000B]0C        <1> 	mov		BYTE [FAT_Type], 12									; FAT12
  1071 0000081B EB17                <1> 	jmp		SHORT .done											; Return
  1072                              <1> 
  1073                              <1> .notFAT12:
  1074 0000081D 663DF5FF0000        <1> 	cmp		eax, 65525											; Is the FS FAT16?
  1075 00000823 7F0A                <1> 	jg		.notFAT16											; If not, branch
  1076                              <1> 
  1077 00000825 E84C00              <1> 	call	FAT16_Calculate_RootDirSec							; Calculate location of root directory
  1078                              <1> 
  1079 00000828 C606[000B]10        <1> 	mov		BYTE [FAT_Type], 16									; FAT16
  1080 0000082D EB05                <1> 	jmp		SHORT .done											; Return
  1081                              <1> 
  1082                              <1> .notFAT16:
  1083                              <1> 	; Okay, if we get down here, it HAS to be FAT32 or a corrupt FS
  1084 0000082F C606[000B]20        <1> 	mov		BYTE [FAT_Type], 32									; FAT32
  1085                              <1> 
  1086                              <1> .done:
  1087 00000834 E80500              <1> 	call	FAT_Calculate_Misc									; Calculate miscellaneous stuff
  1088 00000837 61                  <1> 	popa														; Restore registers
  1089                              <1> 
  1090 00000838 A0[000B]            <1> 	mov		al, BYTE [FAT_Type]									; Store FAT type in AL
  1091                              <1> 
  1092 0000083B C3                  <1> 	ret
  1093                              <1> 
  1094                              <1> ;========================================================================================
  1095                              <1> ; Calculates miscellaneous values that the FAT driver uses later
  1096                              <1> ;========================================================================================
  1097                              <1> FAT_Calculate_Misc:
  1098 0000083C 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1099 0000083F 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1100 00000842 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1101                              <1> 
  1102 00000845 8B0E[E80A]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1103 00000849 8B1E[DA0A]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1104                              <1> 
  1105 0000084D 6601CB              <1> 	add		ebx, ecx											; Add to root dir sectors reserved sectors
  1106                              <1> 
  1107 00000850 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1108 00000853 8A0E[DC0A]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1109 00000857 66A1[E00A]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1110 0000085B 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1111                              <1> 
  1112 0000085E 6601D8              <1> 	add		eax, ebx											; Add FAT sectors to root dir and reserved count
  1113                              <1> 
  1114 00000861 66A3[F00A]          <1> 	mov		DWORD [FAT_FirstDataSector], eax					; Store first data sector
  1115                              <1> 
  1116 00000865 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1117 00000868 8B0E[E80A]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Read number of root directory sectors
  1118 0000086C 6629C8              <1> 	sub		eax, ecx											; Subtract ecx
  1119 0000086F 66A3[F40A]          <1> 	mov		DWORD [FAT_FirstClusterLocation], eax				; Write shaften
  1120 00000873 C3                  <1> 	ret
  1121                              <1> 
  1122                              <1> ;========================================================================================
  1123                              <1> ; Calculates the sector for the root directory for FAT12 and FAT16.
  1124                              <1> ;========================================================================================
  1125                              <1> FAT16_Calculate_RootDirSec:
  1126 00000874 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1127 00000877 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1128 0000087A 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1129                              <1> 
  1130 0000087D 8B1E[DA0A]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; Read reserved sectors to EBX
  1131                              <1> 
  1132 00000881 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1133 00000884 A0[DC0A]            <1> 	mov		al, BYTE [FAT_BPB_NumFATs]							; Read number of FATs 
  1134                              <1> 
  1135 00000887 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1136 0000088A 8A0E[DC0A]          <1> 	mov		cl, BYTE [FAT_BPB_NumFATs]							; Read number of FATs to ECX 
  1137 0000088E 66A1[E00A]          <1> 	mov		eax, DWORD [FAT_BPB_FATSz]							; Read FAT size to EAX
  1138 00000892 66F7E1              <1> 	mul		ecx													; Multiply by number of FATs in ECX
  1139                              <1> 
  1140 00000895 6601D8              <1> 	add		eax, ebx											; Add reserved sector count
  1141                              <1> 
  1142 00000898 66A3[D40A]          <1> 	mov		DWORD [FAT_BPB_RootClus], eax						; Write location of root cluster
  1143                              <1> 
  1144                              <1> .done:
  1145 0000089C C3                  <1> 	ret
  1146                              <1> 
  1147                              <1> ;========================================================================================
  1148                              <1> ; Reads the BPB from the FAT 1st sector in SI.
  1149                              <1> ;========================================================================================
  1150                              <1> FAT_ReadBPB:
  1151 0000089D 8B440B              <1> 	mov		ax, WORD [si+11]									; Read Bytes/sector
  1152 000008A0 A3[CC0A]            <1> 	mov		WORD [FAT_BPB_BytesPerSec], ax						; ""
  1153                              <1> 
  1154 000008A3 8A440D              <1> 	mov		al, BYTE [si+13]									; Read sectors/cluster
  1155 000008A6 A2[D80A]            <1> 	mov		BYTE [FAT_BPB_SectorsPerCluster], al				; ""
  1156                              <1> 
  1157 000008A9 8B440E              <1> 	mov		ax, WORD [si+14]									; Read reserved sectors
  1158 000008AC A3[DA0A]            <1> 	mov		WORD [FAT_BPB_ReservedSectors], ax					; ""
  1159                              <1> 
  1160 000008AF 8A4410              <1> 	mov		al, BYTE [si+16]									; Read number of FATs
  1161 000008B2 A2[DC0A]            <1> 	mov		BYTE [FAT_BPB_NumFATs], al							; ""
  1162                              <1> 
  1163 000008B5 8B4411              <1> 	mov		ax, WORD [si+17]									; Read num root entries
  1164 000008B8 A3[DE0A]            <1> 	mov		WORD [FAT_BPB_RootEntCnt], ax						; ""
  1165                              <1> 
  1166 000008BB 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1167                              <1> 
  1168 000008BE 668B4420            <1> 	mov		eax, DWORD [si+32]									; Read BPB_TotSec32 first
  1169 000008C2 663D00000000        <1> 	cmp		eax, 0												; Is EAX zero?
  1170 000008C8 7503                <1> 	jne		.writeTotSec										; If not, branch
  1171                              <1> 
  1172 000008CA 8B4413              <1> 	mov		ax, WORD [si+19]									; Read BPB_TotSec16 first
  1173                              <1> 
  1174                              <1> .writeTotSec:
  1175 000008CD 66A3[E40A]          <1> 	mov		DWORD [FAT_BPB_TotSec], eax							; ""
  1176                              <1> 
  1177 000008D1 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1178                              <1> 
  1179 000008D4 8B4416              <1> 	mov		ax, WORD [si+22]									; Read BPB_FATSz16
  1180 000008D7 3D0000              <1> 	cmp		ax, 0												; Is it zero?
  1181 000008DA 7507                <1> 	jne		.writeFATSz											; If not, branch.
  1182                              <1> 
  1183 000008DC 668B4424            <1> 	mov		eax, DWORD [si+36]									; Read BPB_FATSz32
  1184                              <1> 
  1185 000008E0 E80500              <1> 	call	.readFAT32Specifics									; Read FAT32-specific data
  1186                              <1> 
  1187                              <1> .writeFATSz:
  1188 000008E3 66A3[E00A]          <1> 	mov		DWORD [FAT_BPB_FATSz], eax							; Write FAT size
  1189                              <1> 
  1190 000008E7 C3                  <1> 	ret
  1191                              <1> 
  1192                              <1> ; All FAT32-specific stuff is read here
  1193                              <1> .readFAT32Specifics:
  1194 000008E8 8B5C28              <1> 	mov		bx, WORD [si+40]									; Read BPB_ExtFlags
  1195 000008EB 891E[D00A]          <1> 	mov		WORD [FAT_BPB_ExtFlags], bx							; Write BPB_ExtFlags
  1196                              <1> 
  1197 000008EF 8B5C2A              <1> 	mov		bx, WORD [si+42]									; Read BPB_FSVer
  1198 000008F2 891E[D20A]          <1> 	mov		WORD [FAT_BPB_FSVer], bx							; Write BPB_FSVer
  1199                              <1> 
  1200 000008F6 668B5C2C            <1> 	mov		ebx, DWORD [si+44]									; Read BPB_RootClus
  1201 000008FA 66891E[D40A]        <1> 	mov		DWORD [FAT_BPB_RootClus], ebx						; Write BPB_RootClus
  1202                              <1> 
  1203 000008FF 8B5C30              <1> 	mov		bx, WORD [si+48]									; Read BPB_FSInfo
  1204 00000902 891E[CE0A]          <1> 	mov		WORD [FAT_BPB_FSInfo], bx							; Write BPB_FSInfo
  1205                              <1> 
  1206                              <1> 
  1207 00000906 C3                  <1> 	ret
  1208                              <1> 
  1209                              <1> ;========================================================================================
  1210                              <1> ; Calculates the entry location for cluster N in the FAT.
  1211                              <1> ; eax: Cluster number
  1212                              <1> ; eax: Sector number containing the cluster
  1213                              <1> ; ebx: Offset in sector
  1214                              <1> ;========================================================================================
  1215                              <1> FAT_FindClusterInTable:
  1216 00000907 60                  <1> 	pusha														; Back up regs
  1217                              <1> 
  1218 00000908 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1219 0000090B 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1220                              <1> 
  1221 0000090E 8A1E[000B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1222 00000912 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1223 00000915 7406                <1> 	je		.FAT32												; If so, jump
  1224                              <1> 
  1225 00000917 66D1E0              <1> 	shl		eax, 1												; Multiply cluster by 2
  1226 0000091A E90400              <1> 	jmp		.cont												; Skip over shift below
  1227                              <1> 
  1228                              <1> .FAT32:
  1229 0000091D 66C1E002            <1> 	shl		eax, 2												; Multiply cluster by 4
  1230                              <1> 
  1231                              <1> .cont:
  1232                              <1> 	; eax = Offset into FAT table
  1233                              <1> 
  1234 00000921 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1235 00000924 8B0E[CC0A]          <1> 	mov		cx, WORD [FAT_BPB_BytesPerSec]						; Read bytes per sector
  1236 00000928 66F7F1              <1> 	div		ecx													; Divide offset by bytes/sector
  1237                              <1> 	; eax = quotient, edx = remainder
  1238                              <1> 
  1239 0000092B 8B1E[DA0A]          <1> 	mov		bx, WORD [FAT_BPB_ReservedSectors]					; BX = reserved sector count
  1240 0000092F 6601D8              <1> 	add		eax, ebx											; Add to FAT offset (sectors)
  1241                              <1> 
  1242 00000932 66A3[4709]          <1> 	mov		DWORD [.secNum], eax								; Store sector number
  1243 00000936 8916[4B09]          <1> 	mov		WORD [.secOff], dx									; Store offset into sector
  1244                              <1> 
  1245                              <1> .done:
  1246 0000093A 61                  <1> 	popa														; Restore regs
  1247                              <1> 
  1248 0000093B 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1249 0000093E 66A1[4709]          <1> 	mov		eax, DWORD [.secNum]								; Get sector number
  1250 00000942 8B1E[4B09]          <1> 	mov		bx, WORD [.secOff]									; Get offset into sector
  1251                              <1> 
  1252 00000946 C3                  <1> 	ret
  1253                              <1> 
  1254                              <1> .secNum:
  1255 00000947 00000000            <1> 	dd		0
  1256                              <1> 
  1257                              <1> .secOff:
  1258 0000094B 0000                <1> 	dw		0
  1259                              <1> 
  1260                              <1> ;========================================================================================
  1261                              <1> ; Converts the cluster number in eax into a sector number.
  1262                              <1> ;========================================================================================
  1263                              <1> FAT_ClusterToSector:
  1264 0000094D 6651                <1> 	push	ecx													; Back up EBX
  1265                              <1> 
  1266 0000094F 6648                <1> 	dec		eax													; Subtract 2 from cluster
  1267 00000951 6648                <1> 	dec		eax													; ""
  1268                              <1> 
  1269 00000953 6631C9              <1> 	xor		ecx, ecx											; Clear EBX
  1270 00000956 8A0E[D80A]          <1> 	mov		cl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1271 0000095A 66F7E1              <1> 	mul		ecx													; Multiply by number of sectors per cluster
  1272                              <1> 
  1273 0000095D 6631C9              <1> 	xor		ecx, ecx											; Clear ECX
  1274 00000960 8B0E[E80A]          <1> 	mov		cx, WORD [FAT_RootDirSectors]						; Root directory sector
  1275 00000964 6601C8              <1> 	add		eax, ecx											; Add to sector count
  1276                              <1> 
  1277 00000967 668B0E[F00A]        <1> 	mov		ecx, DWORD [FAT_FirstDataSector]					; Get first data sector
  1278 0000096C 6601C8              <1> 	add		eax, ecx											; Add data sector offset
  1279                              <1> 
  1280 0000096F 6659                <1> 	pop		ecx													; Restore EBX
  1281                              <1> 
  1282 00000971 C3                  <1> 	ret
  1283                              <1> 
  1284                              <1> ;========================================================================================
  1285                              <1> ; Reads the sector containing the FAT entry for the specified cluster, then returns the
  1286                              <1> ; FAT read from the sector.
  1287                              <1> ; eax: Cluster
  1288                              <1> ; Sets carry flag if error.
  1289                              <1> ;========================================================================================
  1290                              <1> FAT_ReadFAT:
  1291 00000972 E892FF              <1> 	call	FAT_FindClusterInTable								; Locate cluster
  1292 00000975 6653                <1> 	push	ebx													; Push offset into sector to stack
  1293                              <1> 
  1294                              <1> 	; Read sector to memory
  1295 00000977 E82500              <1> 	call	FAT_ReadSector										; Read sector
  1296 0000097A 665B                <1> 	pop		ebx													; Pop offset into sector
  1297 0000097C 721F                <1> 	jc 		SHORT .error										; If error, return
  1298                              <1> 
  1299                              <1> 	; Sector is now read to memory
  1300 0000097E 8A1E[000B]          <1> 	mov		bl, BYTE [FAT_Type]									; Read FAT type
  1301 00000982 80FB20              <1> 	cmp		bl, $20												; Is FAT32?
  1302 00000985 740D                <1> 	je		.FAT32												; If so, jump
  1303                              <1> 
  1304 00000987 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1305 0000098A 678B83[200B0000]    <1> 	mov		ax, WORD [FAT_ReadBuffer+ebx]						; Read FAT16 entry
  1306 00000991 E90800              <1> 	jmp		.done												; Skip over read below
  1307                              <1> 
  1308                              <1> .FAT32:
  1309 00000994 66678B83[200B0000]  <1> 	mov		eax, DWORD [FAT_ReadBuffer+ebx]						; Read FAT32 entry
  1310                              <1> 
  1311                              <1> .done:
  1312 0000099C C3                  <1> 	ret
  1313                              <1> 
  1314                              <1> .error:
  1315 0000099D F9                  <1> 	stc															; Set carry
  1316 0000099E C3                  <1> 	ret
  1317                              <1> 
  1318                              <1> ;========================================================================================
  1319                              <1> ; Reads a logical sector from the drive.
  1320                              <1> ; eax: Logical sector
  1321                              <1> ; Clears the carry flag if successful, set otherwise.
  1322                              <1> ;========================================================================================
  1323                              <1> FAT_ReadSector:
  1324 0000099F 660306[FC0A]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1325                              <1> 
  1326 000009A4 668B1E[040B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1327 000009A9 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1328 000009AC 7429                <1> 	je		.done												; If they are the same sector, branch
  1329                              <1> 
  1330 000009AE 66A3[100B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1331 000009B2 C706[0A0B]0100      <1> 	mov		WORD [FAT_ERTable+0x02], 0x01						; Read one sector
  1332 000009B8 C706[0C0B][200B]    <1> 	mov		WORD [FAT_ERTable+0x04], FAT_ReadBuffer				; Temporary sector buffer offset (seg 0)
  1333 000009BE C706[0E0B]0000      <1> 	mov		WORD [FAT_ERTable+0x06], 0x00						; Page 0
  1334                              <1> 
  1335 000009C4 66A3[040B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Store LBA we're loading
  1336                              <1> 
  1337 000009C8 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1338 000009C9 BE[080B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1339 000009CC B442                <1> 	mov 	ah, $42												; Extended Read
  1340 000009CE 8A16[010B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1341 000009D2 CD13                <1> 	int 	$13													; Perform read
  1342 000009D4 61                  <1> 	popa														; Pop registers
  1343 000009D5 7202                <1> 	jc 		SHORT .error										; If error, return
  1344                              <1> 
  1345                              <1> .done:
  1346 000009D7 F8                  <1> 	clc															; Clear carry
  1347 000009D8 C3                  <1> 	ret
  1348                              <1> 
  1349                              <1> .error:
  1350 000009D9 F9                  <1> 	stc															; Set carry
  1351 000009DA C3                  <1> 	ret
  1352                              <1> 
  1353                              <1> ;========================================================================================
  1354                              <1> ; Tries to locate a file with the name pointed to by in esi in the root directory of the
  1355                              <1> ; FAT. If found, returns the first cluster of the file in eax, filesize in ebx, and
  1356                              <1> ; clears carry. If not found, sets carry.
  1357                              <1> ;
  1358                              <1> ; Note that this only searches the short filename.
  1359                              <1> ;========================================================================================
  1360                              <1> FAT_FindFileAtRoot:
  1361 000009DB 60                  <1> 	pusha														; Push regs
  1362 000009DC 66A1[D40A]          <1> 	mov		eax, DWORD [FAT_BPB_RootClus]						; Read root sector location
  1363 000009E0 E86AFF              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1364 000009E3 E8B9FF              <1> 	call	FAT_ReadSector										; Read sector
  1365                              <1> 
  1366 000009E6 66BF[200B0000]      <1> 	mov		edi, FAT_ReadBuffer									; FAT read buffer
  1367 000009EC B91000              <1> 	mov		cx, (512/32)										; Search the first 512/32 entries
  1368                              <1> 
  1369                              <1> .searchLoop:
  1370 000009EF 678A07              <1> 	mov		al, BYTE [edi]										; Read first byte of string
  1371                              <1> 
  1372 000009F2 3CE5                <1> 	cmp		al, $0E5											; Is directory entry free?
  1373 000009F4 7426                <1> 	je		.fileEntryIgnore									; If so, branch
  1374 000009F6 3C00                <1> 	cmp		al, $00												; Is directory entry free and last one?
  1375 000009F8 7428                <1> 	je		.notFound											; If so, exit loop.
  1376                              <1> 
  1377                              <1> 	; Store pointers
  1378 000009FA 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1379 000009FD 6631D2              <1> 	xor		edx, edx											; Clear EDX
  1380 00000A00 6689F8              <1> 	mov		eax, edi											; Copy read pointer to EAX
  1381 00000A03 6689F2              <1> 	mov		edx, esi											; Copy filename compare ptr to EDX
  1382                              <1> 
  1383                              <1> 	; Compare filename
  1384 00000A06 51                  <1> 	push	cx													; Push loop counter
  1385 00000A07 B90B00              <1> 	mov		cx, $0B												; Filename is 11 bytes
  1386                              <1> 
  1387                              <1> .comparison:
  1388 00000A0A 678A18              <1> 	mov		bl, BYTE [eax]										; Read soruce ptr
  1389 00000A0D 673A1A              <1> 	cmp		bl, BYTE [edx]										; Compare against target
  1390 00000A10 7509                <1> 	jne		.compareFailed										; If not equal, branch
  1391                              <1> 
  1392 00000A12 6640                <1> 	inc		eax													; Increment read pointer
  1393 00000A14 6642                <1> 	inc		edx													; Increment target pointer
  1394                              <1> 
  1395 00000A16 E2F2                <1> 	loop	.comparison											; Compare 11 bytes
  1396                              <1> 
  1397 00000A18 59                  <1> 	pop		cx													; Pop loop counter from stack
  1398 00000A19 EB0A                <1> 	jmp		SHORT .found										; File was found
  1399                              <1> 
  1400                              <1> .compareFailed:
  1401 00000A1B 59                  <1> 	pop		cx													; Pop loop counter
  1402                              <1> 
  1403                              <1> .fileEntryIgnore:
  1404 00000A1C 81C72000            <1> 	add		di, $20												; Read next entry
  1405 00000A20 E2CD                <1> 	loop	.searchLoop											; Loop through entries
  1406                              <1> 
  1407                              <1> ; Drop down here once loop finishes: file not found.
  1408                              <1> .notFound:
  1409 00000A22 61                  <1> 	popa														; Pop registers
  1410 00000A23 F9                  <1> 	stc															; Set carry
  1411 00000A24 C3                  <1> 	ret
  1412                              <1> 
  1413                              <1> ; We found the file
  1414                              <1> .found:
  1415 00000A25 678B471A            <1> 	mov		ax, WORD [edi+26]									; Read cluster low word
  1416 00000A29 A3[480A]            <1> 	mov		WORD [.clusterOfFile], ax							; ""
  1417 00000A2C 678B4714            <1> 	mov		ax, WORD [edi+20]									; Read cluster high word
  1418 00000A30 A3[4A0A]            <1> 	mov		WORD [.clusterOfFile+2], ax							; ""
  1419                              <1> 
  1420 00000A33 66678B471C          <1> 	mov		eax, DWORD [edi+28]									; Read filesize
  1421 00000A38 66A3[4C0A]          <1> 	mov		DWORD [.sizeOfFile], eax							; ""
  1422                              <1> 
  1423 00000A3C 61                  <1> 	popa														; Pop registers
  1424 00000A3D 66A1[480A]          <1> 	mov		eax, DWORD [.clusterOfFile]							; Read file's cluster
  1425 00000A41 668B1E[4C0A]        <1> 	mov		ebx, DWORD [.sizeOfFile]							; Read file's size
  1426 00000A46 F8                  <1> 	clc															; Clear carry bit
  1427 00000A47 C3                  <1> 	ret
  1428                              <1> 
  1429                              <1> 	align	4
  1430                              <1> .clusterOfFile:
  1431 00000A48 00000000            <1> 	dd		0
  1432                              <1> .sizeOfFile:
  1433 00000A4C 00000000            <1> 	dd		0
  1434                              <1> 
  1435                              <1> ;========================================================================================
  1436                              <1> ; Reads the file whose first cluster is in eax to es:di.
  1437                              <1> ;
  1438                              <1> ; Note that this function returns after reading a maximum of 256 chunks.
  1439                              <1> ;========================================================================================
  1440                              <1> FAT_ReadFile:
  1441 00000A50 60                  <1> 	pusha														; Push all regisers
  1442                              <1> 
  1443 00000A51 E80800              <1> 	call	FAT_ReadCluster										; Read cluster
  1444 00000A54 7203                <1> 	jc 		SHORT .error										; If error, return
  1445                              <1> 
  1446                              <1> ;	xor		cx, cx												; Clear CX
  1447                              <1> ;	mov		gs, cx												; Clear GS
  1448                              <1> ;
  1449                              <1> ;.readLoop:
  1450                              <1> ;	call	FAT_ReadFAT											; Read FAT entry for current cluster
  1451                              <1> ;	and		eax, $0FFFFFFF										; Ignore high nybble
  1452                              <1> ;	cmp		eax, $0FFFFFF8										; End of chain marker?
  1453                              <1> ;	jae		.done												; If so, branch (unsigned compare)
  1454                              <1> ;
  1455                              <1> ;	call	FAT_ReadCluster										; Read cluster
  1456                              <1> ;	jc 		SHORT .error										; If error, return
  1457                              <1> ;
  1458                              <1> ;	mov		cx, gs												; Read GS
  1459                              <1> ;	inc		cx													; Increment GS
  1460                              <1> ;	mov		gs, cx												; Move back to GS
  1461                              <1> ;
  1462                              <1> ;	cmp		cl, $0FF											; Is it max? ($FF)
  1463                              <1> ;	je		.error												; If so, we're done
  1464                              <1> ;
  1465                              <1> ;	jmp		.readLoop											; Loop until all sectors of the file are read
  1466                              <1> 
  1467                              <1> .done:
  1468 00000A56 61                  <1> 	popa														; Pop registers
  1469 00000A57 F8                  <1> 	clc															; Clear carry
  1470 00000A58 C3                  <1> 	ret
  1471                              <1> 
  1472                              <1> .error:
  1473 00000A59 61                  <1> 	popa														; Pop registers
  1474 00000A5A F9                  <1> 	stc															; Set carry
  1475 00000A5B C3                  <1> 	ret
  1476                              <1> 
  1477                              <1> ;========================================================================================
  1478                              <1> ; Reads a logical sector from the drive.
  1479                              <1> ; eax: Logical cluster
  1480                              <1> ; es:di: Memory location (Incremented after read)
  1481                              <1> ; Clears the carry flag if successful, set otherwise.
  1482                              <1> ;========================================================================================
  1483                              <1> FAT_ReadCluster:
  1484 00000A5C 66A3[C80A]          <1> 	mov		DWORD [.origCluster], eax							; Store original cluster
  1485 00000A60 E8EAFE              <1> 	call	FAT_ClusterToSector									; Convert cluster->sector
  1486                              <1> 
  1487 00000A63 660306[FC0A]        <1> 	add		eax, DWORD [FAT_PartitionOffset]					; Add partition offset
  1488                              <1> 
  1489 00000A68 668B1E[040B]        <1> 	mov		ebx, DWORD [FAT_LastLoadedSector]					; Read last sector we read from HDD
  1490 00000A6D 6639D8              <1> 	cmp		eax, ebx											; Are we getting a request to read same sector?
  1491 00000A70 742E                <1> 	je		.done												; If they are the same sector, branch
  1492 00000A72 66A3[040B]          <1> 	mov		DWORD [FAT_LastLoadedSector], eax					; Save sector we're reading
  1493                              <1> 
  1494 00000A76 31DB                <1> 	xor		bx, bx												; Clear BX
  1495 00000A78 8A1E[D80A]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read sectors/cluster
  1496 00000A7C C706[0A0B]7F00      <1> 	mov		WORD [FAT_ERTable+0x02], $7F							; Write sectors/cluster 
  1497 00000A82 66A3[100B]          <1> 	mov		DWORD [FAT_ERTable+0x08], eax						; Write LBA
  1498 00000A86 893E[0C0B]          <1> 	mov		WORD [FAT_ERTable+0x04], di							; Offset in segment
  1499 00000A8A 8C06[0E0B]          <1> 	mov		WORD [FAT_ERTable+0x06], es							; Segment
  1500                              <1> 
  1501 00000A8E 60                  <1> 	pusha														; Push registers (BIOS may clobber them)
  1502 00000A8F BE[080B]            <1> 	mov 	si, FAT_ERTable										; Address of "disk address packet"
  1503 00000A92 B442                <1> 	mov 	ah, $42												; Extended Read		
  1504 00000A94 8A16[010B]          <1> 	mov		dl, BYTE [FAT_Drive]								; Device number
  1505 00000A98 CD13                <1> 	int 	$13													; Perform read
  1506 00000A9A 61                  <1> 	popa														; Pop registers
  1507 00000A9B 7209                <1> 	jc 		SHORT .error										; If error, return
  1508                              <1> 
  1509 00000A9D E80C00              <1> 	call	.incrementReadPtr									; Increment read pointer
  1510                              <1> 
  1511                              <1> .done:	
  1512 00000AA0 66A1[C80A]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1513 00000AA4 F8                  <1> 	clc															; Clear carry
  1514 00000AA5 C3                  <1> 	ret
  1515                              <1> 
  1516                              <1> .error:
  1517 00000AA6 66A1[C80A]          <1> 	mov		eax, DWORD [.origCluster]							; Restore original cluster
  1518 00000AAA F9                  <1> 	stc															; Set carry
  1519 00000AAB C3                  <1> 	ret
  1520                              <1> 
  1521                              <1> .incrementReadPtr:
  1522 00000AAC 6631C0              <1> 	xor		eax, eax											; Clear EAX
  1523 00000AAF A1[CC0A]            <1> 	mov		ax, WORD [FAT_BPB_BytesPerSec]						; Read sector length
  1524 00000AB2 6631DB              <1> 	xor		ebx, ebx											; Clear EBX
  1525 00000AB5 8A1E[D80A]          <1> 	mov		bl, BYTE [FAT_BPB_SectorsPerCluster]				; Read bytes per sector
  1526                              <1> 
  1527 00000AB9 66F7E3              <1> 	mul		ebx													; EAX = value to add to write ptr
  1528 00000ABC 01C7                <1> 	add		di, ax												; Add cluster length to di
  1529 00000ABE 7107                <1> 	jno		.noOverflow											; If overflow bit isn't set, branch
  1530                              <1> 
  1531 00000AC0 8CC0                <1> 	mov		ax, es												; Read segment we're writing to
  1532 00000AC2 050010              <1> 	add		ax, $1000											; Write in next segment
  1533 00000AC5 8EC0                <1> 	mov		es, ax												; Write to segment register
  1534                              <1> 
  1535                              <1> .noOverflow:
  1536 00000AC7 C3                  <1> 	ret
  1537                              <1> 
  1538                              <1> 	align	4
  1539                              <1> .origCluster:
  1540 00000AC8 00000000            <1> 	dd		0
  1541                              <1> 
  1542                              <1> ;========================================================================================
  1543                              <1> ; Data section
  1544                              <1> ;========================================================================================
  1545                              <1> 	align	4
  1546                              <1> FAT_BPB_BytesPerSec: ; file offset 11
  1547 00000ACC 0000                <1> 	dw		0
  1548                              <1> FAT_BPB_FSInfo: ; file offset 48, FAT32 only
  1549 00000ACE 0000                <1> 	dw		0
  1550                              <1> FAT_BPB_ExtFlags: ; file offset 40, FAT32 only
  1551 00000AD0 0000                <1> 	dw		0
  1552                              <1> FAT_BPB_FSVer: ; file offset 42, FAT32 only
  1553 00000AD2 0000                <1> 	dw		0
  1554                              <1> 
  1555                              <1> 	align	4
  1556                              <1> FAT_BPB_RootClus: ; file offset 44, FAT32 only
  1557 00000AD4 00000000            <1> 	dd		0
  1558                              <1> FAT_BPB_SectorsPerCluster: ; file offset 13
  1559 00000AD8 00                  <1> 	db		0
  1560                              <1> 
  1561 00000AD9 90                  <1> 	align	2
  1562                              <1> FAT_BPB_ReservedSectors: ; file offset 14
  1563 00000ADA 0000                <1> 	dw		0
  1564                              <1> FAT_BPB_NumFATs: ; file offset 16
  1565 00000ADC 00                  <1> 	db		0
  1566                              <1> 
  1567 00000ADD 90                  <1> 	align	2
  1568                              <1> FAT_BPB_RootEntCnt:	; file offset 17
  1569 00000ADE 0000                <1> 	dw		0
  1570                              <1> 
  1571                              <1> 	align	4
  1572                              <1> FAT_BPB_FATSz: ; file offset 22 if FAT16, 36 if FAT32 and word at 22 is 0
  1573 00000AE0 00000000            <1> 	dd		0
  1574                              <1> 
  1575                              <1> ; Works with FAT32
  1576                              <1> ; For the total sector count, try to read BPB_FATSz16 first (19), then the 32-bit at off 32
  1577                              <1> FAT_BPB_TotSec: ; file offset 32 if 19 = 0
  1578 00000AE4 00000000            <1> 	dd		0
  1579                              <1> 
  1580                              <1> ; Calculated when identifying FS
  1581                              <1> FAT_RootDirSectors:
  1582 00000AE8 0000                <1> 	dw		0
  1583                              <1> 
  1584 00000AEA 90<rept>            <1> 	align	4
  1585                              <1> FAT_DataSectors:
  1586 00000AEC 00000000            <1> 	dd		0
  1587                              <1> FAT_FirstDataSector:
  1588 00000AF0 00000000            <1> 	dd		0
  1589                              <1> FAT_FirstClusterLocation:
  1590 00000AF4 00000000            <1> 	dd		0
  1591                              <1> FAT_TotalClusters:
  1592 00000AF8 00000000            <1> 	dd		0
  1593                              <1> 
  1594                              <1> ; Offset into drive in sectors to the start of the FAT partition
  1595                              <1> FAT_PartitionOffset:
  1596 00000AFC 00000000            <1> 	dd		0
  1597                              <1> FAT_Type:
  1598 00000B00 00                  <1> 	db		0
  1599                              <1> 
  1600                              <1> ; BIOS drive to read from
  1601                              <1> FAT_Drive:
  1602 00000B01 00                  <1> 	db		0
  1603                              <1> 
  1604 00000B02 90<rept>            <1> 	align	4
  1605                              <1> FAT_LastLoadedSector:
  1606 00000B04 00000000            <1> 	dd		0
  1607                              <1> 
  1608                              <1> 	align	4
  1609                              <1> FAT_ERTable:
  1610 00000B08 10                  <1> 	db	$10
  1611 00000B09 00                  <1> 	db	0
  1612 00000B0A 0000                <1> 	dw	0														; Num blocks
  1613 00000B0C 0000                <1> 	dw	0														; Dest
  1614 00000B0E 0000                <1> 	dw	0														; Memory page
  1615 00000B10 00000000            <1> 	dd	0														; Starting LBA
  1616 00000B14 00000000            <1> 	dd	0	
  1617                              <1> 
  1618 00000B18 90<rept>            <1> 	align	$10
  1619                              <1> FAT_ReadBuffer:
  1620                                  
  1621                                  	align 4
  1622                                  
  1623                                  SectorBuf:
  1624 00000B20 00<rept>                	times	512 db 0
